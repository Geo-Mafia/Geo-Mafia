import * as i1 from '@nativescript/core';
import { View, LayoutBase, ContentView, ProxyViewContainer, Page, platformNames, GridLayout, Application, Trace, Utils, TextView, Color, removeTaggedAdditionalCSS, profile, AbsoluteLayout, ActivityIndicator, Button, DatePicker, DockLayout, Frame, HtmlView, Image, Label, ListPicker, ListView, Placeholder, Progress, Repeater, RootLayout, ScrollView, SearchBar, SegmentedBar, SegmentedBarItem, Slider, StackLayout, FlexboxLayout, Switch, TabView, TextField, TimePicker, WebView, WrapLayout, FormattedString, Span, unsetValue, addTaggedAdditionalCSS, getViewById, Observable, ActionItem, NavigationButton, ActionBar, ObservableArray, TabViewItem, Device, knownFolders, File, KeyframeAnimation, animationTimingFunctionConverter, parseKeyframeDeclarations, CSSHelper, eachDescendant, CssAnimationProperty, path } from '@nativescript/core';
import * as i0 from '@angular/core';
import { InjectionToken, Inject, ComponentRef, Injectable, PlatformRef, NgModuleRef, NgZone, Sanitizer, createPlatformFactory, platformCore, ElementRef, Directive, EventEmitter, Output, NgModule, Optional, ComponentFactoryResolver, ApplicationRef, Injector, ViewContainerRef, Component, ViewChild, ViewEncapsulation, Input, ɵisListLikeIterable, forwardRef, TemplateRef, ChangeDetectionStrategy, ContentChild, HostListener, Host, ɵdetectChanges, NO_ERRORS_SCHEMA, ErrorHandler, SkipSelf, ɵINJECTOR_SCOPE, RendererFactory2, ApplicationModule, ContentChildren, Attribute, isDevMode } from '@angular/core';
import { __decorate, __param, __metadata } from 'tslib';
import * as i1$1 from '@angular/common';
import { DOCUMENT, XhrFactory, LocationStrategy, CommonModule, ViewportScroller, ɵNullViewportScroller, PlatformLocation } from '@angular/common';
import { filter, map, take, distinctUntilChanged, startWith } from 'rxjs/operators';
import { BehaviorSubject, Subject, fromEvent, defer, Observable as Observable$1 } from 'rxjs';
import * as i1$3 from '@angular/router';
import { DefaultUrlSerializer, PRIMARY_OUTLET, NavigationEnd, ActivatedRoute, ChildrenOutletContexts, RouterModule, RouteReuseStrategy } from '@angular/router';
import { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';
import { AnimationBuilder } from '@angular/animations';
import * as i1$2 from '@angular/animations/browser';
import { ɵAnimationEngine, ɵWebAnimationsStyleNormalizer, AnimationDriver, ɵAnimationStyleNormalizer } from '@angular/animations/browser';
import { ɵAnimationRendererFactory, ɵBrowserAnimationBuilder } from '@angular/platform-browser/animations';
import { HttpXhrBackend, HttpResponse, HttpErrorResponse, HttpClientModule, HttpBackend } from '@angular/common/http';

const getClassName = (instance) => instance.constructor.name;
class InvisibleNode extends View {
    constructor(name = '') {
        super();
        this.name = name;
        this.nodeType = 1;
        this.nodeName = getClassName(this);
    }
    toString() {
        return `${this.nodeName}(${this.id})-${this.name}`;
    }
}
class CommentNode extends InvisibleNode {
    constructor(value) {
        super(value);
        this.meta = {
            skipAddToDom: true,
        };
        this.id = CommentNode.id.toString();
        CommentNode.id += 1;
    }
}
CommentNode.id = 0;
class TextNode extends InvisibleNode {
    constructor(value) {
        super(value);
        this._text = '';
        this.callbackMap = new Map();
        this._text = value;
        this.meta = {
            skipAddToDom: true,
        };
        this.id = TextNode.id.toString();
        TextNode.id += 1;
    }
    get text() {
        return this._text;
    }
    set text(t) {
        this._text = t;
        this.notify({ eventName: TextNode.textChangeEvent, object: this, value: t });
    }
    registerTextChange(callback, id) {
        const cb = (evt) => callback(evt.value);
        const cbArr = this.callbackMap.get(id) || [];
        cbArr.push(cb);
        this.callbackMap.set(id, cbArr);
        this.on('textChange', cb);
    }
    unregisterTextChange(id) {
        const cbArr = this.callbackMap.get(id) || [];
        cbArr.forEach((cb) => this.off('textChange', cb));
        this.callbackMap.delete(id);
    }
}
TextNode.textChangeEvent = 'textChange';
TextNode.id = 0;

function isDetachedElement(element) {
    return element && element.meta && element.meta.skipAddToDom;
}
function isView(view) {
    return view instanceof View;
}
function isInvisibleNode(view) {
    return view instanceof InvisibleNode;
}
function isLayout(view) {
    return view instanceof LayoutBase;
}
function isContentView(view) {
    return view instanceof ContentView;
}
function getFirstNativeLikeView(view, extractFromNSParent = false) {
    if (view instanceof ProxyViewContainer) {
        if (view.getChildrenCount() === 0) {
            return null;
        }
        return getFirstNativeLikeView(view.getChildAt(0));
    }
    if (extractFromNSParent) {
        const node = view.parentNode;
        detachViewFromParent(view);
        view.parentNode = node;
    }
    return view;
}
function detachViewFromParent(view) {
    const parent = view?.parent;
    if (!parent) {
        return;
    }
    if (parent.meta && parent.meta.removeChild) {
        parent.meta.removeChild(parent, view);
    }
    else if (isLayout(parent)) {
        parent.removeChild(view);
    }
    else if (isContentView(parent) && parent.content === view) {
        parent.content = null;
    }
    else if (isView(parent)) {
        parent._removeView(view);
    }
}

const APP_ROOT_VIEW = new InjectionToken('NativeScriptAppRootView');
const NATIVESCRIPT_ROOT_MODULE_ID = new InjectionToken('NativeScriptRootModuleId');
const START_PATH = new InjectionToken('NativeScriptStartPath');
const ENABLE_REUSABE_VIEWS = new InjectionToken('NativeScriptEnableReusableViews');
const DISABLE_ROOT_VIEW_HANDLING = new InjectionToken('NativeScriptDisableRootViewHandling');
const DEVICE = new InjectionToken('NativeScriptDevice');
const PAGE_FACTORY = new InjectionToken('NativeScriptPageFactory');
const defaultPageFactory = function (_opts) {
    return new Page();
};

let PlatformNamespaceFilter = class PlatformNamespaceFilter {
    constructor(device) {
        this.device = device;
    }
    runsIn(namespace, next) {
        if (namespace === 'android') {
            return this.device.os === platformNames.android;
        }
        if (namespace === 'ios') {
            return this.device.os === platformNames.ios;
        }
        return next(namespace);
    }
};
PlatformNamespaceFilter = __decorate([
    __param(0, Inject(DEVICE)),
    __metadata("design:paramtypes", [Object])
], PlatformNamespaceFilter);
const NAMESPACE_FILTERS = new InjectionToken('NativeScriptNamespaceFilter');

class NgViewRef {
    constructor(ref) {
        this.ref = ref;
        this.view = ref instanceof ComponentRef ? ref.location.nativeElement : ref.rootNodes.find((v) => !(v instanceof InvisibleNode));
        this.firstNativeLikeView = getFirstNativeLikeView(this.view);
    }
    detachNativeLikeView() {
        detachViewFromParent(this.firstNativeLikeView);
    }
}

class AppHostView extends ContentView {
    constructor(backgroundColor) {
        super();
        this.timeout = -1;
        this.backgroundColor = backgroundColor;
    }
    get ngAppRoot() {
        return this._ngAppRoot;
    }
    set ngAppRoot(value) {
        this._ngAppRoot = value;
    }
    //@ts-ignore
    get content() {
        return this._content;
    }
    set content(value) {
        if (this._content) {
            this._content.parentNode = undefined;
        }
        this._content = value;
        if (value) {
            this._content.parentNode = this;
        }
        this.ngAppRoot = value;
        if (this._content instanceof ProxyViewContainer) {
            const grid = new GridLayout();
            grid.backgroundColor = this.backgroundColor;
            grid.addChild(this._content);
            this.ngAppRoot = grid;
        }
        if (this.ngAppRoot) {
            // maybe use this approach
            // this.scheduleRootChange();
        }
    }
    scheduleRootChange() {
        if (this.timeout === -1) {
            this.timeout = setTimeout(() => {
                //console.log(this.ngAppRoot);
                Application.resetRootView({
                    create: () => this.content
                });
                this.timeout = -1;
            }, 0);
        }
    }
}
class AppHostAsyncView extends GridLayout {
    constructor(backgroundColor) {
        super();
        this.backgroundColor = backgroundColor;
    }
    get ngAppRoot() {
        return this;
    }
    set ngAppRoot(value) {
        // ignored
    }
}

class NativeScriptLoadingService {
    constructor() {
        this.mainModuleReady$ = new BehaviorSubject(false);
        this.readyToDestroy$ = new BehaviorSubject(true);
        this.onMainModuleReady$ = this.mainModuleReady$.pipe(filter((ready) => ready));
    }
    /**
     * delays destroying this module until `notifyReadyToDestroy()`.
     * remember to call `notifyReadyToDestroy()` when done!
     */
    waitUntilNotified() {
        this.readyToDestroy$.next(false);
    }
    /**
     * notifies this module is ready to be destroyed
     */
    notifyReadyToDestroy() {
        this.readyToDestroy$.next(true);
    }
    isMainModuleReady() {
        return this.mainModuleReady$.value;
    }
    ngOnDestroy() {
        this.readyToDestroy$.complete();
        this.mainModuleReady$.complete();
    }
    /**
     * This funcion is called by the bootstrap code when the app is ready
     * @internal
     */
    _notifyMainModuleReady() {
        this.mainModuleReady$.next(true);
    }
}
NativeScriptLoadingService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NativeScriptLoadingService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
NativeScriptLoadingService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NativeScriptLoadingService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NativeScriptLoadingService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class NativeScriptDebug {
    static isLogEnabled() {
        return Trace.isEnabled();
    }
    static animationsLog(message) {
        Trace.write(message, NativeScriptDebug.animationsTraceCategory);
    }
    static rendererLog(msg) {
        Trace.write(msg, NativeScriptDebug.rendererTraceCategory);
    }
    static rendererError(message) {
        Trace.write(message, NativeScriptDebug.rendererTraceCategory, Trace.messageType.error);
    }
    static viewUtilLog(msg) {
        Trace.write(msg, NativeScriptDebug.viewUtilCategory);
    }
    static routerLog(message) {
        Trace.write(message, NativeScriptDebug.routerTraceCategory);
    }
    static routerError(message) {
        Trace.write(message, NativeScriptDebug.routerTraceCategory, Trace.messageType.error);
    }
    static routeReuseStrategyLog(message) {
        Trace.write(message, NativeScriptDebug.routeReuseStrategyTraceCategory);
    }
    static styleError(message) {
        Trace.write(message, Trace.categories.Style, Trace.messageType.error);
    }
    static listViewLog(message) {
        Trace.write(message, NativeScriptDebug.listViewTraceCategory);
    }
    static listViewError(message) {
        Trace.write(message, NativeScriptDebug.listViewTraceCategory, Trace.messageType.error);
    }
    static bootstrapLog(message) {
        Trace.write(message, NativeScriptDebug.bootstrapCategory);
    }
    static bootstrapLogError(message) {
        Trace.write(message, NativeScriptDebug.bootstrapCategory, Trace.messageType.error);
    }
}
NativeScriptDebug.animationsTraceCategory = 'ns-animations';
NativeScriptDebug.rendererTraceCategory = 'ns-renderer';
NativeScriptDebug.viewUtilCategory = 'ns-view-util';
NativeScriptDebug.routerTraceCategory = 'ns-router';
NativeScriptDebug.routeReuseStrategyTraceCategory = 'ns-route-reuse-strategy';
NativeScriptDebug.listViewTraceCategory = 'ns-list-view';
NativeScriptDebug.bootstrapCategory = 'bootstrap';
// TODO: migrate all usage to this - avoids extraneous method executions
NativeScriptDebug.enabled = Trace.isEnabled();

function disableRootViewHanding(view) {
    view.__disable_root_view_handling = true;
}
const preAngularDisposal$ = new Subject();
const postAngularBootstrap$ = new Subject();
/**
 * @deprecated
 */
const onBeforeLivesync = preAngularDisposal$.pipe(filter((v) => v.moduleType === 'main' && v.reason === 'hotreload'), map((v) => v.reference));
/**
 * @deprecated
 */
const onAfterLivesync = postAngularBootstrap$.pipe(filter((v) => v.moduleType === 'main'), map((v) => ({ moduleRef: v.reference })));
if (import.meta['webpackHot']) {
    import.meta['webpackHot'].decline();
    global.__onLiveSyncCore = () => {
        Application.getRootView()?._onCssStateChange();
        // all other changes are applied by runNativeScriptAngularApp
    };
}
function emitModuleBootstrapEvent(ref, name, reason) {
    postAngularBootstrap$.next({
        moduleType: name,
        reference: ref,
        reason,
    });
}
function destroyRef(ref, name, reason) {
    if (ref) {
        if (ref instanceof PlatformRef) {
            preAngularDisposal$.next({
                moduleType: 'platform',
                reference: ref,
                reason: name,
            });
        }
        if (ref instanceof NgModuleRef) {
            preAngularDisposal$.next({
                moduleType: name,
                reference: ref,
                reason,
            });
        }
        ref.destroy();
    }
}
function runZoneSyncTask(fn) {
    if (typeof Zone === 'undefined') {
        return;
    }
    const zone = Zone.current;
    const task = zone.scheduleEventTask('sync_function', fn, {}, () => { }, () => { });
    try {
        // console.log(task.state);
        task.invoke();
        // zone.runTask(task);
        // console.log(task.state);
    }
    finally {
        zone.cancelTask(task);
    }
}
function ZoneCanWorkSync() {
    let canRunSync = false;
    runZoneSyncTask(() => {
        Promise.resolve().then(() => (canRunSync = true));
    });
    return canRunSync;
}
/**
 * Tests if global.__drainMicrotaskQueue can be used to drain microtasks
 * Because of Zone.js, even though the native queue might be drained, zone microtasks might not be
 * @param makeTestDrain should it drain the current microtask queue to ensure the queue can be drained
 * @returns if global.__drainMicrotaskQueue can be called
 */
function nativeQueueCanBeDrained(makeTestDrain) {
    if (typeof global.__drainMicrotaskQueue !== 'function') {
        return false;
    }
    if (!makeTestDrain) {
        return true;
    }
    let canRunSync = false;
    Promise.resolve().then(() => (canRunSync = true));
    global.__drainMicrotaskQueue();
    return canRunSync;
}
/**
 * Runs a function in the most synchronous way possible
 * @param fn function to run
 * @param done function to chain after done
 */
function runSynchronously(fn, done) {
    if (typeof Zone !== 'undefined' && ZoneCanWorkSync()) {
        runZoneSyncTask(fn);
        done?.();
        return;
    }
    if (nativeQueueCanBeDrained(true)) {
        fn();
        global.__drainMicrotaskQueue();
        done?.();
        return;
    }
    fn();
    if (done) {
        Utils.queueMacrotask(done);
    }
}
function runNativeScriptAngularApp(options) {
    let mainModuleRef = null;
    let loadingModuleRef;
    let platformRef = null;
    let bootstrapId = -1;
    const updatePlatformRef = (moduleRef, reason) => {
        const newPlatformRef = moduleRef.injector.get(PlatformRef);
        if (newPlatformRef === platformRef) {
            return;
        }
        destroyRef(platformRef, reason);
        platformRef = newPlatformRef;
        platformRef.onDestroy(() => (platformRef = platformRef === newPlatformRef ? null : platformRef));
    };
    let launchEventDone = true;
    let targetRootView = null;
    const setRootView = (ref) => {
        if (bootstrapId === -1) {
            // treat edge cases
            return;
        }
        if (ref instanceof NgModuleRef) {
            if (ref.injector.get(DISABLE_ROOT_VIEW_HANDLING, false)) {
                return;
            }
        }
        else {
            if (ref['__disable_root_view_handling']) {
                return;
            }
        }
        Application.getRootView()?._closeAllModalViewsInternal(); // cleanup old rootview
        NativeScriptDebug.bootstrapLog(`Setting RootView ${launchEventDone ? 'outside of' : 'during'} launch event`);
        // TODO: check for leaks when root view isn't properly destroyed
        if (ref instanceof View) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.bootstrapLog(`Setting RootView to ${ref}`);
            }
            if (launchEventDone) {
                Application.resetRootView({
                    create: () => ref,
                });
            }
            else {
                targetRootView = ref;
            }
            return;
        }
        const view = ref.injector.get(APP_ROOT_VIEW);
        const newRoot = view instanceof AppHostView ? view.content : view;
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.bootstrapLog(`Setting RootView to ${newRoot}`);
        }
        if (launchEventDone) {
            Application.resetRootView({
                create: () => newRoot,
            });
        }
        else {
            targetRootView = newRoot;
        }
    };
    const showErrorUI = (error) => {
        const message = error.message + '\n\n' + error.stack;
        const errorTextBox = new TextView();
        errorTextBox.text = message;
        errorTextBox.color = new Color('red');
        setRootView(errorTextBox);
    };
    const bootstrapRoot = (reason) => {
        try {
            bootstrapId = Date.now();
            const currentBootstrapId = bootstrapId;
            let bootstrapped = false;
            let onMainBootstrap = () => {
                setRootView(mainModuleRef);
            };
            runSynchronously(() => options.appModuleBootstrap(reason).then((ref) => {
                if (currentBootstrapId !== bootstrapId) {
                    // this module is old and not needed anymore
                    // this may happen when developer uses async app initializer and the user exits the app before this bootstraps
                    ref.destroy();
                    return;
                }
                mainModuleRef = ref;
                ref.onDestroy(() => (mainModuleRef = mainModuleRef === ref ? null : mainModuleRef));
                updatePlatformRef(ref, reason);
                const styleTag = ref.injector.get(NATIVESCRIPT_ROOT_MODULE_ID);
                ref.onDestroy(() => {
                    removeTaggedAdditionalCSS(styleTag);
                });
                bootstrapped = true;
                onMainBootstrap();
                emitModuleBootstrapEvent(ref, 'main', reason);
                // bootstrapped component: (ref as any)._bootstrapComponents[0];
            }, (err) => {
                bootstrapped = true;
                NativeScriptDebug.bootstrapLogError(`Error bootstrapping app module:\n${err.message}\n\n${err.stack}`);
                showErrorUI(err);
                throw err;
            }), () => {
                if (currentBootstrapId !== bootstrapId) {
                    return;
                }
                if (!bootstrapped) {
                    if (options.loadingModule) {
                        runSynchronously(() => options.loadingModule(reason).then((loadingRef) => {
                            if (currentBootstrapId !== bootstrapId) {
                                // this module is old and not needed anymore
                                // this may happen when developer uses async app initializer and the user exits the app before this bootstraps
                                loadingRef.destroy();
                                return;
                            }
                            loadingModuleRef = loadingRef;
                            loadingModuleRef.onDestroy(() => (loadingModuleRef = loadingModuleRef === loadingRef ? null : loadingModuleRef));
                            updatePlatformRef(loadingRef, reason);
                            const styleTag = loadingModuleRef.injector.get(NATIVESCRIPT_ROOT_MODULE_ID);
                            loadingRef.onDestroy(() => {
                                removeTaggedAdditionalCSS(styleTag);
                            });
                            setRootView(loadingRef);
                            onMainBootstrap = () => {
                                // delay showing the new rootview to avoid flashes
                                Utils.queueMacrotask(() => {
                                    const loadingService = loadingModuleRef.injector.get(NativeScriptLoadingService);
                                    loadingModuleRef.injector.get(NgZone).run(() => {
                                        loadingService._notifyMainModuleReady();
                                    });
                                    loadingService.readyToDestroy$
                                        .pipe(filter((ready) => ready), take(1))
                                        .subscribe(() => {
                                        destroyRef(loadingModuleRef, 'loading', reason);
                                        loadingModuleRef = null;
                                        setRootView(mainModuleRef);
                                    });
                                });
                            };
                            emitModuleBootstrapEvent(loadingModuleRef, 'loading', reason);
                        }, (err) => {
                            NativeScriptDebug.bootstrapLogError(`Error bootstrapping loading module:\n${err.message}\n\n${err.stack}`);
                            showErrorUI(err);
                            throw err;
                        }));
                    }
                    else if (options.launchView) {
                        let launchView = options.launchView(reason);
                        setRootView(launchView);
                        if (launchView.startAnimation) {
                            setTimeout(() => {
                                // ensure launch animation is executed after launchView added to view stack
                                launchView.startAnimation();
                            });
                        }
                        onMainBootstrap = () => {
                            // delay showing the new rootview to avoid flashes
                            Utils.queueMacrotask(() => {
                                if (launchView.cleanup) {
                                    launchView
                                        .cleanup()
                                        .catch()
                                        .then(() => {
                                        launchView = null;
                                        setRootView(mainModuleRef);
                                    });
                                }
                                else {
                                    launchView = null;
                                    setRootView(mainModuleRef);
                                }
                            });
                        };
                    }
                    else {
                        console.warn('App is bootstrapping asynchronously (likely APP_INITIALIZER) but did not provide a launchView or LoadingModule.');
                    }
                }
            });
        }
        catch (err) {
            NativeScriptDebug.bootstrapLogError(`Error in Bootstrap Function:\n${err.message}\n\n${err.stack}`);
        }
    };
    const disposePlatform = (reason) => {
        destroyRef(platformRef, reason);
        platformRef = null;
    };
    const disposeLastModules = (reason) => {
        // reset bootstrap ID to make sure any modules bootstrapped after this are discarded
        bootstrapId = -1;
        destroyRef(loadingModuleRef, 'loading', reason);
        loadingModuleRef = null;
        destroyRef(mainModuleRef, 'main', reason);
        mainModuleRef = null;
    };
    const launchCallback = profile('@nativescript/angular/platform-common.launchCallback', (args) => {
        launchEventDone = false;
        bootstrapRoot('applaunch');
        launchEventDone = true;
        args.root = targetRootView || null;
    });
    const exitCallback = profile('@nativescript/angular/platform-common.exitCallback', (args) => {
        disposeLastModules('appexit');
    });
    let oldAddEventListener;
    if (typeof Zone !== 'undefined' && global.NativeScriptGlobals?.events?.[Zone.__symbol__('addEventListener')]) {
        oldAddEventListener = global.NativeScriptGlobals.events.addEventListener;
        global.NativeScriptGlobals.events.addEventListener = global.NativeScriptGlobals.events[Zone.__symbol__('addEventListener')];
    }
    Application.on(Application.launchEvent, launchCallback);
    Application.on(Application.exitEvent, exitCallback);
    if (oldAddEventListener) {
        global.NativeScriptGlobals.events.addEventListener = oldAddEventListener;
    }
    if (import.meta['webpackHot']) {
        // handle HMR Application.run
        global['__dispose_app_ng_platform__'] = () => {
            disposePlatform('hotreload');
        };
        global['__dispose_app_ng_modules__'] = () => {
            disposeLastModules('hotreload');
        };
        global['__bootstrap_app_ng_modules__'] = () => {
            bootstrapRoot('hotreload');
        };
        global['__cleanup_ng_hot__'] = () => {
            Application.off(Application.launchEvent, launchCallback);
            Application.off(Application.exitEvent, exitCallback);
            disposeLastModules('hotreload');
            disposePlatform('hotreload');
        };
        global['__reboot_ng_modules__'] = (shouldDisposePlatform = false) => {
            disposeLastModules('hotreload');
            if (shouldDisposePlatform) {
                disposePlatform('hotreload');
            }
            bootstrapRoot('hotreload');
        };
        if (!Application.hasLaunched()) {
            Application.run();
            return;
        }
        bootstrapRoot('hotreload');
        return;
    }
    Application.run();
}

class NativeScriptPlatformRefProxy extends PlatformRef {
    constructor(platform, launchView) {
        super();
        this.platform = platform;
        this.launchView = launchView;
    }
    bootstrapModuleFactory(moduleFactory) {
        this.options = {
            appModuleBootstrap: () => this.platform.bootstrapModuleFactory(moduleFactory),
            launchView: () => this.launchView,
        };
        runNativeScriptAngularApp(this.options);
        return null;
    }
    bootstrapModule(moduleType, compilerOptions) {
        this.options = {
            appModuleBootstrap: () => this.platform.bootstrapModule(moduleType, compilerOptions),
        };
        runNativeScriptAngularApp(this.options);
        return null;
    }
    onDestroy(callback) {
        this.platform.onDestroy(callback);
    }
    get injector() {
        return this.platform.injector;
    }
    destroy() {
        this.platform.destroy();
    }
    get destroyed() {
        return this.platform.destroyed;
    }
}

const defaultPageFactoryProvider = { provide: PAGE_FACTORY, useValue: defaultPageFactory };
class NativeScriptSanitizer extends Sanitizer {
    sanitize(_context, value) {
        return value;
    }
}
// TODO: when angular finally exports their scheduler token for ivy CD, provide our own with queueMacroTask
// export function schedulerFactory() {
//   return (fn: any) => {
//     console.log('SCHEDULER');
//     setTimeout(fn, 0);
//   };
// }
class NativeScriptDocument {
    constructor() {
        // Required by the AnimationDriver
        this.body = {
            isOverride: true,
        };
    }
    createElement(tag) {
        throw new Error('NativeScriptDocument is not DOM Document. There is no createElement() method.');
    }
}
const COMMON_PROVIDERS = [defaultPageFactoryProvider, { provide: Sanitizer, useClass: NativeScriptSanitizer, deps: [] }, { provide: DOCUMENT, useClass: NativeScriptDocument, deps: [] }];
const platformNativeScript = createPlatformFactory(platformCore, 'nativescriptDynamic', COMMON_PROVIDERS);
/**
 * @deprecated use runNativeScriptAngularApp instead
 */
const platformNativeScriptDynamic = function (options, extraProviders) {
    console.log('platformNativeScriptDynamic is deprecated, use runNativeScriptAngularApp instead');
    options = options || {};
    extraProviders = extraProviders || [];
    const ngRootView = new AppHostView(new Color(options.backgroundColor || 'white'));
    let launchView = options.launchView;
    if (!launchView && options.async) {
        launchView = new GridLayout();
        launchView.backgroundColor = options.backgroundColor || 'white';
    }
    return new NativeScriptPlatformRefProxy(platformNativeScript([...extraProviders]), launchView);
};

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Throws an exception when attempting to attach a null portal to a host.
 * @docs-private
 */
function throwNullPortalError() {
    throw Error('Must provide a portal to attach');
}
/**
 * Throws an exception when attempting to attach a portal to a host that is already attached.
 * @docs-private
 */
function throwPortalAlreadyAttachedError() {
    throw Error('Host already has a portal attached');
}
/**
 * Throws an exception when attempting to attach a portal to an already-disposed host.
 * @docs-private
 */
function throwPortalOutletAlreadyDisposedError() {
    throw Error('This PortalOutlet has already been disposed');
}
/**
 * Throws an exception when attempting to attach an unknown portal type.
 * @docs-private
 */
function throwUnknownPortalTypeError() {
    throw Error('Attempting to attach an unknown Portal type. BasePortalOutlet accepts either ' + 'a ComponentPortal or a TemplatePortal.');
}
/**
 * Throws an exception when attempting to attach a portal to a null host.
 * @docs-private
 */
function throwNullPortalOutletError() {
    throw Error('Attempting to attach a portal to a null PortalOutlet');
}
/**
 * Throws an exception when attempting to detach a portal that is not attached.
 * @docs-private
 */
function throwNoPortalAttachedError() {
    throw Error('Attempting to detach a portal that is not attached to a host');
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * A `Portal` is something that you want to render somewhere else.
 * It can be attach to / detached from a `PortalOutlet`.
 */
class Portal {
    /** Attach this portal to a host. */
    attach(host) {
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
            if (host == null) {
                throwNullPortalOutletError();
            }
            if (host.hasAttached()) {
                throwPortalAlreadyAttachedError();
            }
        }
        this._attachedHost = host;
        return host.attach(this);
    }
    /** Detach this portal from its host */
    detach() {
        let host = this._attachedHost;
        if (host != null) {
            this._attachedHost = null;
            host.detach();
        }
        else if (typeof ngDevMode === 'undefined' || ngDevMode) {
            throwNoPortalAttachedError();
        }
    }
    /** Whether this portal is attached to a host. */
    get isAttached() {
        return this._attachedHost != null;
    }
    /**
     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by
     * the PortalOutlet when it is performing an `attach()` or `detach()`.
     */
    setAttachedHost(host) {
        this._attachedHost = host;
    }
}
/**
 * A `ComponentPortal` is a portal that instantiates some Component upon attachment.
 */
class ComponentPortal extends Portal {
    constructor(component, viewContainerRef, injector, componentFactoryResolver) {
        super();
        this.component = component;
        this.viewContainerRef = viewContainerRef;
        this.injector = injector;
        this.componentFactoryResolver = componentFactoryResolver;
    }
}
/**
 * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).
 */
class TemplatePortal extends Portal {
    constructor(template, viewContainerRef, context) {
        super();
        this.templateRef = template;
        this.viewContainerRef = viewContainerRef;
        this.context = context;
    }
    get origin() {
        return this.templateRef.elementRef;
    }
    /**
     * Attach the portal to the provided `PortalOutlet`.
     * When a context is provided it will override the `context` property of the `TemplatePortal`
     * instance.
     */
    attach(host, context = this.context) {
        this.context = context;
        return super.attach(host);
    }
    detach() {
        this.context = undefined;
        return super.detach();
    }
}
/**
 * A `DomPortal` is a portal whose DOM element will be taken from its current position
 * in the DOM and moved into a portal outlet, when it is attached. On detach, the content
 * will be restored to its original position.
 */
class DomPortal extends Portal {
    constructor(element) {
        super();
        this.element = element instanceof ElementRef ? element.nativeElement : element;
    }
}
/**
 * Partial implementation of PortalOutlet that handles attaching
 * ComponentPortal and TemplatePortal.
 */
class BasePortalOutlet {
    constructor() {
        /** Whether this host has already been permanently disposed. */
        this._isDisposed = false;
        // @breaking-change 10.0.0 `attachDomPortal` to become a required abstract method.
        this.attachDomPortal = null;
    }
    /** Whether this host has an attached portal. */
    hasAttached() {
        return !!this._attachedPortal;
    }
    /** Attaches a portal. */
    attach(portal) {
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
            if (!portal) {
                throwNullPortalError();
            }
            if (this.hasAttached()) {
                throwPortalAlreadyAttachedError();
            }
            if (this._isDisposed) {
                throwPortalOutletAlreadyDisposedError();
            }
        }
        if (portal instanceof ComponentPortal) {
            this._attachedPortal = portal;
            return this.attachComponentPortal(portal);
        }
        else if (portal instanceof TemplatePortal) {
            this._attachedPortal = portal;
            return this.attachTemplatePortal(portal);
            // @breaking-change 10.0.0 remove null check for `this.attachDomPortal`.
        }
        else if (this.attachDomPortal && portal instanceof DomPortal) {
            this._attachedPortal = portal;
            return this.attachDomPortal(portal);
        }
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
            throwUnknownPortalTypeError();
        }
    }
    /** Detaches a previously attached portal. */
    detach() {
        if (this._attachedPortal) {
            this._attachedPortal.setAttachedHost(null);
            this._attachedPortal = null;
        }
        this._invokeDisposeFn();
    }
    /** Permanently dispose of this portal host. */
    dispose() {
        if (this.hasAttached()) {
            this.detach();
        }
        this._invokeDisposeFn();
        this._isDisposed = true;
    }
    /** @docs-private */
    setDisposeFn(fn) {
        this._disposeFn = fn;
    }
    _invokeDisposeFn() {
        if (this._disposeFn) {
            this._disposeFn();
            this._disposeFn = null;
        }
    }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,
 * the directive instance itself can be attached to a host, enabling declarative use of portals.
 */
class CdkPortal extends TemplatePortal {
    constructor(templateRef, viewContainerRef) {
        super(templateRef, viewContainerRef);
    }
}
CdkPortal.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: CdkPortal, deps: [{ token: i0.TemplateRef }, { token: i0.ViewContainerRef }], target: i0.ɵɵFactoryTarget.Directive });
CdkPortal.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.2.3", type: CdkPortal, selector: "[cdkPortal]", exportAs: ["cdkPortal"], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: CdkPortal, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cdkPortal]',
                    exportAs: 'cdkPortal',
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef }, { type: i0.ViewContainerRef }]; } });
/**
 * Directive version of a PortalOutlet. Because the directive *is* a PortalOutlet, portals can be
 * directly attached to it, enabling declarative use.
 *
 * Usage:
 * `<ng-template [cdkPortalOutlet]="greeting"></ng-template>`
 */
class CdkPortalOutlet extends BasePortalOutlet {
    constructor(_componentFactoryResolver, _viewContainerRef, renderer) {
        super();
        this._componentFactoryResolver = _componentFactoryResolver;
        this._viewContainerRef = _viewContainerRef;
        this.renderer = renderer;
        /** Whether the portal component is initialized. */
        this._isInitialized = false;
        /** Emits when a portal is attached to the outlet. */
        this.attached = new EventEmitter();
        /**
         * Attaches the given DomPortal to this PortalHost by moving all of the portal content into it.
         * @param portal Portal to be attached.
         * @deprecated To be turned into a method.
         * @breaking-change 10.0.0
         */
        this.attachDomPortal = (portal) => {
            const element = portal.element;
            if (!element.parentNode && (typeof ngDevMode === 'undefined' || ngDevMode)) {
                throw Error('DOM portal content must be attached to a parent node.');
            }
            // Anchor used to save the element's previous position so
            // that we can restore it when the portal is detached.
            const anchorNode = this.renderer.createComment('dom-portal');
            portal.setAttachedHost(this);
            this.renderer.insertBefore(element.parentNode, anchorNode, element);
            this.renderer.appendChild(this._getRootNode(), element);
            super.setDisposeFn(() => {
                if (anchorNode.parentNode) {
                    this.renderer.insertBefore(anchorNode.parentNode, element, anchorNode);
                    this.renderer.removeChild(anchorNode.parentNode, anchorNode);
                    // anchorNode.parentNode!.replaceChild(element, anchorNode);
                }
            });
        };
    }
    /** Portal associated with the Portal outlet. */
    get portal() {
        return this._attachedPortal;
    }
    set portal(portal) {
        // Ignore the cases where the `portal` is set to a falsy value before the lifecycle hooks have
        // run. This handles the cases where the user might do something like `<div cdkPortalOutlet>`
        // and attach a portal programmatically in the parent component. When Angular does the first CD
        // round, it will fire the setter with empty string, causing the user's content to be cleared.
        if (this.hasAttached() && !portal && !this._isInitialized) {
            return;
        }
        if (this.hasAttached()) {
            super.detach();
        }
        if (portal) {
            super.attach(portal);
        }
        this._attachedPortal = portal;
    }
    /** Component or view reference that is attached to the portal. */
    get attachedRef() {
        return this._attachedRef;
    }
    ngOnInit() {
        this._isInitialized = true;
    }
    ngOnDestroy() {
        super.dispose();
        this._attachedPortal = null;
        this._attachedRef = null;
    }
    /**
     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.
     *
     * @param portal Portal to be attached to the portal outlet.
     * @returns Reference to the created component.
     */
    attachComponentPortal(portal) {
        portal.setAttachedHost(this);
        // If the portal specifies an origin, use that as the logical location of the component
        // in the application tree. Otherwise use the location of this PortalOutlet.
        const viewContainerRef = portal.viewContainerRef != null ? portal.viewContainerRef : this._viewContainerRef;
        const resolver = portal.componentFactoryResolver || this._componentFactoryResolver;
        const componentFactory = resolver.resolveComponentFactory(portal.component);
        const ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.injector);
        // If we're using a view container that's different from the injected one (e.g. when the portal
        // specifies its own) we need to move the component into the outlet, otherwise it'll be rendered
        // inside of the alternate view container.
        if (viewContainerRef !== this._viewContainerRef) {
            this.renderer.appendChild(this._getRootNode(), ref.hostView.rootNodes[0]);
        }
        super.setDisposeFn(() => ref.destroy());
        this._attachedPortal = portal;
        this._attachedRef = ref;
        this.attached.emit(ref);
        return ref;
    }
    /**
     * Attach the given TemplatePortal to this PortalHost as an embedded View.
     * @param portal Portal to be attached.
     * @returns Reference to the created embedded view.
     */
    attachTemplatePortal(portal) {
        portal.setAttachedHost(this);
        const viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context);
        super.setDisposeFn(() => this._viewContainerRef.clear());
        this._attachedPortal = portal;
        this._attachedRef = viewRef;
        this.attached.emit(viewRef);
        return viewRef;
    }
    /** Gets the root node of the portal outlet. */
    _getRootNode() {
        const nativeElement = this._viewContainerRef.element.nativeElement;
        // The directive could be set on a template which will result in a comment
        // node being the root. Use the comment's parent node if that is the case.
        return (!(nativeElement instanceof CommentNode) ? nativeElement : nativeElement.parentNode);
    }
}
CdkPortalOutlet.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: CdkPortalOutlet, deps: [{ token: i0.ComponentFactoryResolver }, { token: i0.ViewContainerRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });
CdkPortalOutlet.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.2.3", type: CdkPortalOutlet, selector: "[cdkPortalOutlet]", inputs: { portal: ["cdkPortalOutlet", "portal"] }, outputs: { attached: "attached" }, exportAs: ["cdkPortalOutlet"], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: CdkPortalOutlet, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cdkPortalOutlet]',
                    exportAs: 'cdkPortalOutlet',
                    inputs: ['portal: cdkPortalOutlet'],
                }]
        }], ctorParameters: function () { return [{ type: i0.ComponentFactoryResolver }, { type: i0.ViewContainerRef }, { type: i0.Renderer2 }]; }, propDecorators: { attached: [{
                type: Output
            }] } });
class PortalModule {
}
PortalModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: PortalModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
PortalModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.2.3", ngImport: i0, type: PortalModule, declarations: [CdkPortal, CdkPortalOutlet], exports: [CdkPortal, CdkPortalOutlet] });
PortalModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: PortalModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: PortalModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [CdkPortal, CdkPortalOutlet],
                    declarations: [CdkPortal, CdkPortalOutlet],
                }]
        }] });

const frameMeta = {
    insertChild: (parent, child) => {
        // Page cannot be added to Frame with _addChildFromBuilder (thwos "use defaultPage" error)
        if (isInvisibleNode(child)) {
            return;
        }
        else if (child instanceof Page) {
            parent.navigate({ create: () => child });
        }
        else {
            throw new Error('Only a Page can be a child of Frame');
        }
    },
};

const elementMap = new Map();
const camelCaseSplit = /([a-z0-9])([A-Z])/g;
const defaultViewMeta = { skipAddToDom: false };
function registerElement(elementName, resolver, meta) {
    const entry = { resolver, meta };
    elementMap.set(elementName, entry);
    elementMap.set(elementName.toLowerCase(), entry);
    elementMap.set(elementName.replace(camelCaseSplit, '$1-$2').toLowerCase(), entry);
}
function getViewClass(elementName) {
    const entry = elementMap.get(elementName) || elementMap.get(elementName.toLowerCase());
    if (!entry) {
        throw new TypeError(`No known component for element ${elementName}.`);
    }
    try {
        return entry.resolver();
    }
    catch (e) {
        throw new TypeError(`Could not load view for: ${elementName}.${e}`);
    }
}
function getViewMeta(nodeName) {
    const entry = elementMap.get(nodeName) || elementMap.get(nodeName.toLowerCase());
    return (entry && entry.meta) || defaultViewMeta;
}
function isKnownView(elementName) {
    return elementMap.has(elementName) || elementMap.has(elementName.toLowerCase());
}
function extractSingleViewRecursive(nodes, nestLevel) {
    const actualNodes = nodes.filter((node) => !(node instanceof InvisibleNode));
    if (actualNodes.length === 0) {
        throw new Error(`No suitable views found in list template! ` + `Nesting level: ${nestLevel}`);
    }
    else if (actualNodes.length > 1) {
        throw new Error(`More than one view found in list template!` + `Nesting level: ${nestLevel}`);
    }
    const rootLayout = actualNodes[0];
    if (!rootLayout) {
        return extractSingleViewRecursive(rootLayout.children, nestLevel + 1);
    }
    const parentLayout = rootLayout.parent;
    if (parentLayout instanceof LayoutBase) {
        const node = rootLayout.parentNode;
        parentLayout.removeChild(rootLayout);
        rootLayout.parentNode = node;
    }
    return rootLayout;
}
/**
 * @deprecated getSingleViewRecursive is deprecated, use extractSingleViewRecursive
 */
function getSingleViewRecursive(nodes, nestLevel) {
    return extractSingleViewRecursive(nodes, nestLevel);
}

// Register default NativeScript components
// Note: ActionBar related components are registerd together with action-bar directives.
function registerNativeScriptViewComponents() {
    if (!global.__ngRegisteredViews) {
        global.__ngRegisteredViews = true;
        registerElement('AbsoluteLayout', () => AbsoluteLayout);
        registerElement('ActivityIndicator', () => ActivityIndicator);
        registerElement('Button', () => Button);
        registerElement('ContentView', () => ContentView);
        registerElement('DatePicker', () => DatePicker);
        registerElement('DockLayout', () => DockLayout);
        registerElement('Frame', () => Frame, frameMeta);
        registerElement('GridLayout', () => GridLayout);
        registerElement('HtmlView', () => HtmlView);
        registerElement('Image', () => Image);
        // Parse5 changes <Image> tags to <img>. WTF!
        registerElement('img', () => Image);
        registerElement('Label', () => Label);
        registerElement('ListPicker', () => ListPicker);
        registerElement('ListView', () => ListView);
        registerElement('Page', () => Page);
        registerElement('Placeholder', () => Placeholder);
        registerElement('Progress', () => Progress);
        registerElement('ProxyViewContainer', () => ProxyViewContainer);
        registerElement('Repeater', () => Repeater);
        registerElement('RootLayout', () => RootLayout);
        registerElement('ScrollView', () => ScrollView);
        registerElement('SearchBar', () => SearchBar);
        registerElement('SegmentedBar', () => SegmentedBar);
        registerElement('SegmentedBarItem', () => SegmentedBarItem);
        registerElement('Slider', () => Slider);
        registerElement('StackLayout', () => StackLayout);
        registerElement('FlexboxLayout', () => FlexboxLayout);
        registerElement('Switch', () => Switch);
        registerElement('TabView', () => TabView);
        registerElement('TextField', () => TextField);
        registerElement('TextView', () => TextView);
        registerElement('TimePicker', () => TimePicker);
        registerElement('WebView', () => WebView);
        registerElement('WrapLayout', () => WrapLayout);
        registerElement('FormattedString', () => FormattedString);
        registerElement('Span', () => Span);
    }
}

// Note: this utility exists from deep core import however results in
// Module not found: Error: Can't resolve '@nativescript/core/ui/core/properties'
function isCssVariable(property) {
    return /^--[^,\s]+?$/.test(property);
}
const ELEMENT_NODE_TYPE = 1;
const XML_ATTRIBUTES = Object.freeze(['style', 'rows', 'columns', 'fontAttributes']);
const whiteSpaceSplitter = /\s+/;
function printNgTree(view) {
    let parent = view;
    while (parent.parent && parent.parent.firstChild) {
        parent = parent.parent;
    }
    printChildrenRecurse(parent);
}
function printChildrenRecurse(parent) {
    const children = parent.firstChild ? [parent.firstChild, ...getChildrenSiblings(parent.firstChild).nextSiblings] : [];
    console.log(`parent: ${parent}, firstChild: ${parent.firstChild}, lastChild: ${parent.lastChild} children: ${children}`);
    if (parent.firstChild) {
        console.log(`----- start ${parent}`);
    }
    children.forEach((c) => printChildrenRecurse(c));
    if (parent.firstChild) {
        console.log(`----- end ${parent}`);
    }
}
function getChildrenSiblings(view) {
    const nextSiblings = [];
    const previousSiblings = [];
    let sibling = view.nextSibling;
    while (sibling) {
        nextSiblings.push(sibling);
        sibling = sibling.nextSibling;
    }
    sibling = view.previousSibling;
    while (sibling) {
        previousSiblings.push(sibling);
        sibling = sibling.previousSibling;
    }
    return {
        previousSiblings,
        nextSiblings,
    };
}
function printSiblingsTree(view) {
    const { previousSiblings, nextSiblings } = getChildrenSiblings(view);
    console.log(`${view} previousSiblings: ${previousSiblings} nextSiblings: ${nextSiblings}`);
}
const propertyMaps = new Map();
class ViewUtil {
    constructor(namespaceFilters, reuseViews) {
        this.namespaceFilters = namespaceFilters;
        this.reuseViews = reuseViews;
    }
    /**
     * Inserts a child into a parrent, preferably before next.
     * @param parent parent view
     * @param child child view to be added
     * @param previous previous element. If present, insert after this.
     * @param next next element. If present, insert before this (previous is ignored).
     */
    insertChild(parent, child, previous, next) {
        if (!parent) {
            return;
        }
        const extendedParent = this.ensureNgViewExtensions(parent);
        const extendedChild = this.ensureNgViewExtensions(child);
        // this should never enter, as angular is supposed to remove the child from the previous parent before calling this
        // but when angular animations are enabled, the removal might be delayed, so we need to ensure this view is not anywhere
        // this seems to only happens to CommentNodes
        if (extendedChild.parentNode) {
            this.removeChild(extendedChild.parentNode, extendedChild);
        }
        // if there's a next child, previous is the previousSibling of it
        if (next) {
            previous = next.previousSibling;
        }
        else if (previous) {
            // if there's a previous, next is the nextSibling of it
            next = previous.nextSibling;
        }
        else {
            // no previous or next, append to the parent
            previous = extendedParent.lastChild; // this can still be undefined if the parent has no children!
        }
        this.insertInList(extendedParent, extendedChild, previous, next);
        if (isDetachedElement(child) || isInvisibleNode(child)) {
            extendedChild.parentNode = extendedParent;
        }
        if (!isDetachedElement(child)) {
            const nextVisual = this.findNextVisual(next);
            this.addToVisualTree(extendedParent, extendedChild, nextVisual);
        }
        else if (isInvisibleNode(extendedChild)) {
            const nextVisual = this.findNextVisual(next);
            this.addInvisibleNode(extendedParent, extendedChild, nextVisual);
        }
        // printNgTree(extendedChild);
    }
    insertBefore(parent, child, refChild) {
        const extendedRef = refChild ? this.ensureNgViewExtensions(refChild) : undefined;
        this.insertChild(parent, child, undefined, extendedRef);
    }
    insertAfter(parent, child, refChild) {
        const extendedRef = refChild ? this.ensureNgViewExtensions(refChild) : undefined;
        this.insertChild(parent, child, extendedRef);
    }
    appendChild(parent, child) {
        this.insertChild(parent, child);
    }
    /**
     * Inserts a view into the parent/sibling linked list
     * !WARNING: this method makes no checks to validate the integrity of previous/next children
     * @param parent parent view
     * @param child child view
     * @param previous previous element. null/undefined for first element
     * @param next next element. null/undefined for last element
     */
    insertInList(parent, child, previous, next) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.viewUtilLog(`ViewUtil.insertInList parent: ${parent}, view: ${child}, ` + `previous: ${previous}, next: ${next}`);
        }
        if (previous) {
            previous.nextSibling = child;
            child.previousSibling = previous;
        }
        else {
            parent.firstChild = child;
        }
        if (next) {
            child.nextSibling = next;
            next.previousSibling = child;
        }
        else {
            parent.lastChild = child;
        }
    }
    addToVisualTree(parent, child, next) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.viewUtilLog(`ViewUtil.addToVisualTree parent: ${parent}, view: ${child}, next: ${next}`);
        }
        if (parent.meta && parent.meta.insertChild) {
            parent.meta.insertChild(parent, child, next);
        }
        else if (isLayout(parent)) {
            this.insertToLayout(parent, child, next);
        }
        else if (isContentView(parent)) {
            parent.content = child;
        }
        else if (parent && parent._addChildFromBuilder) {
            parent._addChildFromBuilder(child.nodeName, child);
        }
    }
    addInvisibleNode(parent, child, next) {
        if (parent.meta?.insertInvisibleNode) {
            parent.meta.insertInvisibleNode(parent, child, next);
        }
        else {
            if (child instanceof TextNode) {
                parent.text = child.text;
                child.registerTextChange((t) => (parent.text = t), parent);
            }
        }
    }
    insertToLayout(parent, child, next) {
        if (child.parent === parent) {
            this.removeLayoutChild(parent, child);
        }
        const nextVisual = this.findNextVisual(next);
        if (nextVisual) {
            const index = parent.getChildIndex(nextVisual);
            parent.insertChild(child, index);
        }
        else {
            parent.addChild(child);
        }
        // parent.eachChild((c) => {console.log(c); return true});
    }
    findNextVisual(view) {
        let next = view;
        while (next && isDetachedElement(next)) {
            next = next.nextSibling;
        }
        return next;
    }
    removeChild(parent, child) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.viewUtilLog(`ViewUtil.removeChild parent: ${parent} child: ${child}`);
        }
        if (!parent) {
            return;
        }
        const extendedParent = this.ensureNgViewExtensions(parent);
        const extendedChild = this.ensureNgViewExtensions(child);
        extendedChild.parentNode = null;
        this.removeFromList(extendedParent, extendedChild);
        if (!isDetachedElement(extendedChild)) {
            this.removeFromVisualTree(extendedParent, extendedChild);
        }
        else if (isInvisibleNode(extendedChild)) {
            this.removeInvisibleNode(extendedParent, extendedChild);
        }
    }
    removeFromList(parent, child) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.viewUtilLog(`ViewUtil.removeFromList parent: ${parent} child: ${child}`);
        }
        // only child. null everything
        if (parent.firstChild === child && parent.lastChild === child) {
            parent.firstChild = null;
            parent.lastChild = null;
            child.nextSibling = null;
            child.previousSibling = null;
            return;
        }
        const previous = child.previousSibling;
        const next = child.nextSibling;
        // is first child, make the next sibling the first child (can be null)
        if (parent.firstChild === child) {
            parent.firstChild = next;
        }
        // is last child, make the previous sibling the last child (can be null)
        if (parent.lastChild === child) {
            parent.lastChild = previous;
        }
        // we have a previous sibling, make it point to the next sibling
        if (previous) {
            previous.nextSibling = next;
        }
        // we have a next sibling, make it point to the previous
        if (next) {
            next.previousSibling = previous;
        }
        // finally, null the siblings
        child.nextSibling = null;
        child.previousSibling = null;
    }
    // NOTE: This one is O(n) - use carefully
    findPreviousElement(parent, child) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.viewUtilLog(`ViewUtil.findPreviousElement parent: ${parent} child: ${child}`);
        }
        let previousVisual;
        if (isLayout(parent)) {
            previousVisual = this.getPreviousVisualElement(parent, child);
        }
        let previous = previousVisual || parent.firstChild;
        // since detached elements are not added to the visual tree,
        // we need to find the actual previous sibling of the view,
        // which may as well be an invisible node
        while (previous && previous !== child && previous.nextSibling !== child) {
            previous = previous.nextSibling;
        }
        return previous;
    }
    getPreviousVisualElement(parent, child) {
        const elementIndex = parent.getChildIndex(child);
        if (elementIndex > 0) {
            return parent.getChildAt(elementIndex - 1);
        }
    }
    // NOTE: This one is O(n) - use carefully
    getChildIndex(parent, child) {
        if (isLayout(parent)) {
            return parent.getChildIndex(child);
        }
        else if (isContentView(parent)) {
            return child === parent.content ? 0 : -1;
        }
    }
    removeFromVisualTree(parent, child) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.viewUtilLog(`ViewUtil.removeFromVisualTree parent: ${parent} child: ${child}`);
        }
        if (parent.meta && parent.meta.removeChild) {
            parent.meta.removeChild(parent, child);
        }
        else if (isLayout(parent)) {
            this.removeLayoutChild(parent, child);
        }
        else if (isContentView(parent) && parent.content === child) {
            parent.content = null;
        }
        else if (isView(parent)) {
            parent._removeView(child);
        }
    }
    removeInvisibleNode(parent, child) {
        if (parent.meta?.removeInvisibleNode) {
            parent.meta.removeInvisibleNode(parent, child);
        }
        else {
            if (child instanceof TextNode) {
                child.unregisterTextChange(parent);
            }
        }
    }
    removeLayoutChild(parent, child) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.viewUtilLog(`ViewUtil.removeLayoutChild parent: ${parent} child: ${child}`);
        }
        const index = parent.getChildIndex(child);
        if (index !== -1) {
            parent.removeChild(child);
        }
    }
    createComment(value) {
        return new CommentNode(value);
    }
    createText(value) {
        return new TextNode(value);
    }
    createView(name) {
        const originalName = name;
        if (!isKnownView(name)) {
            name = 'ProxyViewContainer';
        }
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.viewUtilLog(`Creating view: ${originalName} ${name}`);
        }
        const viewClass = getViewClass(name);
        const view = new viewClass();
        const ngView = this.setNgViewExtensions(view, name);
        ngView.reusable = !!this.reuseViews;
        return ngView;
    }
    ensureNgViewExtensions(view) {
        if (view.hasOwnProperty('meta')) {
            return view;
        }
        else {
            const name = view.cssType;
            const ngView = this.setNgViewExtensions(view, name);
            return ngView;
        }
    }
    setNgViewExtensions(view, name) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.viewUtilLog(`Make into a NgView view: ${view} name: "${name}"`);
        }
        const ngView = view;
        ngView.nodeName = name;
        ngView.meta = getViewMeta(name);
        // we're setting the node type of the view
        // to 'element' because of checks done in the
        // dom animation engine
        ngView.nodeType = ELEMENT_NODE_TYPE;
        return ngView;
    }
    setProperty(view, attributeName, value, namespace) {
        if (!view || (namespace && !this.runsIn(namespace))) {
            return;
        }
        if (attributeName.indexOf('.') !== -1) {
            // Handle nested properties
            const properties = attributeName.split('.');
            attributeName = properties[properties.length - 1];
            let propMap = this.getProperties(view);
            let i = 0;
            while (i < properties.length - 1 && typeof view !== 'undefined') {
                let prop = properties[i];
                if (propMap.has(prop)) {
                    prop = propMap.get(prop);
                }
                view = view[prop];
                propMap = this.getProperties(view);
                i++;
            }
        }
        if (typeof view !== 'undefined') {
            this.setPropertyInternal(view, attributeName, value);
        }
    }
    runsIn(platform) {
        let runs = true;
        const last = () => true;
        if (this.namespaceFilters) {
            let chain = (p) => true;
            for (let i = this.namespaceFilters.length - 1; i >= 0; i--) {
                const currentChain = chain;
                chain = (p) => this.namespaceFilters[i].runsIn(p, currentChain);
            }
            runs = chain(platform);
            runs = runs !== false ? true : false; // undefined means true
            // this.namespaceFilters.some((filter) => {
            // 	const runsInFilter = filter.runsIn(platform);
            // 	if (runsInFilter !== undefined) {
            // 		runs = runsInFilter;
            // 		return true;
            // 	}
            // });
        }
        return runs;
    }
    setPropertyInternal(view, attributeName, value) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.viewUtilLog(`Setting attribute: ${attributeName}=${value} to ${view}`);
        }
        if (attributeName === 'class') {
            this.setClasses(view, value);
            return;
        }
        if (XML_ATTRIBUTES.indexOf(attributeName) !== -1) {
            view[attributeName] = value;
            return;
        }
        const propMap = this.getProperties(view);
        const propertyName = propMap.get(attributeName);
        // Ensure the children of a collection currently have no parent set.
        if (Array.isArray(value)) {
            this.removeParentReferencesFromItems(value);
        }
        if (propertyName) {
            // We have a lower-upper case mapped property.
            view[propertyName] = value;
            return;
        }
        // Unknown attribute value -- just set it to our object as is.
        view[attributeName] = value;
    }
    removeParentReferencesFromItems(items) {
        for (const item of items) {
            if (item.parent && item.parentNode) {
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.viewUtilLog(`Unassigning parent ${item.parentNode} on value: ${item}`);
                }
                item.parent = undefined;
                item.parentNode = undefined;
            }
        }
    }
    getProperties(instance) {
        const type = instance && instance.constructor;
        if (!type) {
            return new Map();
        }
        if (!propertyMaps.has(type)) {
            let propMap = new Map();
            for (let propName in instance) {
                // tslint:disable:forin
                propMap.set(propName.toLowerCase(), propName);
            }
            propertyMaps.set(type, propMap);
        }
        return propertyMaps.get(type);
    }
    cssClasses(view) {
        if (!view.ngCssClasses) {
            view.ngCssClasses = new Map();
        }
        return view.ngCssClasses;
    }
    addClass(view, className) {
        const extendedView = this.ensureNgViewExtensions(view);
        this.cssClasses(extendedView).set(className, true);
        this.syncClasses(extendedView);
    }
    removeClass(view, className) {
        const extendedView = this.ensureNgViewExtensions(view);
        this.cssClasses(extendedView).delete(className);
        this.syncClasses(extendedView);
    }
    setClasses(view, classesValue) {
        let classes = classesValue.split(whiteSpaceSplitter);
        this.cssClasses(view).clear();
        classes.forEach((className) => this.cssClasses(view).set(className, true));
        this.syncClasses(view);
    }
    syncClasses(view) {
        let classValue = Array.from(this.cssClasses(view).keys()).join(' ');
        view.className = classValue;
    }
    setStyle(view, styleName, value) {
        if (isCssVariable(styleName)) {
            view.style.setUnscopedCssVariable(styleName, value);
            view._onCssStateChange();
        }
        else {
            view.style[styleName] = value;
        }
    }
    removeStyle(view, styleName) {
        if (isCssVariable(styleName)) {
            // TODO: expose this on core
            view.style.unscopedCssVariables.delete(styleName);
            view._onCssStateChange();
        }
        else {
            view.style[styleName] = unsetValue;
        }
    }
}

var viewUtil = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ViewUtil: ViewUtil
});

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular
 * application context.
 */
let NativeScriptDomPortalOutlet = class NativeScriptDomPortalOutlet extends BasePortalOutlet {
    constructor(
    /** Element into which the content is projected. */
    outletElement, _componentFactoryResolver, _appRef, _defaultInjector, viewUtil) {
        super();
        this.outletElement = outletElement;
        this._componentFactoryResolver = _componentFactoryResolver;
        this._appRef = _appRef;
        this._defaultInjector = _defaultInjector;
        /**
         * Attaches a DOM portal by transferring its content into the outlet.
         * @param portal Portal to be attached.
         * @deprecated To be turned into a method.
         * @breaking-change 10.0.0
         */
        this.attachDomPortal = (portal) => {
            const element = portal.element;
            if (!element.parentNode && (typeof ngDevMode === 'undefined' || ngDevMode)) {
                throw Error('DOM portal content must be attached to a parent node.');
            }
            // Anchor used to save the element's previous position so
            // that we can restore it when the portal is detached.
            const anchorNode = this._viewUtil.createComment('dom-portal');
            this._viewUtil.insertBefore(element.parentNode, anchorNode, element);
            this._viewUtil.appendChild(this.outletElement, element);
            super.setDisposeFn(() => {
                // We can't use `replaceWith` here because IE doesn't support it.
                if (anchorNode.parentNode) {
                    this._viewUtil.insertBefore(anchorNode.parentNode, element, anchorNode);
                    this._viewUtil.removeChild(anchorNode.parentNode, anchorNode);
                    //anchorNode.parentNode.replaceChild(element, anchorNode);
                }
            });
        };
        this._viewUtil = viewUtil || this._defaultInjector.get(ViewUtil);
    }
    /**
     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.
     * @param portal Portal to be attached
     * @returns Reference to the created component.
     */
    attachComponentPortal(portal) {
        const resolver = portal.componentFactoryResolver || this._componentFactoryResolver;
        const componentFactory = resolver.resolveComponentFactory(portal.component);
        let componentRef;
        // If the portal specifies a ViewContainerRef, we will use that as the attachment point
        // for the component (in terms of Angular's component tree, not rendering).
        // When the ViewContainerRef is missing, we use the factory to create the component directly
        // and then manually attach the view to the application.
        if (portal.viewContainerRef) {
            componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.injector);
            this.setDisposeFn(() => componentRef.destroy());
        }
        else {
            componentRef = componentFactory.create(portal.injector || this._defaultInjector);
            this._appRef.attachView(componentRef.hostView);
            this.setDisposeFn(() => {
                this._appRef.detachView(componentRef.hostView);
                componentRef.destroy();
            });
        }
        // At this point the component has been instantiated, so we move it to the location in the DOM
        // where we want it to be rendered.
        const rootNode = this._getComponentRootNode(componentRef);
        if (rootNode.parent) {
            this._viewUtil.removeChild(rootNode.parent, rootNode);
        }
        this._viewUtil.appendChild(this.outletElement, this._getComponentRootNode(componentRef));
        return componentRef;
    }
    /**
     * Attaches a template portal to the DOM as an embedded view.
     * @param portal Portal to be attached.
     * @returns Reference to the created embedded view.
     */
    attachTemplatePortal(portal) {
        let viewContainer = portal.viewContainerRef;
        let viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context);
        // The method `createEmbeddedView` will add the view as a child of the viewContainer.
        // But for the DomPortalOutlet the view can be added everywhere in the DOM
        // (e.g Overlay Container) To move the view to the specified host element. We just
        // re-append the existing root nodes.
        viewRef.rootNodes.forEach((rootNode) => {
            if (rootNode.parent) {
                this._viewUtil.removeChild(rootNode.parent, rootNode);
            }
            this._viewUtil.appendChild(this.outletElement, rootNode);
        });
        // Note that we want to detect changes after the nodes have been moved so that
        // any directives inside the portal that are looking at the DOM inside a lifecycle
        // hook won't be invoked too early.
        viewRef.detectChanges();
        this.setDisposeFn(() => {
            let index = viewContainer.indexOf(viewRef);
            if (index !== -1) {
                viewContainer.remove(index);
            }
        });
        // TODO(jelbourn): Return locals from view.
        return viewRef;
    }
    /**
     * Clears out a portal from the DOM.
     */
    dispose() {
        super.dispose();
        if (this.outletElement.parentNode != null) {
            this._viewUtil.removeChild(this.outletElement.parentNode, this.outletElement);
        }
    }
    /** Gets the root HTMLElement for an instantiated component. */
    _getComponentRootNode(componentRef) {
        return componentRef.hostView.rootNodes[0];
    }
};
NativeScriptDomPortalOutlet = __decorate([
    __param(4, Optional()),
    __metadata("design:paramtypes", [View,
        ComponentFactoryResolver,
        ApplicationRef,
        Injector,
        ViewUtil])
], NativeScriptDomPortalOutlet);

registerElement('DetachedContainer', () => ProxyViewContainer, {
    skipAddToDom: true,
});
/**
 * Wrapper component used for loading components when navigating
 * It uses DetachedContainer as selector so that it is containerRef is not attached to
 * the visual tree.
 */
// eslint-disable-next-line @angular-eslint/component-class-suffix
class DetachedLoader {
    // tslint:disable-line:component-class-suffix
    constructor(resolver, changeDetector, containerRef, appRef) {
        this.resolver = resolver;
        this.changeDetector = changeDetector;
        this.containerRef = containerRef;
        this.appRef = appRef;
        this.disposeFunctions = [];
    }
    createComponentPortal(componentType, customInjector) {
        return new ComponentPortal(componentType, this.vc, customInjector || this.vc.injector);
    }
    createTemplatePortal(templateRef, context) {
        return new TemplatePortal(templateRef, this.vc, context);
    }
    loadInAppRef(componentType) {
        const factory = this.resolver.resolveComponentFactory(componentType);
        const componentRef = factory.create(this.containerRef.injector);
        this.appRef.attachView(componentRef.hostView);
        this.disposeFunctions.push(() => {
            this.appRef.detachView(componentRef.hostView);
            componentRef.destroy();
        });
        // Component is created, built may not be checked if we are loading
        // inside component with OnPush CD strategy. Mark us for check to be sure CD will reach us.
        // We are inside a promise here so no need for setTimeout - CD should trigger
        // after the promise.
        Trace.write('DetachedLoader.loadInLocation component loaded -> markForCheck', 'detached-loader');
        return componentRef;
    }
    loadInLocation(componentType) {
        return this.vc.createComponent(componentType);
    }
    ngOnDestroy() {
        this.disposeFunctions.forEach((fn) => fn());
    }
    detectChanges() {
        this.changeDetector.markForCheck();
    }
    /**
     * @deprecated use Portals
     */
    loadComponent(componentType) {
        Trace.write('DetachedLoader.loadComponent', 'detached-loader');
        return Promise.resolve(this.loadInAppRef(componentType));
    }
    /**
     * @deprecated use Portals
     */
    loadComponentSync(componentType) {
        Trace.write('DetachedLoader.loadComponentSync', 'detached-loader');
        return this.loadInAppRef(componentType);
    }
    /**
     * @deprecated use Portals
     */
    loadComponentInLocation(componentType) {
        Trace.write('DetachedLoader.loadComponentInLocation', 'detached-loader');
        return this.loadInLocation(componentType);
    }
    /**
     * @deprecated use Portals
     */
    loadWithFactory(factory) {
        const componentRef = factory.create(this.containerRef.injector);
        this.appRef.attachView(componentRef.hostView);
        this.disposeFunctions.push(() => {
            this.appRef.detachView(componentRef.hostView);
            componentRef.destroy();
        });
        return componentRef;
    }
    /**
     * @deprecated use Portals
     */
    loadWithFactoryInLocation(factory) {
        return this.vc.createComponent(factory);
    }
}
DetachedLoader.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: DetachedLoader, deps: [{ token: i0.ComponentFactoryResolver }, { token: i0.ChangeDetectorRef }, { token: i0.ViewContainerRef }, { token: i0.ApplicationRef }], target: i0.ɵɵFactoryTarget.Component });
DetachedLoader.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.3", type: DetachedLoader, selector: "DetachedContainer", viewQueries: [{ propertyName: "vc", first: true, predicate: ["vc"], descendants: true, read: ViewContainerRef, static: true }], ngImport: i0, template: `<Placeholder #loader></Placeholder>
    <ng-container #vc></ng-container>
    <ng-content></ng-content>`, isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: DetachedLoader, decorators: [{
            type: Component,
            args: [{
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: 'DetachedContainer',
                    template: `<Placeholder #loader></Placeholder>
    <ng-container #vc></ng-container>
    <ng-content></ng-content>`,
                }]
        }], ctorParameters: function () { return [{ type: i0.ComponentFactoryResolver }, { type: i0.ChangeDetectorRef }, { type: i0.ViewContainerRef }, { type: i0.ApplicationRef }]; }, propDecorators: { vc: [{
                type: ViewChild,
                args: ['vc', { read: ViewContainerRef, static: true }]
            }] } });

class NativescriptXhrFactory extends XhrFactory {
    build() {
        return new XMLHttpRequest();
    }
}
NativescriptXhrFactory.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NativescriptXhrFactory, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
NativescriptXhrFactory.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NativescriptXhrFactory });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NativescriptXhrFactory, decorators: [{
            type: Injectable
        }] });

const addStyleToCss = profile('"renderer".addStyleToCss', function addStyleToCss(style, tag) {
    if (tag) {
        addTaggedAdditionalCSS(style, tag);
    }
    else {
        Application.addCss(style);
    }
});
function runInRootZone(fn) {
    if (typeof Zone === 'undefined') {
        return fn();
    }
    return Zone.root.run(fn);
}
function inRootZone() {
    return function (target, key, descriptor) {
        const childFunction = descriptor.value;
        descriptor.value = function (...args) {
            const fn = childFunction.bind(this);
            return runInRootZone(() => fn(...args));
        };
        return descriptor;
    };
}
let NativeScriptRendererFactory = class NativeScriptRendererFactory {
    constructor(rootView, namespaceFilters, rootModuleID, reuseViews) {
        this.rootView = rootView;
        this.namespaceFilters = namespaceFilters;
        this.rootModuleID = rootModuleID;
        this.reuseViews = reuseViews;
        this.componentRenderers = new Map();
        // backwards compatibility with RadListView
        this.viewUtil = new ViewUtil(this.namespaceFilters, this.reuseViews);
        if (typeof this.reuseViews !== 'boolean') {
            this.reuseViews = false; // default to false
        }
        this.defaultRenderer = new NativeScriptRenderer(rootView, namespaceFilters, this.reuseViews);
    }
    createRenderer(hostElement, type) {
        if (NativeScriptDebug.enabled) {
            NativeScriptDebug.rendererLog(`NativeScriptRendererFactory.createRenderer ${hostElement}. type.id: ${type.id} type.encapsulation: ${type.encapsulation}`);
        }
        if (!hostElement || !type) {
            return this.defaultRenderer;
        }
        let renderer = this.componentRenderers.get(type.id);
        /**
         *! WARNING
         *! We're reusing the renderer for the components
         *! this might cause unexpected behavior as the "rootView" is an arbitrary hostElement
         *! also, the renderer has it's .destroy() called!
         *! might be useful to create a BaseEmulatedRender and a ProxyEmulatedRender
         *! every component type gets a BaseEmulatedRender (singleton) which is passed to ProxyEmulatedRender
         *! ProxyEmulatedRenderer registers with BaseEmulatedRender so we can clean up things like CSS when it's not needed
         *! this might be useful if we find a way to HMR component styling without a full rebootstrap
         */
        if (renderer) {
            if (renderer instanceof EmulatedRenderer) {
                renderer.applyToHost(hostElement);
            }
            return renderer;
        }
        if (type.encapsulation === ViewEncapsulation.None) {
            type.styles.map((s) => s.toString()).forEach((v) => addStyleToCss(v, this.rootModuleID));
            renderer = this.defaultRenderer;
        }
        else {
            renderer = new EmulatedRenderer(type, hostElement, this.namespaceFilters, this.rootModuleID, this.reuseViews);
            renderer.applyToHost(hostElement);
        }
        this.componentRenderers.set(type.id, renderer);
        return renderer;
    }
    // begin?(): void {
    //     throw new Error("Method not implemented.");
    // }
    // end?(): void {
    //     throw new Error("Method not implemented.");
    // }
    whenRenderingDone() {
        if (!this.rootView) {
            return Promise.resolve();
        }
        return new Promise((resolve) => {
            let interval = 0;
            function scheduleResolve() {
                // iOS really hates synchronous things...
                // Utils.queueMacrotask(resolve);
                setTimeout(resolve, 15);
            }
            function fireWhenLoaded() {
                const view = rootFactory();
                if (view.isLoaded) {
                    scheduleResolve();
                }
                else {
                    view.once('loaded', scheduleResolve);
                }
            }
            const rootFactory = () => (this.rootView instanceof ContentView ? this.rootView.content : this.rootView);
            if (!rootFactory()) {
                interval = setInterval(() => {
                    if (rootFactory()) {
                        clearInterval(interval);
                        fireWhenLoaded();
                    }
                }, 10);
            }
            else {
                fireWhenLoaded();
            }
        });
        // throw new Error("Method not implemented.");
    }
};
NativeScriptRendererFactory = __decorate([
    __param(0, Inject(APP_ROOT_VIEW)),
    __param(1, Inject(NAMESPACE_FILTERS)),
    __param(2, Inject(NATIVESCRIPT_ROOT_MODULE_ID)),
    __param(3, Optional()),
    __param(3, Inject(ENABLE_REUSABE_VIEWS)),
    __metadata("design:paramtypes", [View, Array, Object, Object])
], NativeScriptRendererFactory);
class NativeScriptRenderer {
    constructor(rootView, namespaceFilters, reuseViews) {
        this.rootView = rootView;
        this.namespaceFilters = namespaceFilters;
        this.reuseViews = reuseViews;
        this.viewUtil = new ViewUtil(this.namespaceFilters, this.reuseViews);
        this.destroyNode = (node) => runInRootZone(() => {
            if (NativeScriptDebug.enabled) {
                NativeScriptDebug.rendererLog(`NativeScriptRenderer.destroyNode node: ${node}`);
            }
            if (node?.destroyNode) {
                node?.destroyNode();
            }
        });
    }
    get data() {
        throw new Error('Method not implemented.');
    }
    destroy() {
        if (NativeScriptDebug.enabled) {
            NativeScriptDebug.rendererLog('NativeScriptRenderer.destroy');
        }
    }
    createElement(name, namespace) {
        if (NativeScriptDebug.enabled) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.createElement: ${name}`);
        }
        let oldName;
        if (!isKnownView(name)) {
            oldName = name;
            name = 'ProxyViewContainer';
        }
        const view = this.viewUtil.createView(name);
        if (oldName) {
            view.customCSSName = oldName;
        }
        return view;
    }
    createComment(value) {
        if (NativeScriptDebug.enabled) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.createComment ${value}`);
        }
        return this.viewUtil.createComment(value);
    }
    createText(value) {
        if (NativeScriptDebug.enabled) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.createText ${value}`);
        }
        return this.viewUtil.createText(value);
    }
    appendChild(parent, newChild) {
        if (NativeScriptDebug.enabled) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.appendChild child: ${newChild} parent: ${parent}`);
        }
        this.viewUtil.appendChild(parent, newChild);
    }
    insertBefore(parent, newChild, refChild) {
        if (NativeScriptDebug.enabled) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.insertBefore child: ${newChild} ` + `parent: ${parent} refChild: ${refChild}`);
        }
        this.viewUtil.insertBefore(parent, newChild, refChild);
    }
    removeChild(parent, oldChild, isHostElement) {
        if (NativeScriptDebug.enabled) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.removeChild child: ${oldChild} parent: ${parent}`);
        }
        this.viewUtil.removeChild(parent, oldChild);
    }
    selectRootElement(selectorOrNode, preserveContent) {
        if (NativeScriptDebug.enabled) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.selectRootElement: ${selectorOrNode}`);
        }
        if (selectorOrNode instanceof View) {
            return selectorOrNode;
        }
        if (selectorOrNode && selectorOrNode[0] === '#') {
            const result = getViewById(this.rootView, selectorOrNode.slice(1));
            return (result || this.rootView);
        }
        if (typeof selectorOrNode === 'string') {
            const view = this.viewUtil.createView(selectorOrNode);
            if (getFirstNativeLikeView(view) === view) {
                // view is nativelike!
                this.appendChild(this.rootView, view);
                return view;
            }
        }
        return this.rootView;
    }
    parentNode(node) {
        if (NativeScriptDebug.enabled) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.parentNode for node: ${node} is ${node.parentNode}`);
        }
        return node.parentNode;
    }
    nextSibling(node) {
        if (NativeScriptDebug.enabled) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.nextSibling of ${node} is ${node.nextSibling}`);
        }
        return node.nextSibling;
    }
    setAttribute(el, name, value, namespace) {
        if (NativeScriptDebug.enabled) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.setAttribute ${namespace ? namespace + ':' : ''}${el}.${name} = ${value}`);
        }
        this.viewUtil.setProperty(el, name, value, namespace);
    }
    removeAttribute(el, name, namespace) {
        if (NativeScriptDebug.enabled) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.removeAttribute ${namespace ? namespace + ':' : ''}${el}.${name}`);
        }
    }
    addClass(el, name) {
        if (NativeScriptDebug.enabled) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.addClass ${name}`);
        }
        this.viewUtil.addClass(el, name);
    }
    removeClass(el, name) {
        if (NativeScriptDebug.enabled) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.removeClass ${name}`);
        }
        this.viewUtil.removeClass(el, name);
    }
    setStyle(el, style, value, flags) {
        if (NativeScriptDebug.enabled) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.setStyle: ${el}, ${style} = ${value}`);
        }
        this.viewUtil.setStyle(el, style, value);
    }
    removeStyle(el, style, flags) {
        if (NativeScriptDebug.enabled) {
            NativeScriptDebug.rendererLog('NativeScriptRenderer.removeStyle: ${styleName}');
        }
        this.viewUtil.removeStyle(el, style);
    }
    setProperty(el, name, value) {
        if (NativeScriptDebug.enabled) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.setProperty ${el}.${name} = ${value}`);
        }
        this.viewUtil.setProperty(el, name, value);
    }
    setValue(node, value) {
        if (NativeScriptDebug.enabled) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.setValue renderNode: ${node}, value: ${value}`);
        }
        if (node instanceof TextNode) {
            node.text = value;
        }
        // throw new Error("Method not implemented.");
    }
    listen(target, eventName, callback) {
        // throw new Error("Method not implemented.");
        if (NativeScriptDebug.enabled) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.listen: ${eventName}`);
        }
        target.on(eventName, callback);
        if (eventName === View.loadedEvent && target.isLoaded) {
            // we must create a new obervable here to ensure that the event goes through whatever zone patches are applied
            const obs = new Observable();
            obs.once(eventName, callback);
            obs.notify({
                eventName,
                object: target,
            });
        }
        return () => target.off(eventName, callback);
    }
}
__decorate([
    inRootZone(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", void 0)
], NativeScriptRenderer.prototype, "createElement", null);
__decorate([
    inRootZone(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", void 0)
], NativeScriptRenderer.prototype, "createComment", null);
__decorate([
    inRootZone(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", void 0)
], NativeScriptRenderer.prototype, "createText", null);
__decorate([
    inRootZone(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [View, View]),
    __metadata("design:returntype", void 0)
], NativeScriptRenderer.prototype, "appendChild", null);
__decorate([
    inRootZone(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", void 0)
], NativeScriptRenderer.prototype, "insertBefore", null);
__decorate([
    inRootZone(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Boolean]),
    __metadata("design:returntype", void 0)
], NativeScriptRenderer.prototype, "removeChild", null);
__decorate([
    inRootZone(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String, String, String]),
    __metadata("design:returntype", void 0)
], NativeScriptRenderer.prototype, "setAttribute", null);
__decorate([
    inRootZone(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String]),
    __metadata("design:returntype", void 0)
], NativeScriptRenderer.prototype, "addClass", null);
__decorate([
    inRootZone(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String]),
    __metadata("design:returntype", void 0)
], NativeScriptRenderer.prototype, "removeClass", null);
__decorate([
    inRootZone(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String, Object, Number]),
    __metadata("design:returntype", void 0)
], NativeScriptRenderer.prototype, "setStyle", null);
__decorate([
    inRootZone(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String, Number]),
    __metadata("design:returntype", void 0)
], NativeScriptRenderer.prototype, "removeStyle", null);
__decorate([
    inRootZone(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String, Object]),
    __metadata("design:returntype", void 0)
], NativeScriptRenderer.prototype, "setProperty", null);
// CONTENT_ATTR not exported from nativescript-renderer - we need it for styles application.
const COMPONENT_REGEX = /%COMP%/g;
const ATTR_SANITIZER = /-/g;
const COMPONENT_VARIABLE = '%COMP%';
const HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;
const CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;
const replaceNgAttribute = function (input, componentId) {
    return input.replace(COMPONENT_REGEX, componentId);
};
const addScopedStyleToCss = profile(`"renderer".addScopedStyleToCss`, function addScopedStyleToCss(style, tag) {
    if (tag) {
        addTaggedAdditionalCSS(style, tag);
    }
    else {
        Application.addCss(style);
    }
});
class EmulatedRenderer extends NativeScriptRenderer {
    constructor(component, rootView, namespaceFilters, rootModuleId, reuseViews) {
        super(rootView, namespaceFilters, reuseViews);
        this.rootModuleId = rootModuleId;
        const componentId = component.id.replace(ATTR_SANITIZER, '_');
        this.contentAttr = replaceNgAttribute(CONTENT_ATTR, componentId);
        this.hostAttr = replaceNgAttribute(HOST_ATTR, componentId);
        this.addStyles(component.styles, componentId);
    }
    applyToHost(view) {
        super.setAttribute(view, this.hostAttr, '');
    }
    appendChild(parent, newChild) {
        super.appendChild(parent, newChild);
    }
    createElement(parent, name) {
        const view = super.createElement(parent, name);
        // Set an attribute to the view to scope component-specific css.
        // The property name is pre-generated by Angular.
        super.setAttribute(view, this.contentAttr, '');
        return view;
    }
    addStyles(styles, componentId) {
        styles
            .map((s) => s.toString())
            .map((s) => replaceNgAttribute(s, componentId))
            .forEach((s) => addScopedStyleToCss(s, this.rootModuleId));
    }
}
EmulatedRenderer.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: EmulatedRenderer, deps: "invalid", target: i0.ɵɵFactoryTarget.Injectable });
EmulatedRenderer.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: EmulatedRenderer });
__decorate([
    profile,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, String]),
    __metadata("design:returntype", void 0)
], EmulatedRenderer.prototype, "addStyles", null);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: EmulatedRenderer, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: undefined }, { type: i1.View }, { type: undefined }, { type: undefined }, { type: undefined }]; }, propDecorators: { addStyles: [] } });

class PageService {
    constructor(page, elRef, view) {
        this._pageEvents$ = new Subject();
        if (page) {
            this.page = page;
        }
        else {
            view = view || elRef.nativeElement;
            while (view) {
                if (view instanceof Page) {
                    this.page = view;
                    break;
                }
                view = view.parent;
            }
        }
        this._inPage$ = new BehaviorSubject(!!this.page?.isLoaded);
        if (this.page) {
            this.page.on('navigatedFrom', this.pageEvent, this);
            this.page.on('navigatedTo', this.pageEvent, this);
            this.page.on('navigatingFrom', this.pageEvent, this);
            this.page.on('navigatingTo', this.pageEvent, this);
        }
    }
    get inPage() {
        return this._inPage$.value;
    }
    get inPage$() {
        return this._inPage$.pipe(distinctUntilChanged());
    }
    get pageEvents$() {
        return this._pageEvents$.asObservable();
    }
    ngOnDestroy() {
        if (this.page) {
            this.page.off('navigatedFrom', this.pageEvent, this);
            this.page.off('navigatedTo', this.pageEvent, this);
            this.page.off('navigatingFrom', this.pageEvent, this);
            this.page.off('navigatingTo', this.pageEvent, this);
        }
        this._inPage$.complete();
        this._pageEvents$.complete();
    }
    pageEvent(evt) {
        this._pageEvents$.next(evt);
        switch (evt.eventName) {
            case 'navigatedTo':
                this._inPage$.next(true);
                break;
            case 'navigatedFrom':
                this._inPage$.next(false);
                break;
            default:
        }
    }
}
PageService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: PageService, deps: [{ token: i1.Page, optional: true }, { token: i0.ElementRef, optional: true }, { token: i1.ViewBase, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
PageService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: PageService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: PageService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.Page, decorators: [{
                    type: Optional
                }] }, { type: i0.ElementRef, decorators: [{
                    type: Optional
                }] }, { type: i1.ViewBase, decorators: [{
                    type: Optional
                }] }]; } });

function customFrameComponentFactory(v) {
    return v.element.nativeElement;
}
function customPageFactoryFromFrame(v) {
    return v.page;
}
registerElement('FramePage', () => Frame, {
    insertChild: (parent, child) => {
        if (child instanceof Page) {
            frameMeta.insertChild(parent, child);
            return;
        }
        parent['__ng_page__'].content = child;
    },
});
class FramePageComponent {
    constructor(element, renderer) {
        this.element = element;
        this.actionBarHidden = false;
        this.page = renderer.createElement('Page');
        element.nativeElement['__ng_page__'] = this.page;
        renderer.appendChild(element.nativeElement, this.page);
    }
    ngOnChanges(changes) {
        if (changes.actionBarHidden && changes.actionBarHidden.previousValue !== changes.actionBarHidden.currentValue) {
            if (this.page) {
                this.page.actionBarHidden = !!this.actionBarHidden;
            }
        }
    }
    ngAfterViewInit() {
        if (this.page) {
            this.page.actionBarHidden = !!this.actionBarHidden;
        }
    }
}
FramePageComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: FramePageComponent, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
FramePageComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.3", type: FramePageComponent, selector: "FramePage", inputs: { actionBarHidden: "actionBarHidden" }, providers: [
        {
            provide: Frame,
            useFactory: customFrameComponentFactory,
            deps: [FramePageComponent],
        },
        {
            provide: Page,
            useFactory: customPageFactoryFromFrame,
            deps: [FramePageComponent],
        },
        PageService,
    ], usesOnChanges: true, ngImport: i0, template: `<ng-content></ng-content>`, isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: FramePageComponent, decorators: [{
            type: Component,
            args: [{
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: 'FramePage',
                    template: `<ng-content></ng-content>`,
                    providers: [
                        {
                            provide: Frame,
                            useFactory: customFrameComponentFactory,
                            deps: [FramePageComponent],
                        },
                        {
                            provide: Page,
                            useFactory: customPageFactoryFromFrame,
                            deps: [FramePageComponent],
                        },
                        PageService,
                    ],
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }]; }, propDecorators: { actionBarHidden: [{
                type: Input
            }] } });

function customFrameDirectiveFactory(v) {
    return v.element.nativeElement;
}
class FrameDirective {
    constructor(element) {
        this.element = element;
    }
}
FrameDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: FrameDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
FrameDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.2.3", type: FrameDirective, selector: "Frame", providers: [
        {
            provide: Frame,
            useFactory: customFrameDirectiveFactory,
            deps: [FrameDirective],
        },
    ], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: FrameDirective, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'Frame',
                    providers: [
                        {
                            provide: Frame,
                            useFactory: customFrameDirectiveFactory,
                            deps: [FrameDirective],
                        },
                    ],
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; } });

function customPageFactory(v) {
    return v.element.nativeElement;
}
class PageDirective {
    constructor(element) {
        this.element = element;
    }
}
PageDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: PageDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
PageDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.2.3", type: PageDirective, selector: "Page", providers: [
        {
            provide: Page,
            useFactory: customPageFactory,
            deps: [PageDirective],
        },
        PageService,
    ], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: PageDirective, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'Page',
                    providers: [
                        {
                            provide: Page,
                            useFactory: customPageFactory,
                            deps: [PageDirective],
                        },
                        PageService,
                    ],
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; } });

class FramePageModule {
}
FramePageModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: FramePageModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
FramePageModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.2.3", ngImport: i0, type: FramePageModule, declarations: [FrameDirective, PageDirective, FramePageComponent], exports: [FrameDirective, PageDirective, FramePageComponent] });
FramePageModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: FramePageModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: FramePageModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [FrameDirective, PageDirective, FramePageComponent],
                    exports: [FrameDirective, PageDirective, FramePageComponent],
                }]
        }] });

function isPresent(obj) {
    return obj !== undefined && obj !== null;
}
function isBlank(obj) {
    return obj === undefined || obj === null;
}

function isActionItem(view) {
    return view instanceof ActionItem;
}
function isNavigationButton(view) {
    return view instanceof NavigationButton;
}
const actionBarMeta = {
    skipAddToDom: true,
    insertChild: (parent, child, next) => {
        if (isInvisibleNode(child)) {
            return;
        }
        else if (isNavigationButton(child)) {
            parent.navigationButton = child;
            child.parentNode = parent;
        }
        else if (isActionItem(child)) {
            addActionItem(parent, child, next);
            child.parentNode = parent;
        }
        else if (isView(child)) {
            parent.titleView = child;
        }
    },
    removeChild: (parent, child) => {
        if (isInvisibleNode(child)) {
            return;
        }
        else if (isNavigationButton(child)) {
            if (parent.navigationButton === child) {
                parent.navigationButton = null;
            }
            child.parentNode = null;
        }
        else if (isActionItem(child)) {
            parent.actionItems.removeItem(child);
            child.parentNode = null;
        }
        else if (isView(child) && parent.titleView && parent.titleView === child) {
            parent.titleView = null;
        }
    },
};
registerElement('ActionBar', () => ActionBar, actionBarMeta);
registerElement('ActionItem', () => ActionItem);
registerElement('NavigationButton', () => NavigationButton);
const addActionItem = (bar, item, next) => {
    if (next) {
        insertActionItemBefore(bar, item, next);
    }
    else {
        appendActionItem(bar, item);
    }
};
const insertActionItemBefore = (bar, item, next) => {
    const actionItems = bar.actionItems;
    const actionItemsCollection = actionItems.getItems();
    const indexToInsert = actionItemsCollection.indexOf(next);
    actionItemsCollection.splice(indexToInsert, 0, item);
    actionItems.setItems(actionItemsCollection);
};
const appendActionItem = (bar, item) => {
    bar.actionItems.addItem(item);
};
class ActionBarComponent {
    constructor(element, page) {
        this.element = element;
        this.page = page;
        if (!this.page) {
            throw new Error('No Page found in ActionBarComponent.\n' + 'Only a Page can contain an ActionBar, so please ensure ActionBar is only used inside a Component that is routed via page-router-outlet or is contained in a Page.\n' + 'Example for root action bars in AppComponent: <Frame><Page><ActionBar>....</ActionBar></Page></Frame>');
        }
        if (isBlank(this.page.actionBarHidden)) {
            this.page.actionBarHidden = false;
        }
        this.page.actionBar = this.element.nativeElement;
        this.page.actionBar.update();
    }
}
ActionBarComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: ActionBarComponent, deps: [{ token: i0.ElementRef }, { token: i1.Page, optional: true }], target: i0.ɵɵFactoryTarget.Component });
ActionBarComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.3", type: ActionBarComponent, selector: "ActionBar", ngImport: i0, template: '<ng-content></ng-content>', isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: ActionBarComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'ActionBar',
                    template: '<ng-content></ng-content>',
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i1.Page, decorators: [{
                    type: Optional
                }] }]; } });
class ActionBarScope {
    // tslint:disable-line:component-class-suffix
    constructor(page) {
        this.page = page;
        if (!this.page) {
            throw new Error('Inside ActionBarExtension but no ActionBar found to extend.');
        }
    }
    onNavButtonInit(navBtn) {
        this.page.actionBar.navigationButton = navBtn.element.nativeElement;
    }
    onNavButtonDestroy(navBtn) {
        const nav = navBtn.element.nativeElement;
        if (nav && this.page.actionBar.navigationButton === nav) {
            this.page.actionBar.navigationButton = null;
        }
    }
    onActionInit(item) {
        this.page.actionBar.actionItems.addItem(item.element.nativeElement);
    }
    onActionDestroy(item) {
        if (item.element.nativeElement.actionBar) {
            this.page.actionBar.actionItems.removeItem(item.element.nativeElement);
        }
    }
}
ActionBarScope.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: ActionBarScope, deps: [{ token: i1.Page, optional: true }], target: i0.ɵɵFactoryTarget.Component });
ActionBarScope.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.3", type: ActionBarScope, selector: "ActionBarExtension", ngImport: i0, template: '', isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: ActionBarScope, decorators: [{
            type: Component,
            args: [{
                    selector: 'ActionBarExtension',
                    template: '',
                }]
        }], ctorParameters: function () { return [{ type: i1.Page, decorators: [{
                    type: Optional
                }] }]; } });
class ActionItemDirective {
    constructor(element, ownerScope) {
        this.element = element;
        this.ownerScope = ownerScope;
        if (this.ownerScope) {
            this.ownerScope.onActionInit(this);
        }
    }
    ngOnDestroy() {
        if (this.ownerScope) {
            this.ownerScope.onActionDestroy(this);
        }
    }
}
ActionItemDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: ActionItemDirective, deps: [{ token: i0.ElementRef }, { token: ActionBarScope, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
ActionItemDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.2.3", type: ActionItemDirective, selector: "ActionItem", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: ActionItemDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'ActionItem', // tslint:disable-line:directive-selector
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: ActionBarScope, decorators: [{
                    type: Optional
                }] }]; } });
class NavigationButtonDirective {
    constructor(element, ownerScope) {
        this.element = element;
        this.ownerScope = ownerScope;
        if (this.ownerScope) {
            this.ownerScope.onNavButtonInit(this);
        }
    }
    ngOnDestroy() {
        if (this.ownerScope) {
            this.ownerScope.onNavButtonDestroy(this);
        }
    }
}
NavigationButtonDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NavigationButtonDirective, deps: [{ token: i0.ElementRef }, { token: ActionBarScope, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
NavigationButtonDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.2.3", type: NavigationButtonDirective, selector: "NavigationButton", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NavigationButtonDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'NavigationButton', // tslint:disable-line:directive-selector
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: ActionBarScope, decorators: [{
                    type: Optional
                }] }]; } });

const NG_VIEW = '_ngViewRef';
const TEMPLATED_ITEMS_COMPONENT = new InjectionToken('TemplatedItemsComponent');
class ItemContext {
    constructor($implicit, item, index, even, odd) {
        this.$implicit = $implicit;
        this.item = item;
        this.index = index;
        this.even = even;
        this.odd = odd;
    }
}
class NsTemplatedItem {
    constructor(template, location, onCreate) {
        this.template = template;
        this.location = location;
        this.onCreate = onCreate;
    }
    create(context) {
        const viewRef = this.location.createEmbeddedView(this.template, context ? this.setupItemContext(context) : new ItemContext());
        viewRef.detach(); // create detached, just beware this doesn't always work and the view might run the first CD anyway.
        const resultView = getItemViewRoot(viewRef);
        resultView[NG_VIEW] = viewRef;
        if (this.onCreate) {
            this.onCreate(resultView);
        }
        return resultView;
    }
    update(view, context) {
        const viewRef = this.getEmbeddedViewRef(view);
        this.setupItemContext(context, viewRef);
        viewRef?.detectChanges();
    }
    attach(view) {
        const viewRef = this.getEmbeddedViewRef(view);
        viewRef?.reattach();
        viewRef?.detectChanges();
    }
    detach(view) {
        const viewRef = this.getEmbeddedViewRef(view);
        viewRef?.detach();
    }
    dispose(view) {
        const viewRef = this.getEmbeddedViewRef(view);
        viewRef?.destroy();
    }
    getEmbeddedViewRef(view) {
        let viewRef = view[NG_VIEW];
        // Getting angular view from original element (in cases when ProxyViewContainer
        // is used NativeScript internally wraps it in a StackLayout)
        if (!viewRef && view instanceof LayoutBase && view.getChildrenCount() > 0) {
            viewRef = view.getChildAt(0)[NG_VIEW];
        }
        return viewRef;
    }
    isValid(view) {
        return !!this.getEmbeddedViewRef(view);
    }
    setupItemContext({ index, data }, oldView) {
        const context = oldView ? oldView.context : new ItemContext();
        context.$implicit = data;
        context.item = data;
        context.index = index;
        context.even = index % 2 === 0;
        context.odd = !context.even;
        return context;
    }
}
class ListViewComponent {
    constructor(_elementRef, _iterableDiffers, _changeDetectorRef) {
        this._iterableDiffers = _iterableDiffers;
        this._changeDetectorRef = _changeDetectorRef;
        this._viewToTemplate = new WeakMap();
        this.setupItemView = new EventEmitter();
        this.templatedItemsView = _elementRef.nativeElement;
    }
    get nativeElement() {
        return this.templatedItemsView;
    }
    get items() {
        return this._items;
    }
    set items(value) {
        this._items = value;
        let needDiffer = true;
        if (value instanceof ObservableArray) {
            needDiffer = false;
        }
        if (needDiffer && !this._differ && ɵisListLikeIterable(value)) {
            this._differ = this._iterableDiffers.find(this._items).create((_index, item) => {
                return item;
            });
        }
        this.templatedItemsView.items = this._items;
    }
    ngAfterContentInit() {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.listViewLog('TemplatedItemsView.ngAfterContentInit()');
        }
        this.setItemTemplates();
    }
    ngOnDestroy() {
        this.templatedItemsView = null;
        if (this._templateMap) {
            this._templateMap.clear();
        }
    }
    setItemTemplates() {
        // The itemTemplateQuery may be changed after list items are added that contain <template> inside,
        // so cache and use only the original template to avoid errors.
        this.fallbackItemTemplate = this.itemTemplateQuery;
        if (this.fallbackItemTemplate && !this._templateMap?.has('default')) {
            // apparently you can create a Core ListView without a template...
            // we also add a fallback default for when the user sets multiple templates but no templateSelector
            this.registerTemplate('default', this.fallbackItemTemplate);
        }
        if (this._templateMap) {
            // sometimes templates are registered before loader is ready, so we update here
            this._templateMap.forEach((t) => (t.location = this.loader));
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.listViewLog('Setting templates');
            }
            const templates = [];
            this._templateMap.forEach((value, key) => {
                templates.push({
                    createView: () => null,
                    key,
                });
            });
            this.templatedItemsView.itemTemplates = templates;
        }
    }
    registerTemplate(key, template) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.listViewLog(`registerTemplate for key: ${key}, ${this.loader}`);
        }
        if (!this._templateMap) {
            this._templateMap = new Map();
        }
        this._templateMap.set(key, new NsTemplatedItem(template, this.loader, (v) => this._viewToTemplate.set(v, key)));
    }
    onItemLoading(args) {
        if (!this._templateMap) {
            return;
        }
        const index = args.index;
        const lview = args.object;
        const items = lview.items;
        const currentItem = 'getItem' in items && typeof items.getItem === 'function' ? items.getItem(index) : items[index];
        let template;
        if (args.view) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.listViewLog(`onItemLoading: ${index} - Reusing existing view`);
            }
            let templateKey = this._viewToTemplate.get(args.view);
            if (!templateKey && args.view instanceof LayoutBase && args.view.getChildrenCount() > 0) {
                templateKey = this._viewToTemplate.get(args.view.getChildAt(0));
            }
            if (!templateKey) {
                // this template was not created by us
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.listViewError(`ViewReference not found for item ${index}. View recycling is not working`);
                }
                return;
            }
            template = this._templateMap.get(templateKey);
            template.update(args.view, { index, data: currentItem });
        }
        else {
            // this should never enter if it creates the view
            const templateKey = typeof lview.itemTemplateSelector === 'function' ? lview.itemTemplateSelector(currentItem, index, items) : 'default';
            template = this._templateMap.get(templateKey);
            if (!template) {
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.listViewError(`Template for key '${templateKey}' not found.`);
                }
                return;
            }
            args.view = template.create({ index, data: currentItem });
        }
        this.setupViewRef(template.getEmbeddedViewRef(args.view), currentItem, index, args.view);
        template.attach(args.view);
        this._changeDetectorRef.detectChanges();
    }
    setupViewRef(viewRef, data, index, nativeElement) {
        const context = viewRef.context;
        this.setupItemView.next({ view: viewRef, nativeElement, data: data, index: index, context: context });
    }
    ngDoCheck() {
        if (this._differ) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.listViewLog('ngDoCheck() - execute differ');
            }
            const changes = this._differ.diff(this._items);
            if (changes) {
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.listViewLog('ngDoCheck() - refresh');
                }
                this.templatedItemsView.refresh();
            }
        }
    }
}
ListViewComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: ListViewComponent, deps: [{ token: i0.ElementRef }, { token: i0.IterableDiffers }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
ListViewComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.3", type: ListViewComponent, selector: "ListView", inputs: { items: "items" }, outputs: { setupItemView: "setupItemView" }, host: { listeners: { "itemLoading": "onItemLoading($event)" } }, providers: [{ provide: TEMPLATED_ITEMS_COMPONENT, useExisting: forwardRef(() => ListViewComponent) }], queries: [{ propertyName: "itemTemplateQuery", first: true, predicate: TemplateRef, descendants: true, read: TemplateRef }], viewQueries: [{ propertyName: "loader", first: true, predicate: ["loader"], descendants: true, read: ViewContainerRef, static: true }], ngImport: i0, template: `<DetachedContainer>
    <ng-container #loader></ng-container>
  </DetachedContainer>`, isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
__decorate([
    profile,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], ListViewComponent.prototype, "onItemLoading", null);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: ListViewComponent, decorators: [{
            type: Component,
            args: [{
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: 'ListView',
                    template: `<DetachedContainer>
    <ng-container #loader></ng-container>
  </DetachedContainer>`,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [{ provide: TEMPLATED_ITEMS_COMPONENT, useExisting: forwardRef(() => ListViewComponent) }],
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.IterableDiffers }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { loader: [{
                type: ViewChild,
                args: ['loader', { read: ViewContainerRef, static: true }]
            }], setupItemView: [{
                type: Output
            }], itemTemplateQuery: [{
                type: ContentChild,
                args: [TemplateRef, { read: TemplateRef, static: false }]
            }], items: [{
                type: Input
            }], onItemLoading: [{
                type: HostListener,
                args: ['itemLoading', ['$event']]
            }] } });
function getItemViewRoot(viewRef, rootLocator = extractSingleViewRecursive) {
    const rootView = rootLocator(viewRef.rootNodes, 0);
    return rootView;
}
// eslint-disable-next-line @angular-eslint/directive-selector
class TemplateKeyDirective {
    constructor(templateRef, comp) {
        this.templateRef = templateRef;
        this.comp = comp;
    }
    set nsTemplateKey(value) {
        if (this.comp && this.templateRef) {
            this.comp.registerTemplate(value, this.templateRef);
        }
    }
    set nsTemplateKeys(values) {
        // single template with multiple keys
        if (this.comp && this.templateRef && values) {
            values.forEach((value) => this.comp.registerTemplate(value, this.templateRef));
        }
    }
}
TemplateKeyDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: TemplateKeyDirective, deps: [{ token: i0.TemplateRef }, { token: TEMPLATED_ITEMS_COMPONENT, host: true }], target: i0.ɵɵFactoryTarget.Directive });
TemplateKeyDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.2.3", type: TemplateKeyDirective, selector: "[nsTemplateKey],[nsTemplateKeys]", inputs: { nsTemplateKey: "nsTemplateKey", nsTemplateKeys: "nsTemplateKeys" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: TemplateKeyDirective, decorators: [{
            type: Directive,
            args: [{ selector: '[nsTemplateKey],[nsTemplateKeys]' }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef }, { type: undefined, decorators: [{
                    type: Host
                }, {
                    type: Inject,
                    args: [TEMPLATED_ITEMS_COMPONENT]
                }] }]; }, propDecorators: { nsTemplateKey: [{
                type: Input
            }], nsTemplateKeys: [{
                type: Input
            }] } });

/**
 * Utility method to ensure a NgModule is only imported once in a codebase, otherwise will throw to help prevent accidental double importing
 * @param parentModule Parent module name
 * @param moduleName The module name
 */
function throwIfAlreadyLoaded(parentModule, moduleName) {
    if (parentModule) {
        throw new Error(`${moduleName} has already been loaded. Import ${moduleName} in the AppModule only.`);
    }
}
/**
 * Utility method which will only fire the callback once ever
 * @param fn callback to call only once
 */
function once(fn) {
    let wasCalled = false;
    return function wrapper() {
        if (wasCalled) {
            return;
        }
        wasCalled = true;
        fn.apply(null, arguments);
    };
}

class FrameService {
    // TODO: Add any methods that are needed to handle frame/page navigation
    getFrame() {
        return Frame.topmost();
    }
}
FrameService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: FrameService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
FrameService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: FrameService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: FrameService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class Outlet {
    constructor(outletKey, path, pathByOutlets, modalNavigationDepth) {
        this._navigatingBackOutlets = new Set();
        // More than one frame available when using NSEmptyOutletComponent component
        // in module that lazy loads children (loadChildren) and has outlet name.
        this.frames = [];
        this.states = [];
        // Used in reuse-strategy by its children to determine if they should be detached too.
        this.shouldDetach = true;
        this.outletKeys = [outletKey];
        this.isPageNavigationBack = false;
        this.showingModal = false;
        this.modalNavigationDepth = modalNavigationDepth || 0;
        this.pathByOutlets = pathByOutlets;
        this.path = path;
    }
    get isPageNavigationBack() {
        return this._navigatingBackOutlets.size > 0;
    }
    set isPageNavigationBack(isBack) {
        if (!isBack) {
            if (this._navigatingBackOutlets.size > 0) {
                this._navigatingBackOutlets.delete(this._navigatingBackOutlets.values().next().value);
            }
        }
        else {
            for (const key of this.outletKeys) {
                this._navigatingBackOutlets.add(key);
            }
        }
    }
    setOutletKeyNavigatingBack(key) {
        const nests = key.split('/');
        this.outletKeys
            .filter((k) => k.split('/').length >= nests.length)
            .forEach((k) => {
            this._navigatingBackOutlets.add(k);
        });
    }
    containsFrame(frame) {
        return this.frames.indexOf(frame) > -1;
    }
    peekState() {
        if (this.states.length > 0) {
            return this.states[this.states.length - 1];
        }
        return null;
    }
    containsTopState(stateUrl) {
        const lastState = this.peekState();
        return lastState && lastState.segmentGroup.toString() === stateUrl;
    }
    // Search for frame that can go back.
    // Nested 'primary' outlets could result in Outlet with multiple navigatable frames.
    getFrameToBack() {
        let frame = this.frames[this.frames.length - 1];
        if (!this.isNSEmptyOutlet) {
            for (let index = this.frames.length - 1; index >= 0; index--) {
                const currentFrame = this.frames[index];
                if (currentFrame.canGoBack()) {
                    frame = currentFrame;
                    break;
                }
            }
        }
        return frame;
    }
}
const defaultNavOptions = {
    clearHistory: false,
    animated: true,
};

class NSLocationStrategy extends LocationStrategy {
    constructor(frameService, startPath) {
        super();
        this.frameService = frameService;
        this.startPath = startPath;
        this.outlets = [];
        this.popStateCallbacks = new Array();
        this._modalNavigationDepth = 0;
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog('NSLocationStrategy.constructor()');
        }
    }
    getState() {
        return this.currentOutlet && this.currentOutlet.peekState();
    }
    path() {
        if (!this.currentUrlTree) {
            return this.startPath || '/';
        }
        const state = this.currentOutlet && this.currentOutlet.peekState();
        if (!state) {
            return '/';
        }
        let tree = this.currentUrlTree;
        let changedOutlet = this.getSegmentGroupByOutlet(this.currentOutlet);
        // Handle case where the user declares a component at path "/".
        // The url serializer doesn't parse this url as having a primary outlet.
        if (state.isRootSegmentGroup) {
            tree.root = state.segmentGroup;
        }
        else if (changedOutlet) {
            this.updateSegmentGroup(tree.root, changedOutlet, state.segmentGroup);
        }
        const urlSerializer = new DefaultUrlSerializer();
        tree.queryParams = state.queryParams;
        const url = urlSerializer.serialize(tree);
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog('NSLocationStrategy.path(): ' + url);
        }
        return url;
    }
    prepareExternalUrl(internal) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog('NSLocationStrategy.prepareExternalUrl() internal: ' + internal);
        }
        return internal;
    }
    pushState(state, title, url, queryParams) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog('NSLocationStrategy.pushState state: ' + `${state}, title: ${title}, url: ${url}, queryParams: ${queryParams}`);
        }
        this.pushStateInternal(state, title, url, queryParams);
    }
    pushStateInternal(state, title, url, queryParams, replace = false) {
        const urlSerializer = new DefaultUrlSerializer();
        this.currentUrlTree = urlSerializer.parse(url);
        const urlTreeRoot = this.currentUrlTree.root;
        // Handle case where the user declares a component at path "/".
        // The url serializer doesn't parse this url as having a primary outlet.
        if (!Object.keys(urlTreeRoot.children).length) {
            const segmentGroup = this.currentUrlTree && this.currentUrlTree.root;
            const outletKey = this.getOutletKey(this.getSegmentGroupFullPath(segmentGroup), 'primary');
            const outlet = this.findOutlet(outletKey);
            if (outlet && this.updateStates(outlet, segmentGroup, this.currentUrlTree.queryParams, replace)) {
                this.currentOutlet = outlet; // If states updated
            }
            else if (!outlet) {
                // tslint:disable-next-line:max-line-length
                const rootOutlet = this.createOutlet('primary', null, segmentGroup, null, null, this.currentUrlTree.queryParams);
                this.currentOutlet = rootOutlet;
            }
            this.currentOutlet.peekState().isRootSegmentGroup = true;
            return;
        }
        const queue = [];
        let currentTree = urlTreeRoot;
        while (currentTree) {
            Object.keys(currentTree.children).forEach((outletName) => {
                const currentSegmentGroup = currentTree.children[outletName];
                currentSegmentGroup.outlet = outletName;
                currentSegmentGroup.root = urlTreeRoot;
                const outletPath = this.getSegmentGroupFullPath(currentTree);
                let outletKey = this.getOutletKey(outletPath, outletName);
                let outlet = this.findOutlet(outletKey);
                const parentOutletName = currentTree.outlet || '';
                const parentOutletPath = this.getSegmentGroupFullPath(currentTree.parent);
                const parentOutletKey = this.getOutletKey(parentOutletPath, parentOutletName);
                const parentOutlet = this.findOutlet(parentOutletKey);
                const containsLastState = outlet && outlet.containsTopState(currentSegmentGroup.toString());
                if (!outlet) {
                    // tslint:disable-next-line:max-line-length
                    outlet = this.createOutlet(outletKey, outletPath, currentSegmentGroup, parentOutlet, this._modalNavigationDepth, this.currentUrlTree.queryParams);
                    this.currentOutlet = outlet;
                }
                else if (this._modalNavigationDepth > 0 && outlet.showingModal && !containsLastState) {
                    // Navigation inside modal view.
                    this.upsertModalOutlet(outlet, currentSegmentGroup, this.currentUrlTree.queryParams, replace);
                }
                else {
                    outlet.parent = parentOutlet;
                    if (this.updateStates(outlet, currentSegmentGroup, this.currentUrlTree.queryParams, replace)) {
                        this.currentOutlet = outlet; // If states updated
                    }
                }
                queue.push(currentSegmentGroup);
            });
            currentTree = queue.shift();
        }
    }
    replaceState(state, title, url, queryParams) {
        const states = this.currentOutlet && this.currentOutlet.states;
        if (states && states.length > 0) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog('NSLocationStrategy.replaceState changing existing state: ' + `${state}, title: ${title}, url: ${url}, queryParams: ${queryParams}`);
            }
            this.pushStateInternal(state, title, url, queryParams, true);
        }
        else {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog('NSLocationStrategy.replaceState pushing new state: ' + `${state}, title: ${title}, url: ${url}, queryParams: ${queryParams}`);
            }
            this.pushStateInternal(state, title, url, queryParams);
        }
    }
    forward() {
        throw new Error('NSLocationStrategy.forward() - not implemented');
    }
    back(outlet, frame) {
        this.currentOutlet = outlet || this.currentOutlet;
        if (this.currentOutlet.isPageNavigationBack) {
            const states = this.currentOutlet.states;
            // We are navigating to the previous page
            // clear the stack until we get to a page navigation state
            let state = states.pop();
            let count = 1;
            if (frame) {
                while (state.frame && state.frame !== frame) {
                    state = states.pop();
                    count++;
                }
            }
            while (!state.isPageNavigation) {
                state = states.pop();
                count++;
            }
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog(`NSLocationStrategy.back() while navigating back. States popped: ${count}`);
            }
            this.callPopState(state, true);
        }
        else {
            let state = this.currentOutlet.peekState();
            if (state && state.isPageNavigation) {
                // This was a page navigation - so navigate through frame.
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.routerLog('NSLocationStrategy.back() while not navigating back but top' + ' state is page - will call frame.goBack()');
                }
                if (!outlet) {
                    const topmostFrame = this.frameService.getFrame();
                    this.currentOutlet = this.getOutletByFrame(topmostFrame) || this.currentOutlet;
                }
                const frameToBack = this.currentOutlet.getFrameToBack();
                if (frameToBack) {
                    frameToBack.goBack();
                }
            }
            else {
                // Nested navigation - just pop the state
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.routerLog('NSLocationStrategy.back() while not navigating back but top' + ' state is not page - just pop');
                }
                this.callPopState(this.currentOutlet.states.pop(), true);
            }
        }
    }
    canGoBack(outlet) {
        outlet = outlet || this.currentOutlet;
        return outlet.states.length > 1;
    }
    onPopState(fn) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog('NSLocationStrategy.onPopState');
        }
        this.popStateCallbacks.push(fn);
    }
    getBaseHref() {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog('NSLocationStrategy.getBaseHref()');
        }
        return '';
    }
    callPopState(state, pop = true, outlet) {
        outlet = outlet || this.currentOutlet;
        const urlSerializer = new DefaultUrlSerializer();
        let changedOutlet = this.getSegmentGroupByOutlet(outlet);
        if (state && changedOutlet) {
            this.updateSegmentGroup(this.currentUrlTree.root, changedOutlet, state.segmentGroup);
        }
        else if (changedOutlet) {
            // when closing modal view there are scenarios (e.g. root viewContainerRef) when we need
            // to clean up the named page router outlet to make sure we will open the modal properly again if needed.
            this.updateSegmentGroup(this.currentUrlTree.root, changedOutlet, null);
        }
        const url = urlSerializer.serialize(this.currentUrlTree);
        const change = { state, type: 'popstate' };
        for (let fn of this.popStateCallbacks) {
            fn(change);
        }
    }
    toString() {
        let result = [];
        this.outlets.forEach((outlet) => {
            const outletStates = outlet.states;
            const outletLog = outletStates
                // tslint:disable-next-line:max-line-length
                .map((v, i) => `${outlet.outletKeys}.${i}.[${v.isPageNavigation ? 'PAGE' : 'INTERNAL'}].[${outlet.modalNavigationDepth ? 'MODAL' : 'BASE'}] "${v.segmentGroup.toString()}"`)
                .reverse();
            result = result.concat(outletLog);
        });
        return result.join('\n');
    }
    // Methods for syncing with page navigation in PageRouterOutlet
    _beginBackPageNavigation(frame, outletKey) {
        const outlet = this.getOutletByFrame(frame);
        if (!outlet || outlet.isPageNavigationBack) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerError('Attempted to call startGoBack while going back.');
            }
            return;
        }
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog('NSLocationStrategy.startGoBack()');
        }
        outlet.setOutletKeyNavigatingBack(outletKey);
        // outlet.isPageNavigationBack = true;
        // we find all the children and also set their isPageNavigationBack
        this.outlets
            .filter((o) => {
            let parent = o.parent;
            while (parent) {
                if (parent === outlet) {
                    return true;
                }
                parent = parent.parent;
            }
            return false;
        })
            .forEach((o) => (o.isPageNavigationBack = true));
        this.currentOutlet = outlet;
    }
    _finishBackPageNavigation(frame) {
        const outlet = this.getOutletByFrame(frame);
        if (!outlet || !outlet.isPageNavigationBack) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerError('Attempted to call endGoBack while not going back.');
            }
            return;
        }
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog('NSLocationStrategy.finishBackPageNavigation()');
        }
        outlet.isPageNavigationBack = false;
    }
    _beginModalNavigation(frame) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog('NSLocationStrategy._beginModalNavigation()');
        }
        this.currentOutlet = this.getOutletByFrame(frame) || this.currentOutlet;
        // It is possible to have frame, but not corresponding Outlet, if
        // showing modal dialog on app.component.ts ngOnInit() e.g. In that case
        // the modal is treated as none modal navigation.
        if (this.currentOutlet) {
            this.currentOutlet.showingModal = true;
            this._modalNavigationDepth++;
        }
    }
    _closeModalNavigation() {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog('NSLocationStrategy.closeModalNavigation()');
        }
        const isShowingModal = this._modalNavigationDepth > 0;
        if (isShowingModal) {
            this._modalNavigationDepth--;
        }
        // currentOutlet should be the one that corresponds to the topmost frame
        const topmostOutlet = this.getOutletByFrame(this.frameService.getFrame());
        const outlet = this.findOutletByModal(this._modalNavigationDepth, isShowingModal) || topmostOutlet;
        if (outlet) {
            this.currentOutlet = outlet;
            this.currentOutlet.showingModal = false;
            this.callPopState(this.currentOutlet.peekState(), false);
            // this is needed because angular does a setTimeout on onPopState, so if we don't do this we might end up with inconsistent state
            return new Promise((resolve) => setTimeout(resolve, 0));
        }
    }
    _beginPageNavigation(frame) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog('NSLocationStrategy._beginPageNavigation()');
        }
        this.currentOutlet = this.getOutletByFrame(frame) || this.currentOutlet;
        const lastState = this.currentOutlet.peekState();
        if (lastState) {
            lastState.isPageNavigation = true;
        }
        const navOptions = this._currentNavigationOptions || defaultNavOptions;
        if (navOptions.clearHistory) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog('NSLocationStrategy._beginPageNavigation clearing states history');
            }
            this.currentOutlet.states = [lastState];
        }
        this._currentNavigationOptions = undefined;
        return navOptions;
    }
    _setNavigationOptions(options) {
        this._currentNavigationOptions = {
            clearHistory: isPresent(options.clearHistory) ? options.clearHistory : false,
            animated: isPresent(options.animated) ? options.animated : true,
            transition: options.transition,
            replaceUrl: options.replaceUrl,
        };
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog('NSLocationStrategy._setNavigationOptions(' + `${JSON.stringify(this._currentNavigationOptions)})`);
        }
    }
    _getOutlets() {
        return this.outlets;
    }
    updateOutletFrame(outlet, frame, isEmptyOutletFrame) {
        const lastState = outlet.peekState();
        if (lastState && !lastState.frame && !isEmptyOutletFrame) {
            lastState.frame = frame;
        }
        if (!outlet.containsFrame(frame)) {
            outlet.frames.push(frame);
        }
        this.currentOutlet = outlet;
    }
    clearOutlet(frame) {
        this.outlets = this.outlets.filter((currentOutlet) => {
            let isEqualToCurrent;
            if (this.currentOutlet) {
                isEqualToCurrent = currentOutlet.pathByOutlets === this.currentOutlet.pathByOutlets;
            }
            // Remove outlet from the url tree.
            if (currentOutlet.containsFrame(frame) && !isEqualToCurrent) {
                this.callPopState(null, true, currentOutlet);
            }
            // Skip frames filtering since currentOutlet is <router-outlet> when no frames available.
            if (currentOutlet.frames.length && !currentOutlet.isNSEmptyOutlet) {
                currentOutlet.frames = currentOutlet.frames.filter((currentFrame) => currentFrame !== frame);
                return currentOutlet.frames.length;
            }
            return !currentOutlet.containsFrame(frame);
        });
    }
    getSegmentGroupFullPath(segmentGroup) {
        let fullPath = '';
        while (segmentGroup) {
            const url = segmentGroup.toString();
            if (fullPath) {
                fullPath = (url ? url + '/' : '') + fullPath;
            }
            else {
                fullPath = url;
            }
            segmentGroup = segmentGroup.parent;
        }
        return fullPath;
    }
    getRouteFullPath(currentRoute) {
        const outletName = currentRoute.outlet;
        let fullPath;
        currentRoute = currentRoute.parent;
        while (currentRoute) {
            const urls = currentRoute.url.value || currentRoute.url;
            let url = urls;
            if (Array.isArray(urls)) {
                url = url.join('/');
            }
            fullPath = fullPath ? (url ? url + '/' : url) + fullPath : url;
            currentRoute = currentRoute.parent;
        }
        return fullPath ? fullPath + '-' + outletName : outletName;
    }
    getPathByOutlets(urlSegmentGroup) {
        if (!urlSegmentGroup) {
            return '';
        }
        let pathToOutlet;
        let lastPath = urlSegmentGroup.outlet || 'primary';
        let parent = urlSegmentGroup.parent;
        while (parent && urlSegmentGroup.root !== parent) {
            if (parent && parent.outlet !== lastPath) {
                if (lastPath === 'primary') {
                    lastPath = parent.outlet;
                }
                else {
                    lastPath = parent.outlet;
                    pathToOutlet = lastPath + '-' + (pathToOutlet || urlSegmentGroup.outlet);
                }
            }
            parent = parent.parent;
        }
        return pathToOutlet || lastPath;
    }
    findOutlet(outletKey, activatedRouteSnapshot) {
        let outlet = this.outlets.find((currentOutlet) => {
            let equalModalDepth = currentOutlet.modalNavigationDepth === this._modalNavigationDepth;
            return equalModalDepth && currentOutlet.outletKeys.indexOf(outletKey) > -1;
        });
        // No Outlet with the given outletKey could happen when using nested unnamed p-r-o
        // primary -> primary -> prymary
        if (!outlet && activatedRouteSnapshot) {
            const pathByOutlets = this.getPathByOutlets(activatedRouteSnapshot);
            outlet = this.outlets.find((currentOutlet) => {
                let equalModalDepth = currentOutlet.modalNavigationDepth === this._modalNavigationDepth;
                return equalModalDepth && currentOutlet.pathByOutlets === pathByOutlets;
            });
        }
        return outlet;
    }
    findOutletByModal(modalNavigation, isShowingModal) {
        return this.outlets.find((outlet) => {
            let equalModalDepth = outlet.modalNavigationDepth === modalNavigation;
            return isShowingModal ? equalModalDepth && outlet.showingModal : equalModalDepth;
        });
    }
    getOutletByFrame(frame) {
        let outlet;
        for (let index = 0; index < this.outlets.length; index++) {
            const currentOutlet = this.outlets[index];
            if (currentOutlet.containsFrame(frame)) {
                outlet = currentOutlet;
                break;
            }
        }
        return outlet;
    }
    updateStates(outlet, currentSegmentGroup, queryParams, replace = false) {
        const isNewPage = outlet.states.length === 0;
        const lastState = outlet.states[outlet.states.length - 1];
        const equalStateUrls = outlet.containsTopState(currentSegmentGroup.toString());
        const locationState = {
            segmentGroup: currentSegmentGroup,
            isRootSegmentGroup: false,
            isPageNavigation: isNewPage,
            queryParams: { ...queryParams },
        };
        if (!lastState || !equalStateUrls) {
            if (replace) {
                outlet.states.pop();
            }
            outlet.states.push(locationState);
            // Update last state segmentGroup of parent Outlet.
            if (this._modalNavigationDepth === 0 && !outlet.showingModal) {
                this.updateParentsStates(outlet, currentSegmentGroup.parent);
            }
            return true;
        }
        else {
            if (lastState && equalStateUrls) {
                // update query params for last state
                lastState.queryParams = { ...queryParams };
            }
        }
        return false;
    }
    updateParentsStates(outlet, newSegmentGroup) {
        let parentOutlet = outlet.parent;
        // Update parents lastState segmentGroups
        while (parentOutlet && newSegmentGroup) {
            const state = parentOutlet.peekState();
            if (state) {
                state.segmentGroup = newSegmentGroup;
                newSegmentGroup = newSegmentGroup.parent;
                parentOutlet = parentOutlet.parent;
            }
        }
    }
    // tslint:disable-next-line:max-line-length
    createOutlet(outletKey, path, segmentGroup, parent, modalNavigation, queryParams = {}) {
        const pathByOutlets = this.getPathByOutlets(segmentGroup);
        const newOutlet = new Outlet(outletKey, path, pathByOutlets, modalNavigation);
        const locationState = {
            segmentGroup: segmentGroup,
            isRootSegmentGroup: false,
            isPageNavigation: true,
            queryParams: { ...queryParams },
        };
        newOutlet.states = [locationState];
        newOutlet.parent = parent;
        this.outlets.push(newOutlet);
        // Update last state segmentGroup of parent Outlet.
        if (this._modalNavigationDepth === 0 && !newOutlet.showingModal) {
            this.updateParentsStates(newOutlet, segmentGroup.parent);
        }
        return newOutlet;
    }
    getSegmentGroupByOutlet(outlet) {
        const pathList = outlet.pathByOutlets.split('-');
        let segmentGroup = this.currentUrlTree.root;
        let pathToOutlet;
        for (let index = 0; index < pathList.length; index++) {
            const currentPath = pathList[index];
            const childrenCount = Object.keys(segmentGroup.children).length;
            if (childrenCount && segmentGroup.children[currentPath]) {
                const url = segmentGroup.toString();
                pathToOutlet = pathToOutlet ? pathToOutlet + '/' + url : url;
                segmentGroup = segmentGroup.children[currentPath];
            }
            else {
                // If no child outlet found with the given name - forget about all previously found outlets.
                // example: seaching for 'primary-second-primary' shouldn't return 'primary-second'
                // if no 'primary' child available on 'second'.
                segmentGroup = null;
                break;
            }
        }
        // Paths should also match since there could be another Outlet
        // with the same pathByOutlets but different url path.
        if (segmentGroup && outlet.path && pathToOutlet && outlet.path !== pathToOutlet) {
            segmentGroup = null;
        }
        return segmentGroup;
    }
    // Traversal and replacement of segmentGroup.
    updateSegmentGroup(rootNode, oldSegmentGroup, newSegmentGroup) {
        const queue = [];
        let currentTree = rootNode;
        while (currentTree) {
            Object.keys(currentTree.children).forEach((outletName) => {
                if (currentTree.children[outletName] === oldSegmentGroup) {
                    if (newSegmentGroup) {
                        currentTree.children[outletName] = newSegmentGroup;
                    }
                    else {
                        delete currentTree.children[outletName];
                    }
                }
                queue.push(currentTree.children[outletName]);
            });
            currentTree = queue.shift();
        }
    }
    upsertModalOutlet(parentOutlet, segmentedGroup, queryParams, replace = false) {
        let currentModalOutlet = this.findOutletByModal(this._modalNavigationDepth);
        // We want to treat every p-r-o as a standalone Outlet.
        if (!currentModalOutlet) {
            if (this._modalNavigationDepth > 1) {
                // The parent of the current Outlet should be the previous opened modal (if any).
                parentOutlet = this.findOutletByModal(this._modalNavigationDepth - 1);
            }
            // No currentModalOutlet available when opening 'primary' p-r-o.
            const outletName = 'primary';
            const outletPath = parentOutlet.peekState().segmentGroup.toString();
            const outletKey = this.getOutletKey(outletPath, outletName);
            // tslint:disable-next-line:max-line-length
            currentModalOutlet = this.createOutlet(outletKey, outletPath, segmentedGroup, parentOutlet, this._modalNavigationDepth, queryParams);
            this.currentOutlet = currentModalOutlet;
        }
        else if (this.updateStates(currentModalOutlet, segmentedGroup, queryParams, replace)) {
            this.currentOutlet = currentModalOutlet; // If states updated
        }
    }
    getOutletKey(path, outletName) {
        return path ? path + '-' + outletName : outletName;
    }
    ngOnDestroy() {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog('NSLocationStrategy.ngOnDestroy()');
        }
        this.outlets = [];
        this.currentOutlet = null;
    }
}
NSLocationStrategy.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NSLocationStrategy, deps: [{ token: FrameService }, { token: START_PATH, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
NSLocationStrategy.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NSLocationStrategy, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NSLocationStrategy, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: FrameService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [START_PATH]
                }, {
                    type: Optional
                }] }]; } });

class ModalDialogParams {
    constructor(context = {}, closeCallback) {
        this.context = context;
        this.closeCallback = closeCallback;
    }
}
class ModalDialogService {
    constructor(location, zone, appRef, defaultInjector) {
        this.location = location;
        this.zone = zone;
        this.appRef = appRef;
        this.defaultInjector = defaultInjector;
    }
    /**
     * Emits anytime a modal is closed with the ModalDialogParams which were injected into the component which is now closing.
     * For example, can be used to wire up Rx flows outside the scope of just the component being handled.
     */
    get closed$() {
        if (!this._closed$) {
            this._closed$ = new Subject();
        }
        return this._closed$;
    }
    showModal(type, options = {}) {
        // if (!options.viewContainerRef) {
        //   throw new Error('No viewContainerRef: ' + 'Make sure you pass viewContainerRef in ModalDialogOptions.');
        // }
        let parentView = options.viewContainerRef?.element.nativeElement || Application.getRootView();
        if (options.target) {
            parentView = options.target;
        }
        if ((parentView instanceof AppHostView || parentView instanceof AppHostAsyncView) && parentView.ngAppRoot) {
            parentView = parentView.ngAppRoot;
        }
        // _ngDialogRoot is the first child of the previously detached proxy.
        // It should have 'viewController' (iOS) or '_dialogFragment' (Android) available for
        // presenting future modal views.
        if (parentView._ngDialogRoot) {
            parentView = parentView._ngDialogRoot;
        }
        // resolve from particular module (moduleRef)
        // or from same module as parentView (viewContainerRef)
        const componentInjector = options.moduleRef?.injector || options.viewContainerRef?.injector || this.defaultInjector;
        const resolver = componentInjector.get(ComponentFactoryResolver);
        let frame = parentView;
        if (!(parentView instanceof Frame)) {
            frame = (parentView.page && parentView.page.frame) || Frame.topmost();
        }
        this.location?._beginModalNavigation(frame);
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                try {
                    this._showDialog({
                        ...options,
                        containerRef: options.viewContainerRef,
                        injector: componentInjector,
                        context: options.context,
                        doneCallback: resolve,
                        parentView,
                        resolver,
                        type,
                    });
                }
                catch (err) {
                    reject(err);
                }
            }, 10);
        });
    }
    _showDialog(options) {
        let componentViewRef;
        let detachedLoaderRef;
        let portalOutlet;
        const closeCallback = once(async (...args) => {
            options.doneCallback.apply(undefined, args);
            if (componentViewRef) {
                componentViewRef.firstNativeLikeView.closeModal();
                const params = this.openedModalParams.pop();
                if (this._closed$) {
                    this._closed$.next(params);
                }
                await this.location._closeModalNavigation();
                if (detachedLoaderRef || portalOutlet) {
                    this.zone.run(() => {
                        portalOutlet?.dispose();
                        detachedLoaderRef?.instance.detectChanges();
                        detachedLoaderRef?.destroy();
                    });
                }
            }
        });
        const modalParams = new ModalDialogParams(options.context, closeCallback);
        if (!this.openedModalParams) {
            this.openedModalParams = [];
        }
        this.openedModalParams.push(modalParams);
        const childInjector = Injector.create({
            providers: [{ provide: ModalDialogParams, useValue: modalParams }],
            parent: options.injector,
        });
        this.zone.run(() => {
            // if we ever support templates in the old API
            // if(options.templateRef) {
            //     const detachedFactory = options.resolver.resolveComponentFactory(DetachedLoader);
            //     if(options.attachToContainerRef) {
            //         detachedLoaderRef = options.attachToContainerRef.createComponent(detachedFactory, 0, childInjector, null);
            //     } else {
            //         detachedLoaderRef = detachedFactory.create(childInjector); // this DetachedLoader is **completely** detached
            //         this.appRef.attachView(detachedLoaderRef.hostView); // we attach it to the applicationRef, so it becomes a "root" view in angular's hierarchy
            //     }
            //     detachedLoaderRef.changeDetectorRef.detectChanges(); // force a change detection
            //     detachedLoaderRef.instance.createTemplatePortal(options.templateRef);
            // }
            const targetView = new ContentView();
            const portal = new ComponentPortal(options.type);
            portalOutlet = new NativeScriptDomPortalOutlet(targetView, options.resolver, this.appRef, childInjector);
            const componentRef = portalOutlet.attach(portal);
            ɵdetectChanges(componentRef.instance);
            componentViewRef = new NgViewRef(componentRef);
            if (options.useContextAsComponentProps && options.context) {
                for (const key in options.context) {
                    componentViewRef.ref.instance[key] = options.context[key];
                }
            }
            if (componentViewRef !== componentRef.location.nativeElement) {
                componentRef.location.nativeElement._ngDialogRoot = componentViewRef.firstNativeLikeView;
            }
            // if we don't detach the view from its parent, ios gets mad
            componentViewRef.detachNativeLikeView();
            options.parentView.showModal(componentViewRef.firstNativeLikeView, { ...options, closeCallback });
        });
    }
}
ModalDialogService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: ModalDialogService, deps: [{ token: NSLocationStrategy }, { token: i0.NgZone }, { token: i0.ApplicationRef }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });
ModalDialogService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: ModalDialogService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: ModalDialogService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: NSLocationStrategy }, { type: i0.NgZone }, { type: i0.ApplicationRef }, { type: i0.Injector }]; } });

/**
 * This decorator delays a potentially unsafe event (like loaded/unloaded that will sometimes be called before ngOnInit) to be handled safely by ensuring it's called after a lifecycle hook.
 * @param runAfterEvent event/function call to wait until the event can be fired ('ngOnInit', 'ngAfterViewInit', ...)
 * @param options Optional event handling params
 * @returns decorator
 */
function NativeScriptNgSafeEvent(runAfterEvent, options = {}) {
    const event = runAfterEvent;
    return function (target, propertyKey, descriptor) {
        function getNgSafe() {
            return target['__ng_safe__'];
        }
        if (!target['__ng_safe__']) {
            const defaultNgSafe = {
                events: {},
                runBefore: {},
            };
            target['__ng_safe__'] = defaultNgSafe;
        }
        if (!getNgSafe().events[event]) {
            getNgSafe().events[event] = {
                done: false,
                buffer: [],
                originalDelegate: target[event],
            };
            target[event] = function (...args) {
                try {
                    if (getNgSafe().events[event].originalDelegate) {
                        return getNgSafe().events[event].originalDelegate.apply(this, args);
                    }
                }
                finally {
                    getNgSafe().events[event].done = true;
                    getNgSafe().events[event].buffer.forEach((fn) => fn.fn());
                    getNgSafe().events[event].buffer = [];
                }
            };
        }
        if (options.alwaysRunBefore) {
            getNgSafe().runBefore[propertyKey] = target[options.alwaysRunBefore];
            target[`${options.alwaysRunBefore}`] = function (...args) {
                getNgSafe()
                    .events[event].buffer.filter((v) => v.key === propertyKey)
                    .forEach((fn) => fn.fn());
                getNgSafe().events[event].buffer = getNgSafe().events[event].buffer.filter((v) => v.key !== propertyKey);
                getNgSafe().runBefore[propertyKey];
                if (getNgSafe().runBefore[propertyKey]) {
                    return getNgSafe().runBefore[propertyKey].apply(this, args);
                }
            };
        }
        const oldFn = descriptor.value;
        descriptor.value = function (...args) {
            if (getNgSafe().events[event].done) {
                return oldFn.apply(this, args);
            }
            let shouldPush = true;
            if (options.onlyFirst || options.onlyLast) {
                for (let i = 0; i < getNgSafe().events[event].buffer.length; i++) {
                    if (getNgSafe().events[event].buffer[i].key === propertyKey) {
                        if (options.onlyFirst) {
                            shouldPush = false;
                            break;
                        }
                        if (options.onlyLast) {
                            getNgSafe().events[event].buffer.splice(i, 1);
                            break;
                        }
                    }
                }
            }
            if (shouldPush) {
                getNgSafe().events[event].buffer.push({
                    key: propertyKey,
                    fn: oldFn.bind(this, args),
                });
            }
        };
    };
}

class TabViewDirective {
    constructor(element) {
        this.tabView = element.nativeElement;
    }
    get selectedIndex() {
        return this._selectedIndex;
    }
    set selectedIndex(value) {
        this._selectedIndex = value;
        if (this.viewInitialized) {
            this.tabView.selectedIndex = this._selectedIndex;
        }
    }
    ngAfterViewInit() {
        this.viewInitialized = true;
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.rendererLog('this._selectedIndex: ' + this._selectedIndex);
        }
        if (!isBlank(this._selectedIndex)) {
            this.tabView.selectedIndex = this._selectedIndex;
        }
    }
}
TabViewDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: TabViewDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
TabViewDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.2.3", type: TabViewDirective, selector: "TabView", inputs: { selectedIndex: "selectedIndex" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: TabViewDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'TabView', // eslint-disable-line @angular-eslint/directive-selector
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { selectedIndex: [{
                type: Input
            }] } });
class TabViewItemDirective {
    constructor(owner, templateRef, viewContainer) {
        this.owner = owner;
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
    }
    set config(config) {
        if (!this._config || this._config.iconSource !== config.iconSource || this._config.title !== config.title || this._config.textTransform !== config.textTransform) {
            this._config = config;
            this.applyConfig();
        }
    }
    get config() {
        // tslint:disable-line:no-input-rename
        return this._config || {};
    }
    set title(title) {
        this.config = Object.assign(this.config, { title });
    }
    get title() {
        return this.config.title;
    }
    set iconSource(iconSource) {
        this.config = Object.assign(this.config, { iconSource });
    }
    get iconSource() {
        return this.config.iconSource;
    }
    set textTransform(textTransform) {
        this.config = Object.assign(this.config, { textTransform });
    }
    get textTransform() {
        return this.config.textTransform;
    }
    ensureItem() {
        if (!this.item) {
            this.item = new TabViewItem();
        }
    }
    applyConfig() {
        this.ensureItem();
        if (this.config.title) {
            this.item.title = this.config.title;
        }
        if (this.config.iconSource) {
            this.item.iconSource = this.config.iconSource;
        }
        //  TabViewItem textTransform has a default value for Android that kick in
        // only if no value (even a null value) is set.
        if (this.config.textTransform) {
            this.item.textTransform = this.config.textTransform;
        }
    }
    ngOnInit() {
        this.applyConfig();
        const viewRef = this.viewContainer.createEmbeddedView(this.templateRef);
        // Filter out text nodes and comments
        const realViews = viewRef.rootNodes.filter((node) => !(node instanceof InvisibleNode));
        if (realViews.length > 0) {
            this.item.view = realViews[0];
            const newItems = (this.owner.tabView.items || []).concat([this.item]);
            this.owner.tabView.items = newItems;
        }
    }
}
TabViewItemDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: TabViewItemDirective, deps: [{ token: TabViewDirective }, { token: i0.TemplateRef }, { token: i0.ViewContainerRef }], target: i0.ɵɵFactoryTarget.Directive });
TabViewItemDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.2.3", type: TabViewItemDirective, selector: "[tabItem]", inputs: { config: ["tabItem", "config"], title: "title", iconSource: "iconSource", textTransform: "textTransform" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: TabViewItemDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[tabItem]', // eslint-disable-line @angular-eslint/directive-selector
                }]
        }], ctorParameters: function () { return [{ type: TabViewDirective }, { type: i0.TemplateRef }, { type: i0.ViewContainerRef }]; }, propDecorators: { config: [{
                type: Input,
                args: ['tabItem']
            }], title: [{
                type: Input
            }], iconSource: [{
                type: Input
            }], textTransform: [{
                type: Input
            }] } });

/* eslint-disable @angular-eslint/component-selector */
class AndroidFilterComponent {
    constructor(device) {
        this.show = device.os === platformNames.android;
    }
}
AndroidFilterComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: AndroidFilterComponent, deps: [{ token: DEVICE }], target: i0.ɵɵFactoryTarget.Component });
AndroidFilterComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.3", type: AndroidFilterComponent, selector: "android", ngImport: i0, template: `<ng-content *ngIf="show"></ng-content>`, isInline: true, dependencies: [{ kind: "directive", type: i1$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: AndroidFilterComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'android',
                    template: `<ng-content *ngIf="show"></ng-content>`,
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [DEVICE]
                }] }]; } });

/* eslint-disable @angular-eslint/component-selector */
class IOSFilterComponent {
    constructor(device) {
        this.show = device.os === platformNames.ios;
    }
}
IOSFilterComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: IOSFilterComponent, deps: [{ token: DEVICE }], target: i0.ɵɵFactoryTarget.Component });
IOSFilterComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.3", type: IOSFilterComponent, selector: "ios", ngImport: i0, template: `<ng-content *ngIf="show"></ng-content>`, isInline: true, dependencies: [{ kind: "directive", type: i1$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: IOSFilterComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'ios',
                    template: `<ng-content *ngIf="show"></ng-content>`,
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [DEVICE]
                }] }]; } });

const CDK_COMPONENTS = [ActionBarComponent, ActionBarScope, ActionItemDirective, NavigationButtonDirective, ListViewComponent, TemplateKeyDirective, TabViewDirective, TabViewItemDirective, AndroidFilterComponent, IOSFilterComponent];
registerNativeScriptViewComponents();
class NativeScriptCommonModule {
}
NativeScriptCommonModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NativeScriptCommonModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NativeScriptCommonModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.2.3", ngImport: i0, type: NativeScriptCommonModule, declarations: [ActionBarComponent, ActionBarScope, ActionItemDirective, NavigationButtonDirective, ListViewComponent, TemplateKeyDirective, TabViewDirective, TabViewItemDirective, AndroidFilterComponent, IOSFilterComponent], imports: [CommonModule, FramePageModule], exports: [CommonModule, FramePageModule, ActionBarComponent, ActionBarScope, ActionItemDirective, NavigationButtonDirective, ListViewComponent, TemplateKeyDirective, TabViewDirective, TabViewItemDirective, AndroidFilterComponent, IOSFilterComponent] });
NativeScriptCommonModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NativeScriptCommonModule, providers: [ModalDialogService], imports: [CommonModule, FramePageModule, CommonModule, FramePageModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NativeScriptCommonModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, FramePageModule],
                    declarations: [...CDK_COMPONENTS],
                    exports: [CommonModule, FramePageModule, ...CDK_COMPONENTS],
                    providers: [ModalDialogService],
                    schemas: [NO_ERRORS_SCHEMA],
                }]
        }] });

function generateFallbackRootView(parentRootView) {
    if (parentRootView) {
        return parentRootView;
    }
    return new AppHostView(new Color('white'));
}
function errorHandler() {
    return new ErrorHandler();
}
function generateRandomId() {
    return `${Date.now()}` + '_' + Math.random().toString(36).substr(2, 9);
}
const NATIVESCRIPT_MODULE_STATIC_PROVIDERS = [
    { provide: APP_ROOT_VIEW, useFactory: generateFallbackRootView, deps: [[new Optional(), new SkipSelf(), APP_ROOT_VIEW]] },
    { provide: ɵINJECTOR_SCOPE, useValue: 'root' },
    { provide: ErrorHandler, useFactory: errorHandler, deps: [] },
    { provide: ViewUtil, useClass: ViewUtil, deps: [NAMESPACE_FILTERS, [new Optional(), ENABLE_REUSABE_VIEWS]] },
    {
        provide: NativeScriptRendererFactory,
        useClass: NativeScriptRendererFactory,
        deps: [APP_ROOT_VIEW, NAMESPACE_FILTERS, NATIVESCRIPT_ROOT_MODULE_ID, [new Optional(), ENABLE_REUSABE_VIEWS]],
    },
    { provide: NATIVESCRIPT_ROOT_MODULE_ID, useFactory: generateRandomId },
    { provide: RendererFactory2, useExisting: NativeScriptRendererFactory },
    { provide: NAMESPACE_FILTERS, useClass: PlatformNamespaceFilter, deps: [DEVICE], multi: true },
    { provide: DEVICE, useValue: Device },
    { provide: XhrFactory, useClass: NativescriptXhrFactory, deps: [] },
];
const NATIVESCRIPT_MODULE_PROVIDERS = [{ provide: ViewportScroller, useClass: ɵNullViewportScroller }];
class NativeScriptModule {
    constructor(parentModule) {
        if (parentModule) {
            throw new Error(`NativeScriptModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.`);
        }
    }
}
NativeScriptModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NativeScriptModule, deps: [{ token: NativeScriptModule, optional: true, skipSelf: true }], target: i0.ɵɵFactoryTarget.NgModule });
NativeScriptModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.2.3", ngImport: i0, type: NativeScriptModule, declarations: [DetachedLoader], imports: [ApplicationModule, NativeScriptCommonModule], exports: [ApplicationModule, DetachedLoader, NativeScriptCommonModule] });
NativeScriptModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NativeScriptModule, providers: [...NATIVESCRIPT_MODULE_STATIC_PROVIDERS, ...NATIVESCRIPT_MODULE_PROVIDERS], imports: [ApplicationModule, NativeScriptCommonModule, ApplicationModule, NativeScriptCommonModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NativeScriptModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [ApplicationModule, NativeScriptCommonModule],
                    declarations: [DetachedLoader],
                    providers: [...NATIVESCRIPT_MODULE_STATIC_PROVIDERS, ...NATIVESCRIPT_MODULE_PROVIDERS],
                    exports: [ApplicationModule, DetachedLoader, NativeScriptCommonModule],
                    schemas: [NO_ERRORS_SCHEMA],
                }]
        }], ctorParameters: function () { return [{ type: NativeScriptModule, decorators: [{
                    type: Optional
                }, {
                    type: SkipSelf
                }, {
                    type: Inject,
                    args: [NativeScriptModule]
                }] }]; } });

class RootViewProxy extends ContentView {
    constructor(parentRootLayout) {
        super();
        this.parentRootLayout = parentRootLayout;
    }
    _addView(view, atIndex) {
        super._addView(view, atIndex);
        if (this.parentRootLayout.getChildIndex(this) < 0) {
            this.parentRootLayout.insertChild(this, 0);
        }
    }
    _removeView(view) {
        super._removeView(view);
        this.parentRootLayout.removeChild(this);
    }
}
/**
 * This generates a RootLayout and returns a RootViewProxy.
 * Setting RootViewProxy.content will add the view to the bottom of the RootLayout
 * Setting RootViewProxy.content = null will remove the view from the RootLayout
 * @returns RootViewProxy that will insert content into the start of the RootLayout
 */
function generateRootLayoutAndProxy() {
    let rootView = Application.getRootView();
    if (!rootView || !(rootView instanceof RootLayout)) {
        rootView = new RootLayout();
        Application.resetRootView({ create: () => rootView });
    }
    const viewProxy = new RootViewProxy(rootView);
    // (rootView as RootLayout).insertChild(viewProxy, 0);
    return viewProxy;
}
class RootCompositeModule {
}
RootCompositeModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: RootCompositeModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
RootCompositeModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.2.3", ngImport: i0, type: RootCompositeModule });
RootCompositeModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: RootCompositeModule, providers: [
        { provide: DISABLE_ROOT_VIEW_HANDLING, useValue: true },
        { provide: APP_ROOT_VIEW, useFactory: generateRootLayoutAndProxy },
    ] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: RootCompositeModule, decorators: [{
            type: NgModule,
            args: [{
                    providers: [
                        { provide: DISABLE_ROOT_VIEW_HANDLING, useValue: true },
                        { provide: APP_ROOT_VIEW, useFactory: generateRootLayoutAndProxy },
                    ],
                }]
        }] });

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Configuration for opening a modal dialog with the MatDialog service.
 */
class NativeDialogConfig {
    constructor() {
        /** Whether the dialog has a backdrop. */
        this.hasBackdrop = true;
        /** Whether the user can use escape or clicking on the backdrop to close the modal. */
        this.disableClose = false;
        /** Data being injected into the child component. */
        this.data = null;
        /**
         * Whether the dialog should close when the user goes backwards/forwards in history.
         * Note that this usually doesn't include clicking on links (unless the user is using
         * the `HashLocationStrategy`).
         */
        this.closeOnNavigation = true;
        this.nativeOptions = {};
        // TODO(jelbourn): add configuration for lifecycle hooks, ARIA labelling.
    }
}

// Counter for unique dialog ids.
let uniqueId = 0;
class NativeDialogRef {
    constructor(_nativeModalRef, id = `native-dialog-${uniqueId++}`) {
        this._nativeModalRef = _nativeModalRef;
        this.id = id;
        /** Subject for notifying the user that the dialog has finished opening. */
        this._afterOpened = new Subject();
        /** Subject for notifying the user that the dialog has finished closing. */
        this._afterClosed = new Subject();
        /** Subject for notifying the user that the dialog has started closing. */
        this._beforeClosed = new Subject();
        /** Current state of the dialog. */
        this._state = 0 /* NativeDialogState.OPEN */;
        // Pass the id along to the container.
        _nativeModalRef._id = id;
        // Emit when opening animation completes
        _nativeModalRef.stateChanged
            .pipe(filter((event) => event.state === 'opened'), take(1))
            .subscribe(() => {
            this._afterOpened.next();
            this._afterOpened.complete();
        });
        // Dispose overlay when closing animation is complete
        _nativeModalRef.stateChanged
            .pipe(filter((event) => event.state === 'closed'), take(1))
            .subscribe(() => {
            clearTimeout(this._closeFallbackTimeout);
            this._finishDialogClose();
            this._afterClosed.next(this._result);
            this._afterClosed.complete();
        });
        _nativeModalRef.onDismiss.subscribe(() => {
            this._beforeClosed.next(this._result);
            this._beforeClosed.complete();
            this.componentInstance = null;
            _nativeModalRef.dispose();
        });
    }
    /**
     * Close the dialog.
     * @param dialogResult Optional result to return to the dialog opener.
     */
    close(dialogResult) {
        this._result = dialogResult;
        // Transition the backdrop in parallel to the dialog.
        this._nativeModalRef.stateChanged
            .pipe(filter((event) => event.state === 'closing'), take(1))
            .subscribe((event) => {
            this._beforeClosed.next(dialogResult);
            this._beforeClosed.complete();
            this._nativeModalRef.dispose();
            // this._overlayRef.detachBackdrop();
            // The logic that disposes of the overlay depends on the exit animation completing, however
            // it isn't guaranteed if the parent view is destroyed while it's running. Add a fallback
            // timeout which will clean everything up if the animation hasn't fired within the specified
            // amount of time plus 100ms. We don't need to run this outside the NgZone, because for the
            // vast majority of cases the timeout will have been cleared before it has the chance to fire.
            this._closeFallbackTimeout = setTimeout(() => {
                this._finishDialogClose();
                this._afterClosed.next(this._result);
                this._afterClosed.complete();
            }, 
            //event.totalTime + 100);
            100);
        });
        this._state = 1 /* NativeDialogState.CLOSING */;
        this._nativeModalRef._startExitAnimation();
    }
    /**
     * Gets an observable that is notified when the dialog is finished opening.
     */
    afterOpened() {
        return this._afterOpened;
    }
    /**
     * Gets an observable that is notified when the dialog is finished closing.
     */
    afterClosed() {
        return this._afterClosed;
    }
    /**
     * Gets an observable that is notified when the dialog has started closing.
     */
    beforeClosed() {
        return this._beforeClosed;
    }
    /**
     * Gets an observable that emits when the overlay's backdrop has been clicked.
     */
    backdropClick() {
        throw new Error('Method not implemented');
    }
    /** Add a CSS class or an array of classes to the overlay pane. */
    addPanelClass(classes) {
        // this._overlayRef.addPanelClass(classes);
        return this;
    }
    /** Remove a CSS class or an array of classes from the overlay pane. */
    removePanelClass(classes) {
        // this._overlayRef.removePanelClass(classes);
        return this;
    }
    /** Gets the current state of the dialog's lifecycle. */
    getState() {
        return this._state;
    }
    /**
     * Finishes the dialog close by updating the state of the dialog
     * and disposing the overlay.
     */
    _finishDialogClose() {
        this._state = 2 /* NativeDialogState.CLOSED */;
        this._nativeModalRef.dispose();
    }
}

let NativeModalRef = class NativeModalRef {
    constructor(_config, _injector, location) {
        this._config = _config;
        this._injector = _injector;
        this.location = location;
        this.stateChanged = new Subject();
        this.onDismiss = new Subject();
        this._isDismissed = false;
        let parentView = this._config.viewContainerRef?.element.nativeElement || Application.getRootView();
        if ((parentView instanceof AppHostView || parentView instanceof AppHostAsyncView) && parentView.ngAppRoot) {
            parentView = parentView.ngAppRoot;
        }
        // _ngDialogRoot is the first child of the previously detached proxy.
        // It should have 'viewController' (iOS) or '_dialogFragment' (Android) available for
        // presenting future modal views.
        while (parentView._modal || parentView._ngDialogRoot) {
            parentView = parentView._modal || parentView._ngDialogRoot;
        }
        this.parentView = parentView;
        this._closeCallback = once(async () => {
            this.stateChanged.next({ state: 'closing' });
            if (!this._isDismissed) {
                this.modalViewRef.firstNativeLikeView?.closeModal();
            }
            await this.location?._closeModalNavigation();
            // this.detachedLoaderRef?.destroy();
            if (this.modalViewRef?.firstNativeLikeView.isLoaded) {
                fromEvent(this.modalViewRef.firstNativeLikeView, 'unloaded')
                    .pipe(take(1))
                    .subscribe(() => this.stateChanged.next({ state: 'closed' }));
            }
            else {
                this.stateChanged.next({ state: 'closed' });
            }
        });
    }
    _generateDetachedContainer(vcRef) {
        const detachedFactory = (this._config.componentFactoryResolver || this._injector.get(ComponentFactoryResolver)).resolveComponentFactory(DetachedLoader);
        if (vcRef) {
            this.detachedLoaderRef = vcRef.createComponent(detachedFactory);
        }
        else {
            this.detachedLoaderRef = detachedFactory.create(this._config.viewContainerRef?.injector || this._injector);
            this._injector.get(ApplicationRef).attachView(this.detachedLoaderRef.hostView);
        }
        this.detachedLoaderRef.changeDetectorRef.detectChanges();
    }
    attachTemplatePortal(portal) {
        this.startModalNavigation();
        const vcRef = portal.viewContainerRef || this._config.viewContainerRef;
        this._generateDetachedContainer(vcRef);
        portal.viewContainerRef = this.detachedLoaderRef.instance.vc;
        const targetView = new ContentView();
        this.portalOutlet = new NativeScriptDomPortalOutlet(targetView, this._config.componentFactoryResolver || this._injector.get(ComponentFactoryResolver), this._injector.get(ApplicationRef), this._injector);
        const templateRef = this.portalOutlet.attach(portal);
        this.modalViewRef = new NgViewRef(templateRef);
        this.modalViewRef.firstNativeLikeView['__ng_modal_id__'] = this._id;
        // if we don't detach the view from its parent, ios gets mad
        this.modalViewRef.detachNativeLikeView();
        const userOptions = this._config.nativeOptions || {};
        this.parentView.showModal(this.modalViewRef.firstNativeLikeView, {
            context: null,
            ...userOptions,
            closeCallback: async () => {
                await this.location?._closeModalNavigation();
                this.onDismiss.next();
                this.onDismiss.complete();
            },
            cancelable: !this._config.disableClose,
        });
        //   if (this.modalView !== templateRef.rootNodes[0]) {
        //     componentRef.location.nativeElement._ngDialogRoot = this.modalView;
        //   }
        return templateRef;
    }
    attachComponentPortal(portal) {
        this.startModalNavigation();
        const targetView = new ContentView();
        this.portalOutlet = new NativeScriptDomPortalOutlet(targetView, this._config.componentFactoryResolver || this._injector.get(ComponentFactoryResolver), this._injector.get(ApplicationRef), this._injector);
        const componentRef = this.portalOutlet.attach(portal);
        ɵdetectChanges(componentRef.instance);
        this.modalViewRef = new NgViewRef(componentRef);
        if (this.modalViewRef.firstNativeLikeView !== this.modalViewRef.view) {
            this.modalViewRef.view._ngDialogRoot = this.modalViewRef.firstNativeLikeView;
        }
        this.modalViewRef.firstNativeLikeView['__ng_modal_id__'] = this._id;
        // if we don't detach the view from its parent, ios gets mad
        this.modalViewRef.detachNativeLikeView();
        const userOptions = this._config.nativeOptions || {};
        this.parentView.showModal(this.modalViewRef.firstNativeLikeView, {
            context: null,
            ...userOptions,
            closeCallback: async () => {
                this._isDismissed = true;
                this._closeCallback(); // close callback can only be called once, so we call it here to setup the exit events
                this.onDismiss.next();
                this.onDismiss.complete();
            },
            cancelable: !this._config.disableClose,
        });
        return componentRef;
    }
    _startExitAnimation() {
        this._closeCallback();
    }
    dispose() {
        this.portalOutlet.dispose();
    }
    startModalNavigation() {
        const frame = this.parentView instanceof Frame ? this.parentView : this.parentView?.page?.frame || Frame.topmost();
        this.location?._beginModalNavigation(frame);
    }
};
NativeModalRef = __decorate([
    __param(2, Optional()),
    __metadata("design:paramtypes", [NativeDialogConfig, Injector, NSLocationStrategy])
], NativeModalRef);

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/** Injection token that can be used to access the data that was passed in to a dialog. */
const NATIVE_DIALOG_DATA = new InjectionToken('NativeDialogData');
/** Injection token that can be used to specify default dialog options. */
const NATIVE_DIALOG_DEFAULT_OPTIONS = new InjectionToken('native-dialog-default-options');
/**
 * Base class for dialog services. The base dialog service allows
 * for arbitrary dialog refs and dialog container components.
 */
class _NativeDialogBase {
    constructor(_injector, _defaultOptions, _parentDialog, _dialogRefConstructor, _nativeModalType, _dialogDataToken, locationStrategy) {
        this._injector = _injector;
        this._defaultOptions = _defaultOptions;
        this._parentDialog = _parentDialog;
        this._dialogRefConstructor = _dialogRefConstructor;
        this._nativeModalType = _nativeModalType;
        this._dialogDataToken = _dialogDataToken;
        this.locationStrategy = locationStrategy;
        this._openDialogsAtThisLevel = [];
        this._afterAllClosedAtThisLevel = new Subject();
        this._afterOpenedAtThisLevel = new Subject();
        // TODO (jelbourn): tighten the typing right-hand side of this expression.
        /**
         * Stream that emits when all open dialog have finished closing.
         * Will emit on subscribe if there are no open dialogs to begin with.
         */
        this.afterAllClosed = defer(() => (this.openDialogs.length ? this._getAfterAllClosed() : this._getAfterAllClosed().pipe(startWith(undefined))));
    }
    /** Keeps track of the currently-open dialogs. */
    get openDialogs() {
        return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel;
    }
    /** Stream that emits when a dialog has been opened. */
    get afterOpened() {
        return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel;
    }
    _getAfterAllClosed() {
        const parent = this._parentDialog;
        return parent ? parent._getAfterAllClosed() : this._afterAllClosedAtThisLevel;
    }
    open(componentOrTemplateRef, config) {
        config = _applyConfigDefaults(config, this._defaultOptions || new NativeDialogConfig());
        if (config.id && this.getDialogById(config.id) && (typeof ngDevMode === 'undefined' || ngDevMode)) {
            throw Error(`Dialog with id "${config.id}" exists already. The dialog id must be unique.`);
        }
        const dialogRef = this._attachDialogContent(componentOrTemplateRef, config);
        this.openDialogs.push(dialogRef);
        dialogRef.afterClosed().subscribe(() => this._removeOpenDialog(dialogRef));
        this.afterOpened.next(dialogRef);
        // Notify the dialog container that the content has been attached.
        // dialogContainer._initializeWithAttachedContent();
        return dialogRef;
    }
    /**
     * Closes all of the currently-open dialogs.
     */
    closeAll() {
        this._closeDialogs(this.openDialogs);
    }
    /**
     * Finds an open dialog by its id.
     * @param id ID to use when looking up the dialog.
     */
    getDialogById(id) {
        return this.openDialogs.find((dialog) => dialog.id === id);
    }
    ngOnDestroy() {
        // Only close the dialogs at this level on destroy
        // since the parent service may still be active.
        this._closeDialogs(this._openDialogsAtThisLevel);
        this._afterAllClosedAtThisLevel.complete();
        this._afterOpenedAtThisLevel.complete();
    }
    /**
     * Attaches the user-provided component to the already-created dialog container.
     * @param componentOrTemplateRef The type of component being loaded into the dialog,
     *     or a TemplateRef to instantiate as the content.
     * @param dialogContainer Reference to the wrapping dialog container.
     * @param overlayRef Reference to the overlay in which the dialog resides.
     * @param config The dialog configuration.
     * @returns A promise resolving to the MatDialogRef that should be returned to the user.
     */
    _attachDialogContent(componentOrTemplateRef, config) {
        // Create a reference to the dialog we're creating in order to give the user a handle
        // to modify and close it.
        const nativeModalRef = new this._nativeModalType(config, this._injector, this.locationStrategy);
        const dialogRef = new this._dialogRefConstructor(nativeModalRef, config.id);
        if (componentOrTemplateRef instanceof TemplateRef) {
            //     const detachedFactory = options.resolver.resolveComponentFactory(DetachedLoader);
            //     if(options.attachToContainerRef) {
            //         detachedLoaderRef = options.attachToContainerRef.createComponent(detachedFactory, 0, childInjector, null);
            //     } else {
            //         detachedLoaderRef = detachedFactory.create(childInjector); // this DetachedLoader is **completely** detached
            //         this.appRef.attachView(detachedLoaderRef.hostView); // we attach it to the applicationRef, so it becomes a "root" view in angular's hierarchy
            //     }
            //     detachedLoaderRef.changeDetectorRef.detectChanges(); // force a change detection
            //     detachedLoaderRef.instance.createTemplatePortal(options.templateRef);
            nativeModalRef.attachTemplatePortal(
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            new TemplatePortal(componentOrTemplateRef, null, { $implicit: config.data, dialogRef }));
        }
        else {
            const injector = this._createInjector(config, dialogRef);
            const contentRef = nativeModalRef.attachComponentPortal(new ComponentPortal(componentOrTemplateRef, config.viewContainerRef, injector));
            dialogRef.componentInstance = contentRef.instance;
        }
        return dialogRef;
    }
    /**
     * Creates a custom injector to be used inside the dialog. This allows a component loaded inside
     * of a dialog to close itself and, optionally, to return a value.
     * @param config Config object that is used to construct the dialog.
     * @param dialogRef Reference to the dialog.
     * @param dialogContainer Dialog container element that wraps all of the contents.
     * @returns The custom injector that can be used inside the dialog.
     */
    _createInjector(config, dialogRef) {
        const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
        // The dialog container should be provided as the dialog container and the dialog's
        // content are created out of the same `ViewContainerRef` and as such, are siblings
        // for injector purposes. To allow the hierarchy that is expected, the dialog
        // container is explicitly provided in the injector.
        const providers = [
            { provide: this._dialogDataToken, useValue: config.data },
            { provide: this._dialogRefConstructor, useValue: dialogRef },
        ];
        return Injector.create({ parent: userInjector || this._injector, providers });
    }
    /**
     * Removes a dialog from the array of open dialogs.
     * @param dialogRef Dialog to be removed.
     */
    _removeOpenDialog(dialogRef) {
        const index = this.openDialogs.indexOf(dialogRef);
        if (index > -1) {
            this.openDialogs.splice(index, 1);
            // If all the dialogs were closed, remove/restore the `aria-hidden`
            // to a the siblings and emit to the `afterAllClosed` stream.
            if (!this.openDialogs.length) {
                this._getAfterAllClosed().next();
            }
        }
    }
    /** Closes all of the dialogs in an array. */
    _closeDialogs(dialogs) {
        let i = dialogs.length;
        while (i--) {
            // The `_openDialogs` property isn't updated after close until the rxjs subscription
            // runs on the next microtask, in addition to modifying the array as we're going
            // through it. We loop through all of them and call close without assuming that
            // they'll be removed from the list instantaneously.
            dialogs[i].close();
        }
    }
}
_NativeDialogBase.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: _NativeDialogBase, deps: "invalid", target: i0.ɵɵFactoryTarget.Directive });
_NativeDialogBase.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.2.3", type: _NativeDialogBase, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: _NativeDialogBase, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: undefined }, { type: undefined }, { type: i0.Type }, { type: i0.Type }, { type: i0.InjectionToken }, { type: NSLocationStrategy }]; } });
/**
 * Service to open Material Design modal dialogs.
 */
class NativeDialogService extends _NativeDialogBase {
    constructor(injector, defaultOptions, parentDialog, location) {
        super(injector, defaultOptions, parentDialog, NativeDialogRef, NativeModalRef, NATIVE_DIALOG_DATA, location);
    }
}
NativeDialogService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NativeDialogService, deps: [{ token: i0.Injector }, { token: NATIVE_DIALOG_DEFAULT_OPTIONS, optional: true }, { token: NativeDialogService, optional: true, skipSelf: true }, { token: NSLocationStrategy, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
NativeDialogService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NativeDialogService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NativeDialogService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: NativeDialogConfig, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [NATIVE_DIALOG_DEFAULT_OPTIONS]
                }] }, { type: NativeDialogService, decorators: [{
                    type: Optional
                }, {
                    type: SkipSelf
                }] }, { type: NSLocationStrategy, decorators: [{
                    type: Optional
                }] }]; } });
/**
 * Applies default options to the dialog config.
 * @param config Config to be modified.
 * @param defaultOptions Default options provided.
 * @returns The new configuration object.
 */
function _applyConfigDefaults(config, defaultOptions) {
    return { ...defaultOptions, ...config };
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Button that will close the current dialog.
 */
// eslint-disable-next-line @angular-eslint/directive-class-suffix
class NativeDialogCloseDirective {
    constructor(
    // The dialog title directive is always used in combination with a `MatDialogRef`.
    // tslint:disable-next-line: lightweight-tokens
    dialogRef, _elementRef, _dialog) {
        this.dialogRef = dialogRef;
        this._elementRef = _elementRef;
        this._dialog = _dialog;
    }
    ngOnInit() {
        if (!this.dialogRef) {
            // When this directive is included in a dialog via TemplateRef (rather than being
            // in a Component), the DialogRef isn't available via injection because embedded
            // views cannot be given a custom injector. Instead, we look up the DialogRef by
            // ID. This must occur in `onInit`, as the ID binding for the dialog container won't
            // be resolved at constructor time.
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.dialogRef = getClosestDialog(this._elementRef, this._dialog.openDialogs);
        }
    }
    ngOnChanges(changes) {
        const proxiedChange = changes['_matDialogClose'] || changes['_matDialogCloseResult'];
        if (proxiedChange) {
            this.dialogResult = proxiedChange.currentValue;
        }
    }
    _onButtonClick() {
        // Determinate the focus origin using the click event, because using the FocusMonitor will
        // result in incorrect origins. Most of the time, close buttons will be auto focused in the
        // dialog, and therefore clicking the button won't result in a focus change. This means that
        // the FocusMonitor won't detect any origin change, and will always output `program`.
        this.dialogRef.close(this.dialogResult);
    }
}
NativeDialogCloseDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NativeDialogCloseDirective, deps: [{ token: NativeDialogRef, optional: true }, { token: i0.ElementRef }, { token: NativeDialogService }], target: i0.ɵɵFactoryTarget.Directive });
NativeDialogCloseDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.2.3", type: NativeDialogCloseDirective, selector: "[native-dialog-close], [nativeDialogClose]", inputs: { dialogResult: ["native-dialog-close", "dialogResult"], _matDialogClose: ["nativeDialogClose", "_matDialogClose"] }, host: { listeners: { "tap": "_onButtonClick()" } }, exportAs: ["nativeDialogClose"], usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NativeDialogCloseDirective, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: '[native-dialog-close], [nativeDialogClose]',
                    exportAs: 'nativeDialogClose',
                }]
        }], ctorParameters: function () { return [{ type: NativeDialogRef, decorators: [{
                    type: Optional
                }] }, { type: i0.ElementRef }, { type: NativeDialogService }]; }, propDecorators: { dialogResult: [{
                type: Input,
                args: ['native-dialog-close']
            }], _matDialogClose: [{
                type: Input,
                args: ['nativeDialogClose']
            }], _onButtonClick: [{
                type: HostListener,
                args: ['tap']
            }] } });
/**
 * Finds the closest MatDialogRef to an element by looking at the DOM.
 * @param element Element relative to which to look for a dialog.
 * @param openDialogs References to the currently-open dialogs.
 */
function getClosestDialog(element, openDialogs) {
    let view = element.nativeElement.parent;
    while (view && !Object.hasOwnProperty.call(view, '__ng_modal_id__')) {
        view = view.parent;
    }
    return view ? openDialogs.find((dialog) => dialog.id === view['__ng_modal_id__']) : null;
}

class NativeDialogModule {
}
NativeDialogModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NativeDialogModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NativeDialogModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.2.3", ngImport: i0, type: NativeDialogModule, declarations: [NativeDialogCloseDirective], exports: [NativeDialogCloseDirective] });
NativeDialogModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NativeDialogModule, providers: [NativeDialogService] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NativeDialogModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NativeDialogCloseDirective],
                    exports: [NativeDialogCloseDirective],
                    providers: [NativeDialogService],
                }]
        }] });

// Allows greater flexibility with `file-system` and Angular
// Also provides a way for `file-system` to be mocked for testing
class NSFileSystem {
    currentApp() {
        return knownFolders.currentApp();
    }
    fileFromPath(path) {
        return File.fromPath(path);
    }
    fileExists(path) {
        return File.exists(path);
    }
}
NSFileSystem.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NSFileSystem, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
NSFileSystem.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NSFileSystem });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NSFileSystem, decorators: [{
            type: Injectable
        }] });

/**
 * creates a DetachedLoader either linked to the ViewContainerRef or the ApplicationRef if ViewContainerRef is not defined
 * @param resolver component factory resolver
 * @param injector default injector, unused if viewContainerRef is set
 * @param viewContainerRef where the view should live in the angular tree
 * @returns reference to the DetachedLoader
 */
function generateDetachedLoader(resolver, injector, viewContainerRef) {
    injector = viewContainerRef?.injector || injector;
    const detachedFactory = resolver.resolveComponentFactory(DetachedLoader);
    const detachedLoaderRef = viewContainerRef?.createComponent(detachedFactory) || detachedFactory.create(injector);
    if (!viewContainerRef) {
        injector.get(ApplicationRef).attachView(detachedLoaderRef.hostView);
    }
    detachedLoaderRef.changeDetectorRef.detectChanges();
    return detachedLoaderRef;
}
/**
 * Generates a NgViewRef from a component or template. @see NgViewRef
 * Pass keepNativeViewAttached as `true` if you don't want the first native view to be detached from its parent.
 * For opening modals and others, the firstNativeLikeView should be detached.
 * @param typeOrTemplate ComponentType or TemplateRef that should be instanced
 * @param options options for creating the view
 * @returns NgViewRef
 */
function generateNativeScriptView(typeOrTemplate, options) {
    let detachedLoaderRef = options.detachedLoaderRef;
    const reusingDetachedLoader = !!detachedLoaderRef;
    if (reusingDetachedLoader) {
        options.viewContainerRef = detachedLoaderRef.instance.vc;
    }
    const injector = options.viewContainerRef?.injector || options.injector;
    const resolver = options.resolver || injector.get(ComponentFactoryResolver);
    if (!detachedLoaderRef && (options.viewContainerRef || typeOrTemplate instanceof TemplateRef)) {
        detachedLoaderRef = generateDetachedLoader(resolver, injector, options.viewContainerRef);
    }
    let portal;
    if (typeOrTemplate instanceof TemplateRef) {
        portal = new TemplatePortal(typeOrTemplate, detachedLoaderRef.instance.vc);
    }
    else {
        portal = new ComponentPortal(typeOrTemplate, detachedLoaderRef?.instance.vc);
    }
    const parentView = new ContentView();
    const portalOutlet = new NativeScriptDomPortalOutlet(parentView, resolver, injector.get(ApplicationRef), injector);
    const componentOrTemplateRef = portalOutlet.attach(portal);
    componentOrTemplateRef.onDestroy(() => {
        portalOutlet.dispose();
    });
    if (detachedLoaderRef && !reusingDetachedLoader) {
        componentOrTemplateRef.onDestroy(() => {
            detachedLoaderRef.destroy();
        });
    }
    const viewRef = new NgViewRef(componentOrTemplateRef);
    viewRef.detachedLoaderRef = detachedLoaderRef;
    if (!options.keepNativeViewAttached) {
        viewRef.detachNativeLikeView();
    }
    return viewRef;
}

class BaseValueAccessor {
    constructor(view) {
        this.view = view;
        this.pendingChangeNotification = 0;
        this.onChange = (_) => { };
        this.onTouched = () => { };
    }
    registerOnChange(fn) {
        this.onChange = (arg) => {
            if (this.pendingChangeNotification) {
                clearTimeout(this.pendingChangeNotification);
            }
            this.pendingChangeNotification = setTimeout(() => {
                this.pendingChangeNotification = 0;
                fn(arg);
            }, 20);
        };
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.view.isEnabled = !isDisabled;
    }
    writeValue(_) { }
    normalizeValue(value) {
        return isBlank(value) ? unsetValue : value;
    }
}

const TEXT_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => TextValueAccessor),
    multi: true,
};
/**
 * The accessor for writing a text and listening to changes that is used by the
 * {@link NgModel} directives.
 *
 *  ### Example
 *  ```
 *  <TextField [(ngModel)]="model.test">
 *  ```
 */
class TextValueAccessor extends BaseValueAccessor {
    // tslint:disable-line:directive-class-suffix
    constructor(elementRef) {
        super(elementRef.nativeElement);
    }
    writeValue(value) {
        const normalized = super.normalizeValue(value ? `${value}` : value);
        this.view.text = normalized;
    }
}
TextValueAccessor.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: TextValueAccessor, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
TextValueAccessor.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.2.3", type: TextValueAccessor, selector: "TextField[ngModel],TextField[formControlName],TextField[formControl],textField[ngModel],textField[formControlName],textField[formControl],textfield[ngModel],textfield[formControlName],textfield[formControl],text-field[ngModel],text-field[formControlName],text-field[formControl],TextView[ngModel],TextView[formControlName],TextView[formControl],textView[ngModel],textView[formControlName],textView[formControl],textview[ngModel],textview[formControlName],textview[formControl],text-view[ngModel],text-view[formControlName],text-view[formControl],SearchBar[ngModel],SearchBar[formControlName],SearchBar[formControl],searchBar[ngModel],searchBar[formControlName],searchBar[formControl],searchbar[ngModel],searchbar[formControlName],searchbar[formControl],search-bar[ngModel], search-bar[formControlName],search-bar[formControl]", host: { listeners: { "blur": "onTouched()", "textChange": "onChange($event.value)" } }, providers: [TEXT_VALUE_ACCESSOR], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: TextValueAccessor, decorators: [{
            type: Directive,
            args: [{
                    selector: 'TextField[ngModel],TextField[formControlName],TextField[formControl],' +
                        'textField[ngModel],textField[formControlName],textField[formControl],' +
                        'textfield[ngModel],textfield[formControlName],textfield[formControl],' +
                        'text-field[ngModel],text-field[formControlName],text-field[formControl],' +
                        'TextView[ngModel],TextView[formControlName],TextView[formControl],' +
                        'textView[ngModel],textView[formControlName],textView[formControl],' +
                        'textview[ngModel],textview[formControlName],textview[formControl],' +
                        'text-view[ngModel],text-view[formControlName],text-view[formControl],' +
                        'SearchBar[ngModel],SearchBar[formControlName],SearchBar[formControl],' +
                        'searchBar[ngModel],searchBar[formControlName],searchBar[formControl],' +
                        'searchbar[ngModel],searchbar[formControlName],searchbar[formControl],' +
                        'search-bar[ngModel], search-bar[formControlName],search-bar[formControl]',
                    providers: [TEXT_VALUE_ACCESSOR],
                    host: {
                        '(blur)': 'onTouched()',
                        '(textChange)': 'onChange($event.value)',
                    },
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; } });

const CHECKED_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => CheckedValueAccessor),
    multi: true,
};
/**
 * The accessor for setting a checked property and listening to changes that is used by the
 * {@link NgModel} directives.
 *
 *  ### Example
 *  ```
 *  <Switch [(ngModel)]="model.test">
 *  ```
 */
class CheckedValueAccessor extends BaseValueAccessor {
    // tslint:disable-line:directive-class-suffix
    constructor(elementRef) {
        super(elementRef.nativeElement);
    }
    writeValue(value) {
        const normalized = super.normalizeValue(value);
        this.view.checked = normalized;
    }
}
CheckedValueAccessor.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: CheckedValueAccessor, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
CheckedValueAccessor.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.2.3", type: CheckedValueAccessor, selector: "Switch[ngModel],Switch[formControlName],Switch[formControl],switch[ngModel],switch[formControlName],switch[formControl]", host: { listeners: { "checkedChange": "onChange($event.value)" } }, providers: [CHECKED_VALUE_ACCESSOR], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: CheckedValueAccessor, decorators: [{
            type: Directive,
            args: [{
                    selector: 'Switch[ngModel],Switch[formControlName],Switch[formControl],' + 'switch[ngModel],switch[formControlName],switch[formControl]',
                    providers: [CHECKED_VALUE_ACCESSOR],
                    host: {
                        '(checkedChange)': 'onChange($event.value)',
                    },
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; } });

const DATE_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => DateValueAccessor),
    multi: true,
};
/**
 * The accessor for setting a date and listening to changes that is used by the
 * {@link NgModel} directives.
 *
 *  ### Example
 *  ```
 *  <DatePicker [(ngModel)]="model.test">
 *  ```
 */
class DateValueAccessor extends BaseValueAccessor {
    // tslint:disable-line:directive-class-suffix
    constructor(elementRef) {
        super(elementRef.nativeElement);
    }
    writeValue(value) {
        const normalized = super.normalizeValue(value);
        this.view.date = normalized;
    }
}
DateValueAccessor.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: DateValueAccessor, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
DateValueAccessor.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.2.3", type: DateValueAccessor, selector: "DatePicker[ngModel],DatePicker[formControlName],DatePicker[formControl],datepicker[ngModel],datepicker[formControlName],datepicker[formControl],datePicker[ngModel],datePicker[formControlName],datePicker[formControl],date-picker[ngModel],date-picker[formControlName],date-picker[formControl]", host: { listeners: { "dateChange": "onChange($event.value)" } }, providers: [DATE_VALUE_ACCESSOR], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: DateValueAccessor, decorators: [{
            type: Directive,
            args: [{
                    selector: 'DatePicker[ngModel],DatePicker[formControlName],DatePicker[formControl],' + 'datepicker[ngModel],datepicker[formControlName],datepicker[formControl],' + 'datePicker[ngModel],datePicker[formControlName],datePicker[formControl],' + 'date-picker[ngModel],date-picker[formControlName],date-picker[formControl]',
                    providers: [DATE_VALUE_ACCESSOR],
                    host: {
                        '(dateChange)': 'onChange($event.value)',
                    },
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; } });

const TIME_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => TimeValueAccessor),
    multi: true,
};
/**
 * The accessor for setting a time and listening to changes that is used by the
 * {@link NgModel} directives.
 *
 *  ### Example
 *  ```
 *  <TimePicker [(ngModel)]="model.test">
 *  ```
 */
class TimeValueAccessor extends BaseValueAccessor {
    // tslint:disable-line:directive-class-suffix
    constructor(elementRef) {
        super(elementRef.nativeElement);
    }
    writeValue(value) {
        const normalized = super.normalizeValue(value);
        this.view.time = normalized;
    }
}
TimeValueAccessor.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: TimeValueAccessor, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
TimeValueAccessor.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.2.3", type: TimeValueAccessor, selector: "TimePicker[ngModel],TimePicker[formControlName],TimePicker[formControl],timepicker[ngModel],timepicker[formControlName],timepicker[formControl],timePicker[ngModel],timePicker[formControlName],timePicker[formControl],time-picker[ngModel],time-picker[formControlName],time-picker[formControl]", host: { listeners: { "timeChange": "onChange($event.value)" } }, providers: [TIME_VALUE_ACCESSOR], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: TimeValueAccessor, decorators: [{
            type: Directive,
            args: [{
                    selector: 'TimePicker[ngModel],TimePicker[formControlName],TimePicker[formControl],' + 'timepicker[ngModel],timepicker[formControlName],timepicker[formControl],' + 'timePicker[ngModel],timePicker[formControlName],timePicker[formControl],' + 'time-picker[ngModel],time-picker[formControlName],time-picker[formControl]',
                    providers: [TIME_VALUE_ACCESSOR],
                    host: {
                        '(timeChange)': 'onChange($event.value)',
                    },
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; } });

const NUMBER_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => NumberValueAccessor),
    multi: true,
};
/**
 * The accessor for setting a value and listening to changes that is used by the
 * {@link NgModel}
 *
 *  ### Example
 *  ```
 *  <Slider [(ngModel)]="model.test">
 *  ```
 */
class NumberValueAccessor extends BaseValueAccessor {
    // tslint:disable-line:directive-class-suffix
    constructor(elementRef) {
        super(elementRef.nativeElement);
    }
    writeValue(value) {
        const normalized = super.normalizeValue(value);
        this.view.value = normalized;
    }
}
NumberValueAccessor.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NumberValueAccessor, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
NumberValueAccessor.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.2.3", type: NumberValueAccessor, selector: "Slider[ngModel],Slider[formControlName],Slider[formControl],slider[ngModel],slider[formControlName],slider[formControl]", host: { listeners: { "valueChange": "onChange($event.value)" } }, providers: [NUMBER_VALUE_ACCESSOR], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NumberValueAccessor, decorators: [{
            type: Directive,
            args: [{
                    selector: 'Slider[ngModel],Slider[formControlName],Slider[formControl],' + 'slider[ngModel],slider[formControlName],slider[formControl]',
                    providers: [NUMBER_VALUE_ACCESSOR],
                    host: {
                        '(valueChange)': 'onChange($event.value)',
                    },
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; } });

const SELECTED_INDEX_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => SelectedIndexValueAccessor),
    multi: true,
};
/**
 * The accessor for setting a selectedIndex and listening to changes that is used by the
 * {@link NgModel} directives.
 *
 *  ### Example
 *  ```
 *  <SegmentedBar [(ngModel)]="model.test">
 *  ```
 */
class SelectedIndexValueAccessor extends BaseValueAccessor {
    // tslint:disable-line:max-line-length directive-class-suffix
    constructor(elementRef) {
        super(elementRef.nativeElement);
    }
    writeValue(value) {
        const normalized = super.normalizeValue(value);
        this.value = normalized;
        if (this.viewInitialized) {
            this.view.selectedIndex = this.value;
        }
    }
    ngAfterViewInit() {
        this.viewInitialized = true;
        this.view.selectedIndex = this.value;
    }
}
SelectedIndexValueAccessor.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: SelectedIndexValueAccessor, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
SelectedIndexValueAccessor.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.2.3", type: SelectedIndexValueAccessor, selector: "SegmentedBar[ngModel],SegmentedBar[formControlName],SegmentedBar[formControl],segmentedBar[ngModel],segmentedBar[formControlName],segmentedBar[formControl],segmentedbar[ngModel],segmentedbar[formControlName],segmentedbar[formControl],segmented-bar[ngModel],segmented-bar[formControlName],segmented-bar[formControl],ListPicker[ngModel],ListPicker[formControlName],ListPicker[formControl],listPicker[ngModel],listPicker[formControlName],listPicker[formControl],listpicker[ngModel],listpicker[formControlName],listpicker[formControl],list-picker[ngModel],list-picker[formControlName],list-picker[formControl],TabView[ngModel],TabView[formControlName],TabView[formControl],tabView[ngModel],tabView[formControlName],tabView[formControl],tabview[ngModel],tabview[formControlName],tabview[formControl],tab-view[ngModel],tab-view[formControlName],tab-view[formControl]", host: { listeners: { "selectedIndexChange": "onChange($event.value)" } }, providers: [SELECTED_INDEX_VALUE_ACCESSOR], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: SelectedIndexValueAccessor, decorators: [{
            type: Directive,
            args: [{
                    selector: 'SegmentedBar[ngModel],SegmentedBar[formControlName],SegmentedBar[formControl],' +
                        'segmentedBar[ngModel],segmentedBar[formControlName],segmentedBar[formControl],' +
                        'segmentedbar[ngModel],segmentedbar[formControlName],segmentedbar[formControl],' +
                        'segmented-bar[ngModel],segmented-bar[formControlName],segmented-bar[formControl],' +
                        'ListPicker[ngModel],ListPicker[formControlName],ListPicker[formControl],' +
                        'listPicker[ngModel],listPicker[formControlName],listPicker[formControl],' +
                        'listpicker[ngModel],listpicker[formControlName],listpicker[formControl],' +
                        'list-picker[ngModel],list-picker[formControlName],list-picker[formControl],' +
                        'TabView[ngModel],TabView[formControlName],TabView[formControl],' +
                        'tabView[ngModel],tabView[formControlName],tabView[formControl],' +
                        'tabview[ngModel],tabview[formControlName],tabview[formControl],' +
                        'tab-view[ngModel],tab-view[formControlName],tab-view[formControl]',
                    providers: [SELECTED_INDEX_VALUE_ACCESSOR],
                    host: {
                        '(selectedIndexChange)': 'onChange($event.value)',
                    },
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; } });

class NativeScriptFormsModule {
}
NativeScriptFormsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NativeScriptFormsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NativeScriptFormsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.2.3", ngImport: i0, type: NativeScriptFormsModule, declarations: [TextValueAccessor, CheckedValueAccessor, DateValueAccessor, TimeValueAccessor, SelectedIndexValueAccessor, NumberValueAccessor], imports: [FormsModule], exports: [FormsModule, TextValueAccessor, CheckedValueAccessor, DateValueAccessor, TimeValueAccessor, SelectedIndexValueAccessor, NumberValueAccessor] });
NativeScriptFormsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NativeScriptFormsModule, imports: [FormsModule, FormsModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NativeScriptFormsModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [TextValueAccessor, CheckedValueAccessor, DateValueAccessor, TimeValueAccessor, SelectedIndexValueAccessor, NumberValueAccessor],
                    providers: [],
                    imports: [FormsModule],
                    exports: [FormsModule, TextValueAccessor, CheckedValueAccessor, DateValueAccessor, TimeValueAccessor, SelectedIndexValueAccessor, NumberValueAccessor],
                }]
        }] });

const DASH_CASE_REGEXP = /-+([a-z0-9])/g;
function dashCaseToCamelCase(input) {
    return input.replace(DASH_CASE_REGEXP, (...m) => m[1].toUpperCase());
}
function createKeyframeAnimation(styles, duration, delay, easing) {
    const info = createKeyframeAnimationInfo(styles, duration, delay, easing);
    return KeyframeAnimation.keyframeAnimationFromInfo(info);
}
const createKeyframeAnimationInfo = (styles, duration, delay, easing) => ({
    isForwards: true,
    duration: duration || 0.01,
    delay,
    curve: getCurve(easing),
    keyframes: styles.map(parseAnimationKeyframe),
});
const getCurve = (value) => animationTimingFunctionConverter(value);
const parseAnimationKeyframe = (styles) => ({
    duration: getKeyframeDuration(styles),
    declarations: getDeclarations(styles),
});
const getKeyframeDuration = (styles) => styles.offset;
function getDeclarations(styles) {
    const keys = Array.from(styles.keys());
    const unparsedDeclarations = keys.map((property) => ({ property, value: styles.get(property) }));
    return parseKeyframeDeclarations(unparsedDeclarations);
}

class NativeScriptAnimationPlayer {
    constructor(target, keyframes, duration, delay, easing) {
        this.target = target;
        this.duration = duration;
        this.delay = delay;
        this.parentPlayer = null;
        this._startSubscriptions = [];
        this._doneSubscriptions = [];
        this._finished = false;
        this._started = false;
        this.initKeyframeAnimation(keyframes, duration, delay, easing);
    }
    get totalTime() {
        return this.delay + this.duration;
    }
    init() { }
    hasStarted() {
        return this._started;
    }
    onStart(fn) {
        this._startSubscriptions.push(fn);
    }
    onDone(fn) {
        this._doneSubscriptions.push(fn);
    }
    onDestroy(fn) {
        this._doneSubscriptions.push(fn);
    }
    play() {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.animationsLog(`NativeScriptAnimationPlayer.play`);
        }
        if (!this.animation) {
            return;
        }
        if (!this._started) {
            this._started = true;
            this._startSubscriptions.forEach((fn) => fn());
            this._startSubscriptions = [];
        }
        // When this issue https://github.com/NativeScript/NativeScript/issues/7984 is fixes in @nativescript/core
        // we can change this fix and apply the one that is recommended in that issue.
        if (this.target.isLoaded) {
            this.playAnimation();
        }
        else {
            this.target.on(View.loadedEvent, this.onTargetLoaded.bind(this));
        }
    }
    onTargetLoaded(args) {
        this.target.off(View.loadedEvent, this.onTargetLoaded);
        this.playAnimation();
    }
    playAnimation() {
        this.animation
            .play(this.target)
            .then(() => this.onFinish())
            .catch((_e) => { });
    }
    pause() { }
    finish() {
        this.onFinish();
    }
    reset() {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.animationsLog(`NativeScriptAnimationPlayer.reset`);
        }
        if (this.animation && this.animation.isPlaying) {
            this.animation.cancel();
        }
    }
    restart() {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.animationsLog(`NativeScriptAnimationPlayer.restart`);
        }
        this.reset();
        this.play();
    }
    destroy() {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.animationsLog(`NativeScriptAnimationPlayer.destroy`);
        }
        this.onFinish();
    }
    setPosition(_p) {
        throw new Error('AnimationPlayer.setPosition method is not supported!');
    }
    getPosition() {
        return 0;
    }
    initKeyframeAnimation(keyframes, duration, delay, easing) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.animationsLog(`NativeScriptAnimationPlayer.initKeyframeAnimation`);
        }
        this.animation = createKeyframeAnimation(keyframes, duration, delay, easing);
    }
    onFinish() {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.animationsLog(`NativeScriptAnimationPlayer.onFinish`);
        }
        if (this._finished) {
            return;
        }
        this._finished = true;
        this._started = false;
        this._doneSubscriptions.forEach((fn) => fn());
        this._doneSubscriptions = [];
    }
}

class Selector {
    constructor(rawSelector) {
        this.parse(rawSelector);
    }
    match(element) {
        return this.nsSelectorMatch(element) || this.classSelectorsMatch(element);
    }
    parse(rawSelector) {
        const selectors = rawSelector.split(',').map((s) => s.trim());
        this.nsSelectors = selectors.map(CSSHelper.createSelector);
        this.classSelectors = selectors.filter((s) => s.startsWith('.')).map((s) => s.substring(1));
    }
    nsSelectorMatch(element) {
        return this.nsSelectors.some((s) => s.match(element));
    }
    classSelectorsMatch(element) {
        return this.classSelectors.some((s) => this.hasClass(element, s));
    }
    // we're using that instead of match for classes
    // that are dynamically added by the animation engine
    // such as .ng-trigger, that's added for every :enter view
    hasClass(element, cls) {
        return element && element['$$classes'] && element['$$classes'][cls];
    }
}
class NativeScriptAnimationDriver {
    getParentElement(element) {
        return element?.parent;
    }
    validateStyleProperty(property) {
        NativeScriptDebug.animationsLog(`CssAnimationProperty.validateStyleProperty: ${property}`);
        return NativeScriptAnimationDriver.validProperties.indexOf(property) !== -1;
    }
    matchesElement(element, rawSelector) {
        NativeScriptDebug.animationsLog(`NativeScriptAnimationDriver.matchesElement ` + `element: ${element}, selector: ${rawSelector}`);
        const selector = this.makeSelector(rawSelector);
        return selector.match(element);
    }
    containsElement(elm1, elm2) {
        NativeScriptDebug.animationsLog(`NativeScriptAnimationDriver.containsElement ` + `element1: ${elm1}, element2: ${elm2}`);
        // Checking if the parent is our fake body object
        if (elm1['isOverride']) {
            return true;
        }
        const params = { originalView: elm2 };
        const result = this.visitDescendants(elm1, viewMatches, params);
        return result.found;
    }
    query(element, rawSelector, multi) {
        NativeScriptDebug.animationsLog(`NativeScriptAnimationDriver.query ` + `element: ${element}, selector: ${rawSelector} ` + `multi: ${multi}`);
        const selector = this.makeSelector(rawSelector);
        const params = { selector, multi };
        const result = this.visitDescendants(element, queryDescendants, params);
        return result.matches || [];
    }
    computeStyle(element, prop) {
        NativeScriptDebug.animationsLog(`NativeScriptAnimationDriver.computeStyle ` + `element: ${element}, prop: ${prop}`);
        const camelCaseProp = dashCaseToCamelCase(prop);
        return element.style[camelCaseProp];
    }
    animate(element, keyframes, duration, delay, easing) {
        NativeScriptDebug.animationsLog(`NativeScriptAnimationDriver.animate ` + `element: ${element}, keyframes: ${keyframes} ` + `duration: ${duration}, delay: ${delay} ` + `easing: ${easing}`);
        return new NativeScriptAnimationPlayer(element, keyframes, duration, delay, easing);
    }
    makeSelector(rawSelector) {
        return new Selector(rawSelector);
    }
    visitDescendants(element, cb, cbParams) {
        const result = {};
        // fill the result obj with the result from the callback function
        eachDescendant(element, (child) => cb(child, result, cbParams));
        return result;
    }
}
NativeScriptAnimationDriver.validProperties = [...CssAnimationProperty._getPropertyNames(), 'transform'];
function viewMatches(element, result, params) {
    if (element === params.originalView) {
        result.found = true;
    }
    return !result.found;
}
function queryDescendants(element, result, params) {
    if (!result.matches) {
        result.matches = [];
    }
    const { selector, multi } = params;
    // skip comment and text nodes
    // because they are not actual Views
    // and cannot be animated
    if (element instanceof InvisibleNode || !selector.match(element)) {
        return true;
    }
    if (element instanceof ProxyViewContainer) {
        element.eachChild((child) => {
            result.matches.push(child);
            return true;
        });
    }
    else {
        result.matches.push(element);
    }
    return multi;
}

class InjectableAnimationEngine extends ɵAnimationEngine {
    constructor(doc, driver, normalizer) {
        super(doc.body, driver, normalizer);
    }
}
InjectableAnimationEngine.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: InjectableAnimationEngine, deps: [{ token: DOCUMENT }, { token: i1$2.AnimationDriver }, { token: i1$2.ɵAnimationStyleNormalizer }], target: i0.ɵɵFactoryTarget.Injectable });
InjectableAnimationEngine.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: InjectableAnimationEngine });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: InjectableAnimationEngine, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i1$2.AnimationDriver }, { type: i1$2.ɵAnimationStyleNormalizer }]; } });
function instantiateSupportedAnimationDriver() {
    return new NativeScriptAnimationDriver();
}
function instantiateRendererFactory(renderer, engine, zone) {
    return new ɵAnimationRendererFactory(renderer, engine, zone);
}
function instantiateDefaultStyleNormalizer() {
    return new ɵWebAnimationsStyleNormalizer();
}
class NativeScriptAnimationsModule {
    constructor(parentModule) {
        // Prevents NativeScriptAnimationsModule from getting imported multiple times
        throwIfAlreadyLoaded(parentModule, 'NativeScriptAnimationsModule');
    }
}
NativeScriptAnimationsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NativeScriptAnimationsModule, deps: [{ token: NativeScriptAnimationsModule, optional: true, skipSelf: true }], target: i0.ɵɵFactoryTarget.NgModule });
NativeScriptAnimationsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.2.3", ngImport: i0, type: NativeScriptAnimationsModule, imports: [NativeScriptCommonModule] });
NativeScriptAnimationsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NativeScriptAnimationsModule, providers: [
        {
            provide: AnimationDriver,
            useFactory: instantiateSupportedAnimationDriver,
        },
        { provide: AnimationBuilder, useClass: ɵBrowserAnimationBuilder },
        {
            provide: ɵAnimationStyleNormalizer,
            useFactory: instantiateDefaultStyleNormalizer,
        },
        { provide: ɵAnimationEngine, useClass: InjectableAnimationEngine },
        {
            provide: RendererFactory2,
            useFactory: instantiateRendererFactory,
            deps: [NativeScriptRendererFactory, ɵAnimationEngine, NgZone],
        },
    ], imports: [NativeScriptCommonModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NativeScriptAnimationsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [NativeScriptCommonModule],
                    providers: [
                        {
                            provide: AnimationDriver,
                            useFactory: instantiateSupportedAnimationDriver,
                        },
                        { provide: AnimationBuilder, useClass: ɵBrowserAnimationBuilder },
                        {
                            provide: ɵAnimationStyleNormalizer,
                            useFactory: instantiateDefaultStyleNormalizer,
                        },
                        { provide: ɵAnimationEngine, useClass: InjectableAnimationEngine },
                        {
                            provide: RendererFactory2,
                            useFactory: instantiateRendererFactory,
                            deps: [NativeScriptRendererFactory, ɵAnimationEngine, NgZone],
                        },
                    ],
                }]
        }], ctorParameters: function () { return [{ type: NativeScriptAnimationsModule, decorators: [{
                    type: Optional
                }, {
                    type: SkipSelf
                }] }]; } });

function isLocalRequest(url) {
    return url.indexOf('~') === 0 || url.indexOf('/') === 0;
}
function getAbsolutePath(url, nsFileSystem) {
    url = url.replace('~', '').replace('/', '');
    url = path.join(nsFileSystem.currentApp().path, url);
    return url;
}
function processLocalFileRequest(url, nsFileSystem, successResponse, errorResponse) {
    url = getAbsolutePath(url, nsFileSystem);
    // request from local app resources
    return new Observable$1((observer) => {
        if (nsFileSystem.fileExists(url)) {
            const localFile = nsFileSystem.fileFromPath(url);
            localFile.readText().then((data) => {
                try {
                    const json = JSON.parse(data);
                    observer.next(successResponse(url, json, 200));
                    observer.complete();
                }
                catch (error) {
                    // Even though the response status was 2xx, this is still an error.
                    // The parse error contains the text of the body that failed to parse.
                    const errorResult = { error, text: data };
                    observer.error(errorResponse(url, errorResult, 200));
                }
            }, (err) => {
                observer.error(errorResponse(url, err, 400));
            });
        }
        else {
            observer.error(errorResponse(url, 'Not Found', 404));
        }
    });
}

class NsHttpBackEnd extends HttpXhrBackend {
    constructor(xhrFactory, nsFileSystem) {
        super(xhrFactory);
        this.nsFileSystem = nsFileSystem;
    }
    handle(req) {
        let result;
        if (isLocalRequest(req.url)) {
            result = this.handleLocalFileRequest(req.url);
        }
        else {
            result = super.handle(req);
        }
        return result;
    }
    handleLocalFileRequest(url) {
        return processLocalFileRequest(url, this.nsFileSystem, createSuccessResponse, createErrorResponse);
    }
}
NsHttpBackEnd.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NsHttpBackEnd, deps: [{ token: i1$1.XhrFactory }, { token: NSFileSystem }], target: i0.ɵɵFactoryTarget.Injectable });
NsHttpBackEnd.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NsHttpBackEnd });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NsHttpBackEnd, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$1.XhrFactory }, { type: NSFileSystem }]; } });
function createSuccessResponse(url, body, status) {
    return new HttpResponse({
        url,
        body,
        status,
        statusText: 'OK',
    });
}
function createErrorResponse(url, body, status) {
    return new HttpErrorResponse({
        url,
        error: body,
        status,
        statusText: 'ERROR',
    });
}

class NativeScriptHttpClientModule {
}
NativeScriptHttpClientModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NativeScriptHttpClientModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NativeScriptHttpClientModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.2.3", ngImport: i0, type: NativeScriptHttpClientModule, imports: [HttpClientModule], exports: [HttpClientModule] });
NativeScriptHttpClientModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NativeScriptHttpClientModule, providers: [NSFileSystem, NsHttpBackEnd, { provide: HttpBackend, useExisting: NsHttpBackEnd }], imports: [HttpClientModule, HttpClientModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NativeScriptHttpClientModule, decorators: [{
            type: NgModule,
            args: [{
                    providers: [NSFileSystem, NsHttpBackEnd, { provide: HttpBackend, useExisting: NsHttpBackEnd }],
                    imports: [HttpClientModule],
                    exports: [HttpClientModule],
                }]
        }] });

/**
 * There are cases where multiple activatedRoute nodes should be associated/handled by the same PageRouterOutlet.
 * We can gat additional ActivatedRoutes nodes when there is:
 *  - Lazy loading - there is an additional ActivatedRoute node for the RouteConfig with the `loadChildren` setup
 *  - Componentless routes - there is an additional ActivatedRoute node for the componentless RouteConfig
 *
 * Example:
 *   R  <-- root
 *   |
 * feature (lazy module) <-- RouteConfig: { path: "lazy", loadChildren: "./feature/feature.module#FeatureModule" }
 *   |
 * module (componentless route) <-- RouteConfig: { path: "module", children: [...] } // Note: No 'component'
 *   |
 *  home <-- RouteConfig: { path: "module", component: MyComponent } - this is what we get as activatedRoute param
 *
 *  In these cases we will mark the top-most node (feature). NSRouteReuseStrategy will detach the tree there and
 *  use this ActivateRoute as a kay for caching.
 */
function findTopActivatedRouteNodeForOutlet(activatedRoute) {
    // TODO: test this and figure it out if it's really no longer needed
    return activatedRoute;
    // let outletActivatedRoute = activatedRoute;
    // while (outletActivatedRoute.parent && outletActivatedRoute.parent.routeConfig && !outletActivatedRoute.parent.routeConfig.component) {
    //   outletActivatedRoute = outletActivatedRoute.parent;
    // }
    // return outletActivatedRoute;
}
const pageRouterActivatedSymbol = Symbol('page-router-activated');
const loaderRefSymbol = Symbol('loader-ref');
function destroyComponentRef(componentRef) {
    if (componentRef) {
        const loaderRef = componentRef[loaderRefSymbol];
        if (loaderRef) {
            loaderRef.destroy();
        }
        componentRef.destroy();
    }
}

const getSnapshotKey = function (snapshot) {
    return snapshot.pathFromRoot.join('->');
};
/**
 * Detached state cache
 */
class DetachedStateCache {
    constructor() {
        this.cache = new Array();
    }
    get length() {
        return this.cache.length;
    }
    push(cacheItem) {
        this.cache.push(cacheItem);
    }
    pop() {
        return this.cache.pop();
    }
    peek() {
        return this.cache[this.cache.length - 1];
    }
    clear() {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routeReuseStrategyLog(`DetachedStateCache.clear() ${this.cache.length} items will be destroyed`);
        }
        while (this.cache.length > 0) {
            const state = this.cache.pop().state;
            if (!state.componentRef) {
                throw new Error('No componentRef found in DetachedRouteHandle');
            }
            destroyComponentRef(state.componentRef);
        }
    }
    clearModalCache() {
        let removedItemsCount = 0;
        const hasModalPages = this.cache.some((cacheItem) => {
            return cacheItem.isModal;
        });
        if (hasModalPages) {
            let modalCacheCleared = false;
            while (!modalCacheCleared) {
                let cacheItem = this.peek();
                const state = cacheItem.state;
                if (!state.componentRef) {
                    throw new Error('No componentRef found in DetachedRouteHandle');
                }
                destroyComponentRef(state.componentRef);
                if (cacheItem.isModal) {
                    modalCacheCleared = true;
                }
                this.pop();
                removedItemsCount++;
            }
        }
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routeReuseStrategyLog(`DetachedStateCache.clearModalCache() ${removedItemsCount} items will be destroyed`);
        }
    }
}
/**
 * Detaches subtrees loaded inside PageRouterOutlet in forward navigation
 * and reattaches them on back.
 * Reuses routes as long as their route config is the same.
 */
class NSRouteReuseStrategy {
    constructor(location) {
        this.location = location;
        this.cacheByOutlet = {};
    }
    shouldDetach(route) {
        route = findTopActivatedRouteNodeForOutlet(route);
        const { outlet } = this.findValidOutletAndKey(route);
        const key = getSnapshotKey(route);
        let isPageActivated = false;
        let tmp = route;
        while (!(isPageActivated = tmp[pageRouterActivatedSymbol]) && tmp.parent) {
            tmp = tmp.parent;
        }
        const isBack = outlet ? outlet.isPageNavigationBack : false;
        let shouldDetach = outlet && !isBack && isPageActivated;
        if (outlet) {
            if (outlet.parent && !outlet.parent.shouldDetach) {
                shouldDetach = false;
            }
            outlet.shouldDetach = shouldDetach;
        }
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routeReuseStrategyLog(`shouldDetach isBack: ${isBack} key: ${key} result: ${shouldDetach}`);
        }
        return shouldDetach;
    }
    findValidOutletAndKey(targetRoute) {
        let route = targetRoute;
        const routeOutletKey = this.location.getRouteFullPath(route);
        let outletKey = routeOutletKey;
        let outlet = this.location.findOutlet(outletKey, route);
        while (!outlet) {
            if (!route.parent) {
                return { outlet: null, outletKey: routeOutletKey };
            }
            route = route.parent;
            outletKey = this.location.getRouteFullPath(route);
            outlet = this.location.findOutlet(outletKey, route);
        }
        if (outlet) {
            while (!outlet.outletKeys.includes(outletKey)) {
                if (!route.parent) {
                    NativeScriptDebug.routeReuseStrategyLog(`Could not find valid outlet key for route: ${targetRoute}.`);
                    return { outlet, outletKey: routeOutletKey };
                }
                route = route.parent;
                outletKey = this.location.getRouteFullPath(route);
            }
        }
        return { outlet, outletKey };
    }
    shouldAttach(route) {
        route = findTopActivatedRouteNodeForOutlet(route);
        const { outlet, outletKey } = this.findValidOutletAndKey(route);
        const cache = this.cacheByOutlet[outletKey];
        if (!cache) {
            return false;
        }
        const key = getSnapshotKey(route);
        const isBack = outlet ? outlet.isPageNavigationBack : false;
        const shouldAttach = isBack && cache.peek()?.key === key;
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routeReuseStrategyLog(`shouldAttach isBack: ${isBack} key: ${key} result: ${shouldAttach}`);
        }
        if (outlet) {
            outlet.shouldDetach = true;
        }
        return shouldAttach;
    }
    store(route, state) {
        route = findTopActivatedRouteNodeForOutlet(route);
        const key = getSnapshotKey(route);
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routeReuseStrategyLog(`store key: ${key}, state: ${state}`);
        }
        const { outletKey } = this.findValidOutletAndKey(route);
        // tslint:disable-next-line:max-line-length
        const cache = (this.cacheByOutlet[outletKey] = this.cacheByOutlet[outletKey] || new DetachedStateCache());
        if (state) {
            let isModal = false;
            if (this.location._modalNavigationDepth > 0) {
                isModal = true;
            }
            cache.push({ key, state, isModal });
        }
        else {
            const topItem = cache.peek();
            if (topItem.key === key) {
                cache.pop();
                if (!cache.length) {
                    delete this.cacheByOutlet[outletKey];
                }
            }
            else {
                throw new Error("Trying to pop from DetachedStateCache but keys don't match. " + `expected: ${topItem.key} actual: ${key}`);
            }
        }
    }
    retrieve(route) {
        route = findTopActivatedRouteNodeForOutlet(route);
        const { outlet, outletKey } = this.findValidOutletAndKey(route);
        const cache = this.cacheByOutlet[outletKey];
        if (!cache) {
            return null;
        }
        const key = getSnapshotKey(route);
        const isBack = outlet ? outlet.isPageNavigationBack : false;
        const cachedItem = cache.peek();
        let state = null;
        if (isBack && cachedItem && cachedItem.key === key) {
            state = cachedItem.state;
        }
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routeReuseStrategyLog(`retrieved isBack: ${isBack} key: ${key} state: ${state}`);
        }
        return state;
    }
    shouldReuseRoute(future, curr) {
        const shouldReuse = future.routeConfig === curr.routeConfig;
        if (shouldReuse && curr && curr[pageRouterActivatedSymbol]) {
            // When reusing route - copy the pageRouterActivated to the new snapshot
            // It's needed in shouldDetach to determine if the route should be detached.
            future[pageRouterActivatedSymbol] = curr[pageRouterActivatedSymbol];
        }
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routeReuseStrategyLog(`shouldReuseRoute result: ${shouldReuse}`);
        }
        return shouldReuse;
    }
    clearCache(outletKey) {
        const cache = this.cacheByOutlet[outletKey];
        if (cache) {
            cache.clear();
        }
    }
    popCache(outletKey) {
        const cache = this.cacheByOutlet[outletKey];
        if (cache) {
            if (cache.peek()) {
                const state = cache.pop()?.state;
                if (state?.componentRef) {
                    destroyComponentRef(state?.componentRef);
                }
            }
        }
    }
    clearModalCache(outletKey) {
        const cache = this.cacheByOutlet[outletKey];
        if (cache) {
            cache.clearModalCache();
        }
    }
}
NSRouteReuseStrategy.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NSRouteReuseStrategy, deps: [{ token: NSLocationStrategy }], target: i0.ɵɵFactoryTarget.Injectable });
NSRouteReuseStrategy.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NSRouteReuseStrategy });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NSRouteReuseStrategy, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: NSLocationStrategy }]; } });

class RouterExtensions {
    constructor(router, locationStrategy, frameService) {
        this.router = router;
        this.locationStrategy = locationStrategy;
        this.frameService = frameService;
    }
    navigate(commands, extras) {
        if (extras) {
            this.locationStrategy._setNavigationOptions(extras);
        }
        return this.router.navigate(commands, extras);
    }
    navigateByUrl(url, options) {
        if (options) {
            this.locationStrategy._setNavigationOptions(options);
        }
        return this.router.navigateByUrl(url);
    }
    back(backNavigationOptions) {
        if (backNavigationOptions) {
            this.backOutlets(backNavigationOptions);
        }
        else {
            this.locationStrategy.back();
        }
    }
    canGoBack(backNavigationOptions) {
        let canGoBack = true;
        if (backNavigationOptions) {
            const { outletsToBack, outlets } = this.findOutletsToBack(backNavigationOptions);
            if (outletsToBack.length !== outlets.length) {
                NativeScriptDebug.routerError('No outlet found relative to activated route');
            }
            else {
                outletsToBack.forEach((outletToBack) => {
                    if (!this.locationStrategy.canGoBack(outletToBack)) {
                        canGoBack = false;
                    }
                });
            }
        }
        else {
            canGoBack = this.locationStrategy.canGoBack();
        }
        return canGoBack;
    }
    backToPreviousPage() {
        this.frameService.getFrame().goBack();
    }
    canGoBackToPreviousPage() {
        return this.frameService.getFrame().canGoBack();
    }
    backOutlets(options) {
        const { outletsToBack, outlets } = this.findOutletsToBack(options);
        if (outletsToBack.length !== outlets.length) {
            NativeScriptDebug.routerError('No outlet found relative to activated route');
        }
        else {
            outletsToBack.forEach((outletToBack) => {
                if (outletToBack.isPageNavigationBack) {
                    NativeScriptDebug.routerError('Attempted to call startGoBack while going back:');
                }
                else {
                    this.locationStrategy.back(outletToBack);
                }
            });
        }
    }
    // tslint:disable-next-line:max-line-length
    findOutletsToBack(options) {
        const rootRoute = this.router.routerState.root;
        let outlets = options.outlets;
        let relativeRoute = options.relativeTo || rootRoute;
        const relativeRouteOutlet = this.findOutletByRoute(relativeRoute);
        const isNSEmptyOutlet = relativeRouteOutlet && relativeRouteOutlet.isNSEmptyOutlet;
        // Lazy named outlet has added 'primary' inner NSEmptyOutlet child.
        // Take parent route when `relativeTo` option points to the outer named outlet.
        if (isNSEmptyOutlet && relativeRoute.outlet !== 'primary') {
            relativeRoute = relativeRoute.parent || relativeRoute;
        }
        outlets = outlets || [relativeRoute.outlet];
        const outletsToBack = this.findOutletsRecursive([...outlets], relativeRoute);
        return { outletsToBack: outletsToBack, outlets: outlets };
    }
    // warning, outlets is mutable!
    findOutletsRecursive(outlets, route) {
        if (!route || outlets.length === 0) {
            return [];
        }
        const outletsToBack = [];
        if (outlets.some((currentOutlet) => currentOutlet === route.outlet)) {
            const outlet = this.findOutletByRoute(route);
            if (outlet) {
                outlets.splice(outlets.indexOf(route.outlet), 1);
                outletsToBack.push(outlet);
            }
        }
        if (!route.children) {
            return outletsToBack;
        }
        for (let index = 0; index < route.children.length; index++) {
            if (outlets.length === 0) {
                break;
            }
            const currentRoute = route.children[index];
            outletsToBack.push(...this.findOutletsRecursive(outlets, currentRoute));
        }
        return outletsToBack;
    }
    findOutletByRoute(currentRoute) {
        let outlet;
        const currentRouteSnapshop = findTopActivatedRouteNodeForOutlet(currentRoute.snapshot);
        const outletKey = this.locationStrategy.getRouteFullPath(currentRouteSnapshop);
        outlet = this.locationStrategy.findOutlet(outletKey, currentRouteSnapshop);
        return outlet;
    }
}
RouterExtensions.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: RouterExtensions, deps: [{ token: i1$3.Router }, { token: NSLocationStrategy }, { token: FrameService }], target: i0.ɵɵFactoryTarget.Injectable });
RouterExtensions.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: RouterExtensions, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: RouterExtensions, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1$3.Router }, { type: NSLocationStrategy }, { type: FrameService }]; } });

/**
 * The nsRouterLink directive lets you link to specific parts of your app.
 *
 * Consider the following route configuration:
 * ```
 * [{ path: "/user", component: UserCmp }]
 * ```
 *
 * When linking to this `User` route, you can write:
 *
 * ```
 * <a [nsRouterLink]="["/user"]">link to user component</a>
 * ```
 *
 * NSRouterLink expects the value to be an array of path segments, followed by the params
 * for that level of routing. For instance `["/team", {teamId: 1}, "user", {userId: 2}]`
 * means that we want to generate a link to `/team;teamId=1/user;userId=2`.
 *
 * The first segment name can be prepended with `/`, `./`, or `../`.
 * If the segment begins with `/`, the router will look up the route from the root of the app.
 * If the segment begins with `./`, or doesn"t begin with a slash, the router will
 * instead look in the current component"s children for the route.
 * And if the segment begins with `../`, the router will go up one level.
 */
class NSRouterLink {
    constructor(ngZone, router, navigator, route, el) {
        this.ngZone = ngZone;
        this.router = router;
        this.navigator = navigator;
        this.route = route;
        this.el = el;
        this.pageTransition = true;
        this.commands = [];
    }
    ngAfterViewInit() {
        this.el.nativeElement.on('tap', () => {
            this.ngZone.run(() => {
                this.onTap();
            });
        });
    }
    set params(data) {
        if (Array.isArray(data)) {
            this.commands = data;
        }
        else {
            this.commands = [data];
        }
    }
    onTap() {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog(`nsRouterLink.tapped: ${this.commands} ` + `clear: ${this.clearHistory} ` + `transition: ${JSON.stringify(this.pageTransition)} ` + `duration: ${this.pageTransitionDuration}`);
        }
        const extras = this.getExtras();
        // this.navigator.navigateByUrl(this.urlTree, extras);
        this.navigator.navigate(this.commands, {
            ...extras,
            relativeTo: this.route,
            queryParams: this.queryParams,
            fragment: this.fragment,
            queryParamsHandling: this.queryParamsHandling,
            preserveFragment: attrBoolValue(this.preserveFragment),
        });
    }
    getExtras() {
        const transition = this.getTransition();
        return {
            skipLocationChange: attrBoolValue(this.skipLocationChange),
            replaceUrl: attrBoolValue(this.replaceUrl),
            clearHistory: this.convertClearHistory(this.clearHistory),
            animated: transition.animated,
            transition: transition.transition,
        };
    }
    get urlTree() {
        const urlTree = this.router.createUrlTree(this.commands, {
            relativeTo: this.route,
            queryParams: this.queryParams,
            fragment: this.fragment,
            queryParamsHandling: this.queryParamsHandling,
            preserveFragment: attrBoolValue(this.preserveFragment),
        });
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog(`nsRouterLink urlTree created: ${urlTree}`);
        }
        return urlTree;
    }
    convertClearHistory(value) {
        return value === true || value === 'true';
    }
    getTransition() {
        let transition;
        let animated;
        if (typeof this.pageTransition === 'boolean') {
            animated = this.pageTransition;
        }
        else if (typeof this.pageTransition === 'string') {
            if (this.pageTransition === 'none' || this.pageTransition === 'false') {
                animated = false;
            }
            else {
                animated = true;
                transition = {
                    name: this.pageTransition,
                };
            }
        }
        else {
            animated = true;
            transition = this.pageTransition;
        }
        let duration = +this.pageTransitionDuration;
        if (!isNaN(duration)) {
            transition = transition || {};
            transition.duration = duration;
        }
        return { animated, transition };
    }
}
NSRouterLink.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NSRouterLink, deps: [{ token: i0.NgZone }, { token: i1$3.Router }, { token: RouterExtensions }, { token: i1$3.ActivatedRoute }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
NSRouterLink.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.2.3", type: NSRouterLink, selector: "[nsRouterLink]", inputs: { target: "target", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", preserveQueryParams: "preserveQueryParams", preserveFragment: "preserveFragment", skipLocationChange: "skipLocationChange", replaceUrl: "replaceUrl", clearHistory: "clearHistory", pageTransition: "pageTransition", pageTransitionDuration: "pageTransitionDuration", params: ["nsRouterLink", "params"] }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NSRouterLink, decorators: [{
            type: Directive,
            args: [{ selector: '[nsRouterLink]' }]
        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: i1$3.Router }, { type: RouterExtensions }, { type: i1$3.ActivatedRoute }, { type: i0.ElementRef }]; }, propDecorators: { target: [{
                type: Input
            }], queryParams: [{
                type: Input
            }], fragment: [{
                type: Input
            }], queryParamsHandling: [{
                type: Input
            }], preserveQueryParams: [{
                type: Input
            }], preserveFragment: [{
                type: Input
            }], skipLocationChange: [{
                type: Input
            }], replaceUrl: [{
                type: Input
            }], clearHistory: [{
                type: Input
            }], pageTransition: [{
                type: Input
            }], pageTransitionDuration: [{
                type: Input
            }], params: [{
                type: Input,
                args: ['nsRouterLink']
            }] } });
function attrBoolValue(s) {
    return s === '' || !!s;
}

/* tslint:disable:forin */
function containsTree(container, containee, exact) {
    if (exact) {
        return equalSegmentGroups(container.root, containee.root);
    }
    else {
        return containsSegmentGroup(container.root, containee.root);
    }
}
function equalSegmentGroups(container, containee) {
    if (!equalPath(container.segments, containee.segments)) {
        return false;
    }
    if (container.numberOfChildren !== containee.numberOfChildren) {
        return false;
    }
    for (let c in containee.children) {
        if (!container.children[c]) {
            return false;
        }
        if (!equalSegmentGroups(container.children[c], containee.children[c])) {
            return false;
        }
    }
    return true;
}
function containsSegmentGroup(container, containee) {
    return containsSegmentGroupHelper(container, containee, containee.segments);
}
function containsSegmentGroupHelper(container, containee, containeePaths) {
    if (container.segments.length > containeePaths.length) {
        const current = container.segments.slice(0, containeePaths.length);
        if (!equalPath(current, containeePaths)) {
            return false;
        }
        if (containee.hasChildren()) {
            return false;
        }
        return true;
    }
    else if (container.segments.length === containeePaths.length) {
        if (!equalPath(container.segments, containeePaths)) {
            return false;
        }
        for (let c in containee.children) {
            if (!container.children[c]) {
                return false;
            }
            if (!containsSegmentGroup(container.children[c], containee.children[c])) {
                return false;
            }
        }
        return true;
    }
    else {
        const current = containeePaths.slice(0, container.segments.length);
        const next = containeePaths.slice(container.segments.length);
        if (!equalPath(container.segments, current)) {
            return false;
        }
        if (!container.children[PRIMARY_OUTLET]) {
            return false;
        }
        return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next);
    }
}
function equalPath(a, b) {
    if (a.length !== b.length) {
        return false;
    }
    for (let i = 0; i < a.length; ++i) {
        if (a[i].path !== b[i].path) {
            return false;
        }
    }
    return true;
}

/**
 * The NSRouterLinkActive directive lets you add a CSS class to an element when the link"s route
 * becomes active.
 *
 * Consider the following example:
 *
 * ```
 * <a [nsRouterLink]="/user/bob" [nsRouterLinkActive]="active-link">Bob</a>
 * ```
 *
 * When the url is either "/user" or "/user/bob", the active-link class will
 * be added to the component. If the url changes, the class will be removed.
 *
 * You can set more than one class, as follows:
 *
 * ```
 * <a [nsRouterLink]="/user/bob" [nsRouterLinkActive]="class1 class2">Bob</a>
 * <a [nsRouterLink]="/user/bob" [nsRouterLinkActive]="["class1", "class2"]">Bob</a>
 * ```
 *
 * You can configure NSRouterLinkActive by passing `exact: true`. This will add the
 * classes only when the url matches the link exactly.
 *
 * ```
 * <a [nsRouterLink]="/user/bob" [nsRouterLinkActive]="active-link"
 * [nsRouterLinkActiveOptions]="{exact: true}">Bob</a>
 * ```
 *
 * Finally, you can apply the NSRouterLinkActive directive to an ancestor of a RouterLink.
 *
 * ```
 * <div [nsRouterLinkActive]="active-link" [nsRouterLinkActiveOptions]="{exact: true}">
 *   <a [nsRouterLink]="/user/jim">Jim</a>
 *   <a [nsRouterLink]="/user/bob">Bob</a>
 * </div>
 * ```
 *
 * This will set the active-link class on the div tag if the url is either "/user/jim" or
 * "/user/bob".
 *
 * @stable
 */
class NSRouterLinkActive {
    constructor(router, element, renderer) {
        this.router = router;
        this.element = element;
        this.renderer = renderer;
        this.classes = [];
        this.active = false;
        this.nsRouterLinkActiveOptions = { exact: false };
        this.subscription = router.events.subscribe((s) => {
            if (s instanceof NavigationEnd) {
                this.update();
            }
        });
    }
    get isActive() {
        return this.active;
    }
    ngAfterContentInit() {
        this.links.changes.subscribe(() => this.update());
        this.update();
    }
    set nsRouterLinkActive(data) {
        if (Array.isArray(data)) {
            this.classes = data;
        }
        else {
            this.classes = data.split(' ');
        }
    }
    ngOnChanges(_) {
        this.update();
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    update() {
        if (!this.links) {
            return;
        }
        const hasActiveLinks = this.hasActiveLinks();
        // react only when status has changed to prevent unnecessary dom updates
        if (this.active !== hasActiveLinks) {
            const currentUrlTree = this.router.parseUrl(this.router.url);
            const isActiveLinks = this.reduceList(currentUrlTree, this.links);
            this.classes.forEach((c) => {
                if (isActiveLinks) {
                    this.renderer.addClass(this.element.nativeElement, c);
                }
                else {
                    this.renderer.removeClass(this.element.nativeElement, c);
                }
            });
        }
        Promise.resolve(hasActiveLinks).then((active) => (this.active = active));
    }
    reduceList(currentUrlTree, q) {
        return q.reduce((res, link) => {
            return res || containsTree(currentUrlTree, link.urlTree, this.nsRouterLinkActiveOptions.exact);
        }, false);
    }
    isLinkActive(router) {
        return (link) => router.isActive(link.urlTree, this.nsRouterLinkActiveOptions.exact);
    }
    hasActiveLinks() {
        return this.links.some(this.isLinkActive(this.router));
    }
}
NSRouterLinkActive.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NSRouterLinkActive, deps: [{ token: i1$3.Router }, { token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });
NSRouterLinkActive.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.2.3", type: NSRouterLinkActive, selector: "[nsRouterLinkActive]", inputs: { nsRouterLinkActiveOptions: "nsRouterLinkActiveOptions", nsRouterLinkActive: "nsRouterLinkActive" }, queries: [{ propertyName: "links", predicate: NSRouterLink }], exportAs: ["routerLinkActive"], usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NSRouterLinkActive, decorators: [{
            type: Directive,
            args: [{
                    selector: '[nsRouterLinkActive]',
                    exportAs: 'routerLinkActive',
                }]
        }], ctorParameters: function () { return [{ type: i1$3.Router }, { type: i0.ElementRef }, { type: i0.Renderer2 }]; }, propDecorators: { links: [{
                type: ContentChildren,
                args: [NSRouterLink]
            }], nsRouterLinkActiveOptions: [{
                type: Input
            }], nsRouterLinkActive: [{
                type: Input,
                args: ['nsRouterLinkActive']
            }] } });

class PageRoute {
    constructor(startRoute) {
        this.activatedRoute = new BehaviorSubject(startRoute);
    }
}
class DestructibleInjector {
    constructor(destructableProviders, parent) {
        this.destructableProviders = destructableProviders;
        this.parent = parent;
        this.refs = new Set();
    }
    get(token, notFoundValue, flags) {
        const ref = this.parent.get(token, notFoundValue, flags);
        if (this.destructableProviders.has(token)) {
            this.refs.add(ref);
        }
        return ref;
    }
    destroy() {
        this.refs.forEach((ref) => {
            if (ref.ngOnDestroy instanceof Function) {
                ref.ngOnDestroy();
            }
        });
        this.refs.clear();
    }
}
const routeToString = function (activatedRoute) {
    return activatedRoute.pathFromRoot.join('->');
};
registerElement('page-router-outlet', () => Frame);
// eslint-disable-next-line @angular-eslint/directive-selector
// eslint-disable-next-line @angular-eslint/directive-class-suffix
class PageRouterOutlet {
    constructor(parentContexts, location, name, actionBarVisibility, isEmptyOutlet, locationStrategy, componentFactoryResolver, resolver, changeDetector, pageFactory, routeReuseStrategy, ngZone, elRef, viewUtil) {
        this.parentContexts = parentContexts;
        this.location = location;
        this.locationStrategy = locationStrategy;
        this.componentFactoryResolver = componentFactoryResolver;
        this.resolver = resolver;
        this.changeDetector = changeDetector;
        this.pageFactory = pageFactory;
        this.routeReuseStrategy = routeReuseStrategy;
        this.ngZone = ngZone;
        // tslint:disable-line:directive-class-suffix
        this.activated = null;
        this._activatedRoute = null;
        this.attachEvents = new EventEmitter();
        this.detachEvents = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-rename
        this.activateEvents = new EventEmitter(); // tslint:disable-line:no-output-rename
        // eslint-disable-next-line @angular-eslint/no-output-rename
        this.deactivateEvents = new EventEmitter(); // tslint:disable-line:no-output-rename
        this.isEmptyOutlet = isEmptyOutlet;
        this.frame = elRef.nativeElement;
        this.setActionBarVisibility(actionBarVisibility);
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog(`PageRouterOutlet.constructor frame: ${this.frame}`);
        }
        this.name = name || PRIMARY_OUTLET;
        parentContexts.onChildOutletCreated(this.name, this);
        this.viewUtil = viewUtil;
        this.detachedLoaderFactory = resolver.resolveComponentFactory(DetachedLoader);
    }
    /** @deprecated from Angular since v4 */
    get locationInjector() {
        return this.location.injector;
    }
    /** @deprecated from Angular since v4 */
    get locationFactoryResolver() {
        return this.resolver;
    }
    get isActivated() {
        return !!this.activated;
    }
    get component() {
        if (!this.activated) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog('Outlet is not activated');
            }
            return;
        }
        return this.activated.instance;
    }
    get activatedRoute() {
        if (!this.activated) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog('Outlet is not activated');
            }
            return;
        }
        return this._activatedRoute;
    }
    get activatedRouteData() {
        if (this._activatedRoute) {
            return this._activatedRoute.snapshot.data;
        }
        return {};
    }
    setActionBarVisibility(actionBarVisibility) {
        switch (actionBarVisibility) {
            case 'always':
            case 'never':
                this.frame.actionBarVisibility = actionBarVisibility;
                return;
            default:
                this.frame.actionBarVisibility = 'auto';
        }
    }
    ngOnDestroy() {
        // In the event that the `parentContexts` has changed the outlet
        // via the creation of another outlet, the `onChildOutletDestroyed`
        // will be skipped
        if (this.parentContexts.getContext(this.name)?.outlet === this) {
            // Clear accumulated modal view page cache when page-router-outlet
            // destroyed on modal view closing
            this.parentContexts.onChildOutletDestroyed(this.name);
        }
        if (this.outlet) {
            this.outlet.outletKeys.forEach((key) => {
                this.routeReuseStrategy.clearModalCache(key);
            });
            this.locationStrategy.clearOutlet(this.frame);
        }
        else {
            NativeScriptDebug.routerLog('PageRouterOutlet.ngOnDestroy: no outlet available for page-router-outlet');
        }
        if (this.isActivated) {
            const c = this.activated.instance;
            this.activated.hostView.detach();
            destroyComponentRef(this.activated);
            this.deactivateEvents.emit(c);
            this.activated = null;
        }
    }
    deactivate() {
        if (!this.outlet || !this.outlet.isPageNavigationBack) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog('Currently not in page back navigation - component should be detached instead of deactivated.');
            }
            return;
        }
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog('PageRouterOutlet.deactivate() while going back - should destroy');
        }
        if (!this.isActivated) {
            return;
        }
        const c = this.activated.instance;
        destroyComponentRef(this.activated);
        this.activated = null;
        this._activatedRoute = null;
        this.deactivateEvents.emit(c);
    }
    /**
     * Called when the `RouteReuseStrategy` instructs to detach the subtree
     */
    detach() {
        if (!this.isActivated) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog('Outlet is not activated');
            }
            return;
        }
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog(`PageRouterOutlet.detach() - ${routeToString(this._activatedRoute)}`);
        }
        // Detach from ChangeDetection
        this.activated.hostView.detach();
        const component = this.activated;
        this.activated = null;
        this._activatedRoute = null;
        this.detachEvents.emit(component.instance);
        return component;
    }
    /**
     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree
     */
    attach(ref, activatedRoute) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog(`PageRouterOutlet.attach() - ${routeToString(activatedRoute)}`);
        }
        this.activated = ref;
        // reattach to ChangeDetection
        this.activated.hostView.markForCheck();
        this.activated.hostView.reattach();
        this._activatedRoute = activatedRoute;
        this.markActivatedRoute(activatedRoute);
        // we have a child with the same name, so we don't finish the back nav
        if (this.isFinalPageRouterOutlet()) {
            this.locationStrategy._finishBackPageNavigation(this.frame);
        }
        this.attachEvents.emit(ref.instance);
    }
    isFinalPageRouterOutlet() {
        let children = this.parentContexts.getContext(this.name)?.children;
        while (children) {
            const childContext = children.getContext(this.name);
            if (!childContext || !childContext.outlet) {
                return true;
            }
            if (childContext.outlet instanceof PageRouterOutlet) {
                return false;
            }
            children = childContext.children;
        }
        return true;
    }
    /**
     * Called by the Router to instantiate a new component during the commit phase of a navigation.
     * This method in turn is responsible for calling the `routerOnActivate` hook of its child.
     */
    activateWith(activatedRoute, resolver) {
        this.outlet = this.outlet || this.getOutlet(activatedRoute.snapshot);
        if (!this.outlet) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerError('No outlet found relative to activated route');
            }
            return;
        }
        this.outlet.isNSEmptyOutlet = this.isEmptyOutlet;
        this.locationStrategy.updateOutletFrame(this.outlet, this.frame, this.isEmptyOutlet);
        if (this.outlet && this.outlet.isPageNavigationBack) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog('Currently in page back navigation - component should be reattached instead of activated.');
            }
            if (this.isFinalPageRouterOutlet()) {
                this.locationStrategy._finishBackPageNavigation(this.frame);
            }
        }
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog(`PageRouterOutlet.activateWith() - ${routeToString(activatedRoute)}`);
        }
        this._activatedRoute = activatedRoute;
        this.markActivatedRoute(activatedRoute);
        resolver = resolver || this.resolver;
        this.activateOnGoForward(activatedRoute, resolver);
        this.activateEvents.emit(this.activated.instance);
    }
    activateOnGoForward(activatedRoute, loadedResolver) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog('PageRouterOutlet.activate() forward navigation - ' + 'create detached loader in the loader container');
        }
        let resolver;
        let ourInjector = this.location.injector;
        if (!(loadedResolver instanceof ComponentFactoryResolver)) {
            ourInjector = loadedResolver;
            resolver = loadedResolver?.get(ComponentFactoryResolver);
        }
        else {
            resolver = loadedResolver;
        }
        const factory = this.getComponentFactory(activatedRoute, resolver);
        const page = this.pageFactory({
            isNavigation: true,
            componentType: factory.componentType,
        });
        const destructables = new Set([]);
        const injector = Injector.create({
            providers: [
                { provide: Page, useValue: page },
                { provide: Frame, useValue: this.frame },
                { provide: PageRoute, useValue: new PageRoute(activatedRoute) },
                { provide: ActivatedRoute, useValue: activatedRoute },
                { provide: ChildrenOutletContexts, useValue: this.parentContexts.getOrCreateContext(this.name).children },
                { provide: PageService, useClass: PageService },
            ],
            parent: ourInjector,
        });
        const childInjector = new DestructibleInjector(destructables, injector);
        const loaderRef = this.location.createComponent(this.detachedLoaderFactory, this.location.length, childInjector, []);
        loaderRef.onDestroy(() => childInjector.destroy());
        this.changeDetector.markForCheck();
        this.activated = loaderRef.instance.loadWithFactoryInLocation(factory);
        this.activated.changeDetectorRef.detectChanges();
        this.loadComponentInPage(page, this.activated, { activatedRoute });
        this.activated[loaderRefSymbol] = loaderRef;
    }
    loadComponentInPage(page, componentRef, navigationContext) {
        // Component loaded. Find its root native view.
        const componentView = componentRef.location.nativeElement;
        // Remove it from original native parent.
        this.viewUtil.removeChild(componentView.parent, componentView);
        // Add it to the new page
        this.viewUtil.appendChild(page, componentView);
        let topActivatedRoute = findTopActivatedRouteNodeForOutlet(this._activatedRoute.snapshot);
        let outletKey = this.locationStrategy.getRouteFullPath(topActivatedRoute);
        const thisRouteKey = outletKey;
        while (!this.locationStrategy.findOutlet(outletKey)) {
            topActivatedRoute = topActivatedRoute.parent;
            if (!topActivatedRoute) {
                NativeScriptDebug.routerError('Could not find outlet for route: ' + thisRouteKey);
                break;
            }
            outletKey = this.locationStrategy.getRouteFullPath(topActivatedRoute);
        }
        const navigatedFromCallback = global.Zone.current.wrap((args) => {
            if (args.isBackNavigation) {
                this.locationStrategy._beginBackPageNavigation(this.frame, outletKey);
                this.locationStrategy.back(null, this.frame);
            }
        });
        // TODO: experiment with using NgZone instead of global above
        // const navigatedFromCallback = (args: NavigatedData) => {
        // 	if (args.isBackNavigation) {
        //     this.ngZone.run(() => {
        //       this.locationStrategy._beginBackPageNavigation(this.frame);
        //       this.locationStrategy.back(null, this.frame);
        //     });
        // 	}
        // };
        page.on(Page.navigatedFromEvent, navigatedFromCallback);
        componentRef.onDestroy(() => {
            if (page) {
                page.off(Page.navigatedFromEvent, navigatedFromCallback);
                page = null;
            }
        });
        const navOptions = this.locationStrategy._beginPageNavigation(this.frame);
        const isReplace = navOptions.replaceUrl && !navOptions.clearHistory;
        // Clear refCache if navigation with clearHistory
        if (navOptions.clearHistory) {
            const clearCallback = () => setTimeout(() => {
                if (this.outlet) {
                    // potential alternative fix (only fix children of the current outlet)
                    // const nests = outletKey.split('/');
                    // this.outlet.outletKeys.filter((k) => k.split('/').length >= nests.length).forEach((key) => this.routeReuseStrategy.clearCache(key));
                    this.outlet.outletKeys.forEach((key) => this.routeReuseStrategy.clearCache(key));
                }
            });
            page.once(Page.navigatedToEvent, clearCallback);
        }
        else if (navOptions.replaceUrl) {
            const clearCallback = () => setTimeout(() => {
                if (this.outlet) {
                    // potential alternative fix (only fix children of the current outlet)
                    // const nests = outletKey.split('/');
                    // this.outlet.outletKeys.filter((k) => k.split('/').length >= nests.length).forEach((key) => this.routeReuseStrategy.popCache(key));
                    this.outlet.outletKeys.forEach((key) => this.routeReuseStrategy.popCache(key));
                }
            });
            page.once(Page.navigatedToEvent, clearCallback);
        }
        const navigationEntry = {
            create() {
                return page;
            },
            context: navigationContext,
            clearHistory: navOptions.clearHistory,
            animated: navOptions.animated,
            transition: navOptions.transition,
        };
        if (isReplace && this.frame.currentPage) {
            this.frame.replacePage(navigationEntry);
        }
        else {
            this.frame.navigate(navigationEntry);
        }
    }
    // Find and mark the top activated route as an activated one.
    // In ns-location-strategy we are reusing components only if their corresponing routes
    // are marked as activated from this method.
    markActivatedRoute(activatedRoute) {
        const queue = [];
        queue.push(activatedRoute.snapshot);
        let currentRoute = queue.shift();
        while (currentRoute) {
            currentRoute.children.forEach((childRoute) => {
                queue.push(childRoute);
            });
            const topActivatedRoute = findTopActivatedRouteNodeForOutlet(currentRoute);
            const outletKey = this.locationStrategy.getRouteFullPath(topActivatedRoute);
            const outlet = this.locationStrategy.findOutlet(outletKey, topActivatedRoute);
            if (outlet && outlet.frames.length) {
                topActivatedRoute[pageRouterActivatedSymbol] = true;
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.routerLog('Activated route marked as page: ' + routeToString(topActivatedRoute));
                }
            }
            currentRoute = queue.shift();
        }
    }
    getComponentFactory(activatedRoute, loadedResolver) {
        const component = activatedRoute.routeConfig.component || activatedRoute.component;
        return loadedResolver ? loadedResolver.resolveComponentFactory(component) : this.componentFactoryResolver.resolveComponentFactory(component);
    }
    getOutlet(activatedRouteSnapshot) {
        const topActivatedRoute = findTopActivatedRouteNodeForOutlet(activatedRouteSnapshot);
        const outletKey = this.locationStrategy.getRouteFullPath(topActivatedRoute);
        let outlet = this.locationStrategy.findOutlet(outletKey, topActivatedRoute);
        // Named lazy loaded outlet.
        if (!outlet && this.isEmptyOutlet) {
            const parentOutletKey = this.locationStrategy.getRouteFullPath(topActivatedRoute.parent);
            outlet = this.locationStrategy.findOutlet(parentOutletKey, topActivatedRoute.parent);
            if (outlet) {
                outlet.outletKeys.push(outletKey);
            }
        }
        return outlet;
    }
}
PageRouterOutlet.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: PageRouterOutlet, deps: [{ token: i1$3.ChildrenOutletContexts }, { token: i0.ViewContainerRef }, { token: 'name', attribute: true }, { token: 'actionBarVisibility', attribute: true }, { token: 'isEmptyOutlet', attribute: true }, { token: NSLocationStrategy }, { token: i0.ComponentFactoryResolver }, { token: i0.ComponentFactoryResolver }, { token: i0.ChangeDetectorRef }, { token: PAGE_FACTORY }, { token: NSRouteReuseStrategy }, { token: i0.NgZone }, { token: i0.ElementRef }, { token: ViewUtil }], target: i0.ɵɵFactoryTarget.Directive });
PageRouterOutlet.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.2.3", type: PageRouterOutlet, selector: "page-router-outlet", outputs: { activateEvents: "activate", deactivateEvents: "deactivate" }, ngImport: i0 });
__decorate([
    profile,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [ActivatedRoute, Object]),
    __metadata("design:returntype", void 0)
], PageRouterOutlet.prototype, "activateWith", null);
__decorate([
    profile,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Page, ComponentRef, Object]),
    __metadata("design:returntype", void 0)
], PageRouterOutlet.prototype, "loadComponentInPage", null);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: PageRouterOutlet, decorators: [{
            type: Directive,
            args: [{ selector: 'page-router-outlet' }]
        }], ctorParameters: function () { return [{ type: i1$3.ChildrenOutletContexts }, { type: i0.ViewContainerRef }, { type: undefined, decorators: [{
                    type: Attribute,
                    args: ['name']
                }] }, { type: undefined, decorators: [{
                    type: Attribute,
                    args: ['actionBarVisibility']
                }] }, { type: undefined, decorators: [{
                    type: Attribute,
                    args: ['isEmptyOutlet']
                }] }, { type: NSLocationStrategy }, { type: i0.ComponentFactoryResolver }, { type: i0.ComponentFactoryResolver }, { type: i0.ChangeDetectorRef }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [PAGE_FACTORY]
                }] }, { type: NSRouteReuseStrategy }, { type: i0.NgZone }, { type: i0.ElementRef }, { type: ViewUtil }]; }, propDecorators: { activateEvents: [{
                type: Output,
                args: ['activate']
            }], deactivateEvents: [{
                type: Output,
                args: ['deactivate']
            }], activateWith: [], loadComponentInPage: [] } });

class NativescriptPlatformLocation extends PlatformLocation {
    constructor(locationStrategy) {
        super();
        this.locationStrategy = locationStrategy;
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog('NativescriptPlatformLocation.constructor()');
        }
    }
    getState() {
        return undefined;
    }
    getBaseHrefFromDOM() {
        return '/';
    }
    onPopState(fn) {
        this.locationStrategy.onPopState(fn);
        return () => { };
    }
    onHashChange(_fn) {
        return () => { };
    }
    get search() {
        return '';
    }
    get hash() {
        return '';
    }
    get pathname() {
        return this.locationStrategy.path();
    }
    set pathname(_newPath) {
        throw new Error('NativescriptPlatformLocation set pathname - not implemented');
    }
    pushState(state, title, url) {
        this.locationStrategy.pushState(state, title, url, null);
    }
    replaceState(state, title, url) {
        this.locationStrategy.replaceState(state, title, url, null);
    }
    forward() {
        throw new Error('NativescriptPlatformLocation.forward() - not implemented');
    }
    back() {
        this.locationStrategy.back();
    }
}
NativescriptPlatformLocation.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NativescriptPlatformLocation, deps: [{ token: NSLocationStrategy }], target: i0.ɵɵFactoryTarget.Injectable });
NativescriptPlatformLocation.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NativescriptPlatformLocation });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NativescriptPlatformLocation, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: NSLocationStrategy }]; } });

class NSEmptyOutletComponent {
    constructor(page) {
        this.page = page;
        if (this.page) {
            this.page.actionBarHidden = true;
            this.page.on('loaded', () => {
                if (this.pageRouterOutlet && this.page.frame) {
                    this.pageRouterOutlet.setActionBarVisibility(this.page.frame.actionBarVisibility);
                }
            });
        }
    }
}
NSEmptyOutletComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NSEmptyOutletComponent, deps: [{ token: i1.Page }], target: i0.ɵɵFactoryTarget.Component });
NSEmptyOutletComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.3", type: NSEmptyOutletComponent, selector: "ns-empty-outlet", viewQueries: [{ propertyName: "pageRouterOutlet", first: true, predicate: PageRouterOutlet, descendants: true, read: PageRouterOutlet }], ngImport: i0, template: "<page-router-outlet isEmptyOutlet='true'></page-router-outlet>", isInline: true, dependencies: [{ kind: "directive", type: PageRouterOutlet, selector: "page-router-outlet", outputs: ["activate", "deactivate"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NSEmptyOutletComponent, decorators: [{
            type: Component,
            args: [{
                    // tslint:disable-next-line:component-selector
                    selector: 'ns-empty-outlet',
                    template: "<page-router-outlet isEmptyOutlet='true'></page-router-outlet>",
                }]
        }], ctorParameters: function () { return [{ type: i1.Page }]; }, propDecorators: { pageRouterOutlet: [{
                type: ViewChild,
                args: [PageRouterOutlet, { read: PageRouterOutlet, static: false }]
            }] } });

function provideLocationStrategy(locationStrategy, frameService, startPath) {
    return locationStrategy ? locationStrategy : new NSLocationStrategy(frameService, startPath);
}
class NativeScriptRouterModule {
    static forRoot(routes, config) {
        return {
            ngModule: NativeScriptRouterModule,
            providers: [
                ...RouterModule.forRoot(routes, config).providers,
                {
                    provide: NSLocationStrategy,
                    useFactory: provideLocationStrategy,
                    deps: [[NSLocationStrategy, new Optional(), new SkipSelf()], FrameService, [new Optional(), START_PATH]],
                },
                { provide: LocationStrategy, useExisting: NSLocationStrategy },
                NativescriptPlatformLocation,
                { provide: PlatformLocation, useExisting: NativescriptPlatformLocation },
                RouterExtensions,
                NSRouteReuseStrategy,
                { provide: RouteReuseStrategy, useExisting: NSRouteReuseStrategy },
            ],
        };
    }
    static forChild(routes) {
        return { ngModule: NativeScriptRouterModule, providers: RouterModule.forChild(routes).providers };
    }
}
NativeScriptRouterModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NativeScriptRouterModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NativeScriptRouterModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.2.3", ngImport: i0, type: NativeScriptRouterModule, declarations: [NSRouterLink, NSRouterLinkActive, PageRouterOutlet, NSEmptyOutletComponent], imports: [RouterModule, NativeScriptCommonModule], exports: [RouterModule, NSRouterLink, NSRouterLinkActive, PageRouterOutlet, NSEmptyOutletComponent] });
NativeScriptRouterModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NativeScriptRouterModule, imports: [RouterModule, NativeScriptCommonModule, RouterModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: NativeScriptRouterModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NSRouterLink, NSRouterLinkActive, PageRouterOutlet, NSEmptyOutletComponent],
                    imports: [RouterModule, NativeScriptCommonModule],
                    exports: [RouterModule, NSRouterLink, NSRouterLinkActive, PageRouterOutlet, NSEmptyOutletComponent],
                    schemas: [NO_ERRORS_SCHEMA],
                }]
        }] });

/* eslint-disable @typescript-eslint/ban-types */
let currentRafId = 1;
function noop() { }
/**
 * An injectable service for executing work inside or outside of the Angular zone.
 *
 * The most common use of this service is to optimize performance when starting a work consisting of
 * one or more asynchronous tasks that don't require UI updates or error handling to be handled by
 * Angular. Such tasks can be kicked off via {@link #runOutsideAngular} and if needed, these tasks
 * can reenter the Angular zone via {@link #run}.
 *
 * <!-- TODO: add/fix links to:
 *   - docs explaining zones and the use of zones in Angular and change-detection
 *   - link to runOutsideAngular/run (throughout this file!)
 *   -->
 *
 * @usageNotes
 * ### Example
 *
 * ```
 * import {Component, NgZone} from '@angular/core';
 * import {NgIf} from '@angular/common';
 *
 * @Component({
 *   selector: 'ng-zone-demo',
 *   template: `
 *     <h2>Demo: NgZone</h2>
 *
 *     <p>Progress: {{progress}}%</p>
 *     <p *ngIf="progress >= 100">Done processing {{label}} of Angular zone!</p>
 *
 *     <button (click)="processWithinAngularZone()">Process within Angular zone</button>
 *     <button (click)="processOutsideOfAngularZone()">Process outside of Angular zone</button>
 *   `,
 * })
 * export class NgZoneDemo {
 *   progress: number = 0;
 *   label: string;
 *
 *   constructor(private _ngZone: NgZone) {}
 *
 *   // Loop inside the Angular zone
 *   // so the UI DOES refresh after each setTimeout cycle
 *   processWithinAngularZone() {
 *     this.label = 'inside';
 *     this.progress = 0;
 *     this._increaseProgress(() => console.log('Inside Done!'));
 *   }
 *
 *   // Loop outside of the Angular zone
 *   // so the UI DOES NOT refresh after each setTimeout cycle
 *   processOutsideOfAngularZone() {
 *     this.label = 'outside';
 *     this.progress = 0;
 *     this._ngZone.runOutsideAngular(() => {
 *       this._increaseProgress(() => {
 *         // reenter the Angular zone and display done
 *         this._ngZone.run(() => { console.log('Outside Done!'); });
 *       });
 *     });
 *   }
 *
 *   _increaseProgress(doneCallback: () => void) {
 *     this.progress += 1;
 *     console.log(`Current progress: ${this.progress}%`);
 *
 *     if (this.progress < 100) {
 *       window.setTimeout(() => this._increaseProgress(doneCallback), 10);
 *     } else {
 *       doneCallback();
 *     }
 *   }
 * }
 * ```
 *
 * @publicApi
 */
class NativeScriptNgZone {
    constructor({ enableLongStackTrace = isDevMode(), shouldCoalesceEventChangeDetection = true, shouldCoalesceRunChangeDetection = true } = {}) {
        this.hasPendingMacrotasks = false;
        this.hasPendingMicrotasks = false;
        /**
         * Whether there are no outstanding microtasks or macrotasks.
         */
        this.isStable = true;
        /**
         * Notifies when code enters Angular Zone. This gets fired first on VM Turn.
         */
        this.onUnstable = new EventEmitter(false);
        /**
         * Notifies when there is no more microtasks enqueued in the current VM Turn.
         * This is a hint for Angular to do change detection, which may enqueue more microtasks.
         * For this reason this event can fire multiple times per VM Turn.
         */
        this.onMicrotaskEmpty = new EventEmitter(false);
        /**
         * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which
         * implies we are about to relinquish VM turn.
         * This event gets called just once.
         */
        this.onStable = new EventEmitter(false);
        /**
         * Notifies that an error has been delivered.
         */
        this.onError = new EventEmitter(false);
        if (typeof Zone == 'undefined') {
            throw new Error(`In this configuration Angular requires Zone.js`);
        }
        Zone.assertZonePatched();
        const self = this;
        self._nesting = 0;
        self._outer = self._inner = Zone.current;
        if (Zone['TaskTrackingZoneSpec']) {
            self._inner = self._inner.fork(new Zone['TaskTrackingZoneSpec']());
        }
        if (enableLongStackTrace && Zone['longStackTraceZoneSpec']) {
            self._inner = self._inner.fork(Zone['longStackTraceZoneSpec']);
        }
        // if shouldCoalesceRunChangeDetection is true, all tasks including event tasks will be
        // coalesced, so shouldCoalesceEventChangeDetection option is not necessary and can be skipped.
        self.shouldCoalesceEventChangeDetection = !shouldCoalesceRunChangeDetection && shouldCoalesceEventChangeDetection;
        self.shouldCoalesceRunChangeDetection = shouldCoalesceRunChangeDetection;
        self.lastRequestAnimationFrameId = -1;
        self.nativeRequestAnimationFrame = function (cb) {
            const nativeDispatchToMainThread = Utils[Zone.__symbol__('dispatchToMainThread')] || Utils.dispatchToMainThread;
            nativeDispatchToMainThread(cb);
            return currentRafId++;
        };
        forkInnerZoneWithAngularBehavior(self);
    }
    static isInAngularZone() {
        return Zone.current.get('isAngularZone') === true;
    }
    static assertInAngularZone() {
        if (!NgZone.isInAngularZone()) {
            throw new Error('Expected to be in Angular Zone, but it is not!');
        }
    }
    static assertNotInAngularZone() {
        if (NgZone.isInAngularZone()) {
            throw new Error('Expected to not be in Angular Zone, but it is!');
        }
    }
    /**
     * Executes the `fn` function synchronously within the Angular zone and returns value returned by
     * the function.
     *
     * Running functions via `run` allows you to reenter Angular zone from a task that was executed
     * outside of the Angular zone (typically started via {@link #runOutsideAngular}).
     *
     * Any future tasks or microtasks scheduled from within this function will continue executing from
     * within the Angular zone.
     *
     * If a synchronous error happens it will be rethrown and not reported via `onError`.
     */
    run(fn, applyThis, applyArgs) {
        return this._inner.run(fn, applyThis, applyArgs);
    }
    /**
     * Executes the `fn` function synchronously within the Angular zone as a task and returns value
     * returned by the function.
     *
     * Running functions via `run` allows you to reenter Angular zone from a task that was executed
     * outside of the Angular zone (typically started via {@link #runOutsideAngular}).
     *
     * Any future tasks or microtasks scheduled from within this function will continue executing from
     * within the Angular zone.
     *
     * If a synchronous error happens it will be rethrown and not reported via `onError`.
     */
    runTask(fn, applyThis, applyArgs, name) {
        const zone = this._inner;
        const task = zone.scheduleEventTask('NgZoneEvent: ' + name, fn, EMPTY_PAYLOAD, noop, noop);
        try {
            return zone.runTask(task, applyThis, applyArgs);
        }
        finally {
            zone.cancelTask(task);
        }
    }
    /**
     * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not
     * rethrown.
     */
    runGuarded(fn, applyThis, applyArgs) {
        return this._inner.runGuarded(fn, applyThis, applyArgs);
    }
    /**
     * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by
     * the function.
     *
     * Running functions via {@link #runOutsideAngular} allows you to escape Angular's zone and do
     * work that
     * doesn't trigger Angular change-detection or is subject to Angular's error handling.
     *
     * Any future tasks or microtasks scheduled from within this function will continue executing from
     * outside of the Angular zone.
     *
     * Use {@link #run} to reenter the Angular zone and do work that updates the application model.
     */
    runOutsideAngular(fn) {
        return this._outer.run(fn);
    }
}
const EMPTY_PAYLOAD = {};
function checkStable(zone) {
    // TODO: @JiaLiPassion, should check zone.isCheckStableRunning to prevent
    // re-entry. The case is:
    //
    // @Component({...})
    // export class AppComponent {
    // constructor(private ngZone: NgZone) {
    //   this.ngZone.onStable.subscribe(() => {
    //     this.ngZone.run(() => console.log('stable'););
    //   });
    // }
    //
    // The onStable subscriber run another function inside ngZone
    // which causes `checkStable()` re-entry.
    // But this fix causes some issues in g3, so this fix will be
    // launched in another PR.
    if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {
        try {
            zone._nesting++;
            zone.onMicrotaskEmpty.emit(null);
        }
        finally {
            zone._nesting--;
            if (!zone.hasPendingMicrotasks) {
                try {
                    zone.runOutsideAngular(() => zone.onStable.emit(null));
                }
                finally {
                    zone.isStable = true;
                }
            }
        }
    }
}
function delayChangeDetectionForEvents(zone) {
    /**
     * We also need to check _nesting here
     * Consider the following case with shouldCoalesceRunChangeDetection = true
     *
     * ngZone.run(() => {});
     * ngZone.run(() => {});
     *
     * We want the two `ngZone.run()` only trigger one change detection
     * when shouldCoalesceRunChangeDetection is true.
     * And because in this case, change detection run in async way(requestAnimationFrame),
     * so we also need to check the _nesting here to prevent multiple
     * change detections.
     */
    if (zone.isCheckStableRunning || zone.lastRequestAnimationFrameId !== -1) {
        return;
    }
    zone.lastRequestAnimationFrameId = zone.nativeRequestAnimationFrame.call(global, () => {
        // This is a work around for https://github.com/angular/angular/issues/36839.
        // The core issue is that when event coalescing is enabled it is possible for microtasks
        // to get flushed too early (As is the case with `Promise.then`) between the
        // coalescing eventTasks.
        //
        // To workaround this we schedule a "fake" eventTask before we process the
        // coalescing eventTasks. The benefit of this is that the "fake" container eventTask
        //  will prevent the microtasks queue from getting drained in between the coalescing
        // eventTask execution.
        if (!zone.fakeTopEventTask) {
            zone.fakeTopEventTask = Zone.root.scheduleEventTask('fakeTopEventTask', () => {
                zone.lastRequestAnimationFrameId = -1;
                updateMicroTaskStatus(zone);
                zone.isCheckStableRunning = true;
                checkStable(zone);
                zone.isCheckStableRunning = false;
            }, undefined, () => { }, () => { });
        }
        zone.fakeTopEventTask.invoke();
    });
    updateMicroTaskStatus(zone);
}
function forkInnerZoneWithAngularBehavior(zone) {
    const delayChangeDetectionForEventsDelegate = () => {
        delayChangeDetectionForEvents(zone);
    };
    zone._inner = zone._inner.fork({
        name: 'angular',
        properties: { isAngularZone: true },
        onInvokeTask: (delegate, current, target, task, applyThis, applyArgs) => {
            try {
                onEnter(zone);
                return delegate.invokeTask(target, task, applyThis, applyArgs);
            }
            finally {
                if ((zone.shouldCoalesceEventChangeDetection && task.type === 'eventTask') || zone.shouldCoalesceRunChangeDetection || !Utils.isMainThread()) {
                    delayChangeDetectionForEventsDelegate();
                }
                onLeave(zone);
            }
        },
        onInvoke: (delegate, current, target, callback, applyThis, applyArgs, source) => {
            try {
                onEnter(zone);
                return delegate.invoke(target, callback, applyThis, applyArgs, source);
            }
            finally {
                if (zone.shouldCoalesceRunChangeDetection || !Utils.isMainThread()) {
                    delayChangeDetectionForEventsDelegate();
                }
                onLeave(zone);
            }
        },
        onHasTask: (delegate, current, target, hasTaskState) => {
            delegate.hasTask(target, hasTaskState);
            if (current === target) {
                // We are only interested in hasTask events which originate from our zone
                // (A child hasTask event is not interesting to us)
                if (hasTaskState.change == 'microTask') {
                    zone._hasPendingMicrotasks = hasTaskState.microTask;
                    updateMicroTaskStatus(zone);
                    checkStable(zone);
                }
                else if (hasTaskState.change == 'macroTask') {
                    zone.hasPendingMacrotasks = hasTaskState.macroTask;
                }
            }
        },
        onHandleError: (delegate, current, target, error) => {
            delegate.handleError(target, error);
            zone.runOutsideAngular(() => zone.onError.emit(error));
            return false;
        },
    });
}
function updateMicroTaskStatus(zone) {
    if (zone._hasPendingMicrotasks || zone.lastRequestAnimationFrameId !== -1) {
        zone.hasPendingMicrotasks = true;
    }
    else {
        zone.hasPendingMicrotasks = false;
    }
}
function onEnter(zone) {
    zone._nesting++;
    if (zone.isStable) {
        zone.isStable = false;
        zone.onUnstable.emit(null);
    }
}
function onLeave(zone) {
    zone._nesting--;
    checkStable(zone);
}

/**
 * Generated bundle index. Do not edit.
 */

export { APP_ROOT_VIEW, ActionBarComponent, ActionBarScope, ActionItemDirective, AndroidFilterComponent, AppHostAsyncView, AppHostView, BasePortalOutlet, BaseValueAccessor, COMMON_PROVIDERS, CdkPortal, CdkPortalOutlet, CheckedValueAccessor, CommentNode, ComponentPortal, DEVICE, DISABLE_ROOT_VIEW_HANDLING, DateValueAccessor, DetachedLoader, DomPortal, ENABLE_REUSABE_VIEWS, EmulatedRenderer, FrameDirective, FramePageComponent, FramePageModule, FrameService, IOSFilterComponent, InjectableAnimationEngine, InvisibleNode, ItemContext, ListViewComponent, ModalDialogParams, ModalDialogService, NAMESPACE_FILTERS, NATIVESCRIPT_MODULE_PROVIDERS, NATIVESCRIPT_MODULE_STATIC_PROVIDERS, NATIVESCRIPT_ROOT_MODULE_ID, NATIVE_DIALOG_DATA, NATIVE_DIALOG_DEFAULT_OPTIONS, NSEmptyOutletComponent, NSFileSystem, NSLocationStrategy, NSRouteReuseStrategy, NSRouterLink, NSRouterLinkActive, NativeDialogCloseDirective, NativeDialogConfig, NativeDialogModule, NativeDialogRef, NativeDialogService, NativeModalRef, NativeScriptAnimationDriver, NativeScriptAnimationPlayer, NativeScriptAnimationsModule, NativeScriptCommonModule, NativeScriptDocument, NativeScriptDomPortalOutlet, NativeScriptFormsModule, NativeScriptHttpClientModule, NativeScriptLoadingService, NativeScriptModule, NativeScriptNgSafeEvent, NativeScriptNgZone, NativeScriptRendererFactory, NativeScriptRouterModule, NativeScriptSanitizer, NativescriptXhrFactory, NavigationButtonDirective, NgViewRef, NsHttpBackEnd, NsTemplatedItem, NumberValueAccessor, Outlet, PAGE_FACTORY, PageDirective, PageRoute, PageRouterOutlet, PageService, PlatformNamespaceFilter, Portal, PortalModule, RootCompositeModule, RootViewProxy, RouterExtensions, START_PATH, SelectedIndexValueAccessor, TEMPLATED_ITEMS_COMPONENT, TabViewDirective, TabViewItemDirective, TemplateKeyDirective, TemplatePortal, TextNode, TextValueAccessor, TimeValueAccessor, _NativeDialogBase, createKeyframeAnimation, customFrameComponentFactory, customFrameDirectiveFactory, customPageFactory, customPageFactoryFromFrame, dashCaseToCamelCase, defaultNavOptions, defaultPageFactory, defaultPageFactoryProvider, detachViewFromParent, disableRootViewHanding, errorHandler, extractSingleViewRecursive, frameMeta, generateDetachedLoader, generateFallbackRootView, generateNativeScriptView, generateRandomId, generateRootLayoutAndProxy, getFirstNativeLikeView, getItemViewRoot, getSingleViewRecursive, getViewClass, getViewMeta, instantiateDefaultStyleNormalizer, instantiateRendererFactory, instantiateSupportedAnimationDriver, isBlank, isContentView, isDetachedElement, isInvisibleNode, isKnownView, isLayout, isPresent, isView, onAfterLivesync, onBeforeLivesync, once, platformNativeScript, platformNativeScriptDynamic, postAngularBootstrap$, preAngularDisposal$, provideLocationStrategy, registerElement, registerNativeScriptViewComponents, runNativeScriptAngularApp, throwIfAlreadyLoaded, throwNoPortalAttachedError, throwNullPortalError, throwNullPortalOutletError, throwPortalAlreadyAttachedError, throwPortalOutletAlreadyDisposedError, throwUnknownPortalTypeError, COMPONENT_VARIABLE as ɵCOMPONENT_VARIABLE, CONTENT_ATTR as ɵCONTENT_ATTR, HOST_ATTR as ɵHOST_ATTR, NativeScriptDebug as ɵNativeScriptAngularDebug, viewUtil as ɵViewUtil, actionBarMeta as ɵactionBarMeta, elementMap as ɵelementMap, isActionItem as ɵisActionItem, isNavigationButton as ɵisNavigationButton };
//# sourceMappingURL=nativescript-angular.mjs.map
