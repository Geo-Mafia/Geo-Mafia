import { ApplicationRef, ComponentFactoryResolver, Injectable, Injector, NgZone, ɵdetectChanges as detectChanges } from '@angular/core';
import { Application, ContentView, Frame } from '@nativescript/core';
import { Subject } from 'rxjs';
import { AppHostAsyncView, AppHostView } from '../../app-host-view';
import { ComponentPortal } from '../../cdk/portal/common';
import { NativeScriptDomPortalOutlet } from '../../cdk/portal/nsdom-portal-outlet';
import { once } from '../../utils/general';
import { NgViewRef } from '../../view-refs';
import { NSLocationStrategy } from '../router/ns-location-strategy';
import * as i0 from "@angular/core";
import * as i1 from "../router/ns-location-strategy";
export class ModalDialogParams {
    constructor(context = {}, closeCallback) {
        this.context = context;
        this.closeCallback = closeCallback;
    }
}
export class ModalDialogService {
    constructor(location, zone, appRef, defaultInjector) {
        this.location = location;
        this.zone = zone;
        this.appRef = appRef;
        this.defaultInjector = defaultInjector;
    }
    /**
     * Emits anytime a modal is closed with the ModalDialogParams which were injected into the component which is now closing.
     * For example, can be used to wire up Rx flows outside the scope of just the component being handled.
     */
    get closed$() {
        if (!this._closed$) {
            this._closed$ = new Subject();
        }
        return this._closed$;
    }
    showModal(type, options = {}) {
        // if (!options.viewContainerRef) {
        //   throw new Error('No viewContainerRef: ' + 'Make sure you pass viewContainerRef in ModalDialogOptions.');
        // }
        let parentView = options.viewContainerRef?.element.nativeElement || Application.getRootView();
        if (options.target) {
            parentView = options.target;
        }
        if ((parentView instanceof AppHostView || parentView instanceof AppHostAsyncView) && parentView.ngAppRoot) {
            parentView = parentView.ngAppRoot;
        }
        // _ngDialogRoot is the first child of the previously detached proxy.
        // It should have 'viewController' (iOS) or '_dialogFragment' (Android) available for
        // presenting future modal views.
        if (parentView._ngDialogRoot) {
            parentView = parentView._ngDialogRoot;
        }
        // resolve from particular module (moduleRef)
        // or from same module as parentView (viewContainerRef)
        const componentInjector = options.moduleRef?.injector || options.viewContainerRef?.injector || this.defaultInjector;
        const resolver = componentInjector.get(ComponentFactoryResolver);
        let frame = parentView;
        if (!(parentView instanceof Frame)) {
            frame = (parentView.page && parentView.page.frame) || Frame.topmost();
        }
        this.location?._beginModalNavigation(frame);
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                try {
                    this._showDialog({
                        ...options,
                        containerRef: options.viewContainerRef,
                        injector: componentInjector,
                        context: options.context,
                        doneCallback: resolve,
                        parentView,
                        resolver,
                        type,
                    });
                }
                catch (err) {
                    reject(err);
                }
            }, 10);
        });
    }
    _showDialog(options) {
        let componentViewRef;
        let detachedLoaderRef;
        let portalOutlet;
        const closeCallback = once(async (...args) => {
            options.doneCallback.apply(undefined, args);
            if (componentViewRef) {
                componentViewRef.firstNativeLikeView.closeModal();
                const params = this.openedModalParams.pop();
                if (this._closed$) {
                    this._closed$.next(params);
                }
                await this.location._closeModalNavigation();
                if (detachedLoaderRef || portalOutlet) {
                    this.zone.run(() => {
                        portalOutlet?.dispose();
                        detachedLoaderRef?.instance.detectChanges();
                        detachedLoaderRef?.destroy();
                    });
                }
            }
        });
        const modalParams = new ModalDialogParams(options.context, closeCallback);
        if (!this.openedModalParams) {
            this.openedModalParams = [];
        }
        this.openedModalParams.push(modalParams);
        const childInjector = Injector.create({
            providers: [{ provide: ModalDialogParams, useValue: modalParams }],
            parent: options.injector,
        });
        this.zone.run(() => {
            // if we ever support templates in the old API
            // if(options.templateRef) {
            //     const detachedFactory = options.resolver.resolveComponentFactory(DetachedLoader);
            //     if(options.attachToContainerRef) {
            //         detachedLoaderRef = options.attachToContainerRef.createComponent(detachedFactory, 0, childInjector, null);
            //     } else {
            //         detachedLoaderRef = detachedFactory.create(childInjector); // this DetachedLoader is **completely** detached
            //         this.appRef.attachView(detachedLoaderRef.hostView); // we attach it to the applicationRef, so it becomes a "root" view in angular's hierarchy
            //     }
            //     detachedLoaderRef.changeDetectorRef.detectChanges(); // force a change detection
            //     detachedLoaderRef.instance.createTemplatePortal(options.templateRef);
            // }
            const targetView = new ContentView();
            const portal = new ComponentPortal(options.type);
            portalOutlet = new NativeScriptDomPortalOutlet(targetView, options.resolver, this.appRef, childInjector);
            const componentRef = portalOutlet.attach(portal);
            detectChanges(componentRef.instance);
            componentViewRef = new NgViewRef(componentRef);
            if (options.useContextAsComponentProps && options.context) {
                for (const key in options.context) {
                    componentViewRef.ref.instance[key] = options.context[key];
                }
            }
            if (componentViewRef !== componentRef.location.nativeElement) {
                componentRef.location.nativeElement._ngDialogRoot = componentViewRef.firstNativeLikeView;
            }
            // if we don't detach the view from its parent, ios gets mad
            componentViewRef.detachNativeLikeView();
            options.parentView.showModal(componentViewRef.firstNativeLikeView, { ...options, closeCallback });
        });
    }
}
ModalDialogService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: ModalDialogService, deps: [{ token: i1.NSLocationStrategy }, { token: i0.NgZone }, { token: i0.ApplicationRef }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });
ModalDialogService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: ModalDialogService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: ModalDialogService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.NSLocationStrategy }, { type: i0.NgZone }, { type: i0.ApplicationRef }, { type: i0.Injector }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGlhbG9ncy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL2FuZ3VsYXIvc3JjL2xpYi9sZWdhY3kvZGlyZWN0aXZlcy9kaWFsb2dzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxjQUFjLEVBQUUsd0JBQXdCLEVBQWdCLFVBQVUsRUFBRSxRQUFRLEVBQWUsTUFBTSxFQUEwQixjQUFjLElBQUksYUFBYSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNMLE9BQU8sRUFBRSxXQUFXLEVBQUUsV0FBVyxFQUFFLEtBQUssRUFBb0MsTUFBTSxvQkFBb0IsQ0FBQztBQUN2RyxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQy9CLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxXQUFXLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUVwRSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDMUQsT0FBTyxFQUFFLDJCQUEyQixFQUFFLE1BQU0sc0NBQXNDLENBQUM7QUFDbkYsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQzNDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUM1QyxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQzs7O0FBK0JwRSxNQUFNLE9BQU8saUJBQWlCO0lBQzVCLFlBQW1CLFVBQWUsRUFBRSxFQUFTLGFBQStCO1FBQXpELFlBQU8sR0FBUCxPQUFPLENBQVU7UUFBUyxrQkFBYSxHQUFiLGFBQWEsQ0FBa0I7SUFBRyxDQUFDO0NBQ2pGO0FBR0QsTUFBTSxPQUFPLGtCQUFrQjtJQVM3QixZQUFvQixRQUE0QixFQUFVLElBQVksRUFBVSxNQUFzQixFQUFVLGVBQXlCO1FBQXJILGFBQVEsR0FBUixRQUFRLENBQW9CO1FBQVUsU0FBSSxHQUFKLElBQUksQ0FBUTtRQUFV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T0FBTyxFQUFFLGFBQWEsRUFBRSxDQUFDLENBQUM7UUFDcEcsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDOzsrR0E1SVUsa0JBQWtCO21IQUFsQixrQkFBa0I7MkZBQWxCLGtCQUFrQjtrQkFEOUIsVUFBVSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFwcGxpY2F0aW9uUmVmLCBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIENvbXBvbmVudFJlZiwgSW5qZWN0YWJsZSwgSW5qZWN0b3IsIE5nTW9kdWxlUmVmLCBOZ1pvbmUsIFR5cGUsIFZpZXdDb250YWluZXJSZWYsIMm1ZGV0ZWN0Q2hhbmdlcyBhcyBkZXRlY3RDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBcHBsaWNhdGlvbiwgQ29udGVudFZpZXcsIEZyYW1lLCBTaG93TW9kYWxPcHRpb25zLCBWaWV3LCBWaWV3QmFzZSB9IGZyb20gJ0BuYXRpdmVzY3JpcHQvY29yZSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBBcHBIb3N0QXN5bmNWaWV3LCBBcHBIb3N0VmlldyB9IGZyb20gJy4uLy4uL2FwcC1ob3N0LXZpZXcnO1xuaW1wb3J0IHsgRGV0YWNoZWRMb2FkZXIgfSBmcm9tICcuLi8uLi9jZGsvZGV0YWNoZWQtbG9hZGVyJztcbmltcG9ydCB7IENvbXBvbmVudFBvcnRhbCB9IGZyb20gJy4uLy4uL2Nkay9wb3J0YWwvY29tbW9uJztcbmltcG9ydCB7IE5hdGl2ZVNjcmlwdERvbVBvcnRhbE91dGxldCB9IGZyb20gJy4uLy4uL2Nkay9wb3J0YWwvbnNkb20tcG9ydGFsLW91dGxldCc7XG5pbXBvcnQgeyBvbmNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvZ2VuZXJhbCc7XG5pbXBvcnQgeyBOZ1ZpZXdSZWYgfSBmcm9tICcuLi8uLi92aWV3LXJlZnMnO1xuaW1wb3J0IHsgTlNMb2NhdGlvblN0cmF0ZWd5IH0gZnJvbSAnLi4vcm91dGVyL25zLWxvY2F0aW9uLXN0cmF0ZWd5JztcblxuZXhwb3J0IHR5cGUgQmFzZVNob3dNb2RhbE9wdGlvbnMgPSBQaWNrPFNob3dNb2RhbE9wdGlvbnMsIEV4Y2x1ZGU8a2V5b2YgU2hvd01vZGFsT3B0aW9ucywgJ2Nsb3NlQ2FsbGJhY2snIHwgJ2NvbnRleHQnPj47XG5cbmV4cG9ydCBpbnRlcmZhY2UgTW9kYWxEaWFsb2dPcHRpb25zIGV4dGVuZHMgQmFzZVNob3dNb2RhbE9wdGlvbnMge1xuICBjb250ZXh0PzogYW55O1xuICB2aWV3Q29udGFpbmVyUmVmPzogVmlld0NvbnRhaW5lclJlZjtcbiAgbW9kdWxlUmVmPzogTmdNb2R1bGVSZWY8YW55PjtcbiAgdGFyZ2V0PzogVmlldztcbiAgLyoqXG4gICAqIFVzZSBjb250ZXh0IGRhdGEgYXMgY29tcG9uZW50IGluc3RhbmNlIHByb3BlcnRpZXNcbiAgICovXG4gIHVzZUNvbnRleHRBc0NvbXBvbmVudFByb3BzPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTaG93RGlhbG9nT3B0aW9ucyBleHRlbmRzIE1vZGFsRGlhbG9nT3B0aW9ucyB7XG4gIGNvbnRhaW5lclJlZj86IFZpZXdDb250YWluZXJSZWY7XG4gIC8qKlxuICAgKiB3aGljaCBjb250YWluZXIgdG8gYXR0YWNoIHRoZSBjaGFuZ2UgZGV0ZWN0aW9uXG4gICAqIGlmIG5vdCBzcGVjaWZpZWQsIGF0dGFjaGVzIHRvIHRoZSBBcHBsaWNhdGlvblJlZiAocmVjb21tZW5kZWQpXG4gICAqL1xuICBhdHRhY2hUb0NvbnRhaW5lclJlZj86IFZpZXdDb250YWluZXJSZWY7XG4gIGluamVjdG9yOiBJbmplY3RvcjtcbiAgY29udGV4dDogYW55O1xuICBkb25lQ2FsbGJhY2s7XG4gIHBhZ2VGYWN0b3J5PzogYW55O1xuICBwYXJlbnRWaWV3OiBWaWV3QmFzZTtcbiAgcmVzb2x2ZXI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjtcbiAgdHlwZTogVHlwZTxhbnk+O1xufVxuXG5leHBvcnQgY2xhc3MgTW9kYWxEaWFsb2dQYXJhbXMge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgY29udGV4dDogYW55ID0ge30sIHB1YmxpYyBjbG9zZUNhbGxiYWNrOiAoLi4uYXJncykgPT4gYW55KSB7fVxufVxuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTW9kYWxEaWFsb2dTZXJ2aWNlIHtcbiAgLyoqXG4gICAqIEFueSBvcGVuZWQgTW9kYWxEaWFsb2dQYXJhbXMgaW4gb3JkZXIgb2Ygd2hlbiB0aGV5IHdlcmUgb3BlbmVkIChNb3N0IHJlY2VudCBvbiB0b3ApLlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHdoZW4geW91IG5lZWQgYWNjZXNzIHRvIE1vZGFsRGlhbG9nUGFyYW1zIG91dHNpZGUgb2YgdGhlIGNvbXBvbmVudCB3aGljaCBoYWQgdGhlbSBpbmplY3RlZC5cbiAgICogRWFjaCBpcyBwb3BwZWQgb2ZmIGFzIG1vZGFscyBhcmUgY2xvc2VkLlxuICAgKi9cbiAgb3BlbmVkTW9kYWxQYXJhbXM6IEFycmF5PE1vZGFsRGlhbG9nUGFyYW1zPjtcbiAgX2Nsb3NlZCQ6IFN1YmplY3Q8TW9kYWxEaWFsb2dQYXJhbXM+O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgbG9jYXRpb246IE5TTG9jYXRpb25TdHJhdGVneSwgcHJpdmF0ZSB6b25lOiBOZ1pvbmUsIHByaXZhdGUgYXBwUmVmOiBBcHBsaWNhdGlvblJlZiwgcHJpdmF0ZSBkZWZhdWx0SW5qZWN0b3I6IEluamVjdG9yKSB7fVxuXG4gIC8qKlxuICAgKiBFbWl0cyBhbnl0aW1lIGEgbW9kYWwgaXMgY2xvc2VkIHdpdGggdGhlIE1vZGFsRGlhbG9nUGFyYW1zIHdoaWNoIHdlcmUgaW5qZWN0ZWQgaW50byB0aGUgY29tcG9uZW50IHdoaWNoIGlzIG5vdyBjbG9zaW5nLlxuICAgKiBGb3IgZXhhbXBsZSwgY2FuIGJlIHVzZWQgdG8gd2lyZSB1cCBSeCBmbG93cyBvdXRzaWRlIHRoZSBzY29wZSBvZiBqdXN0IHRoZSBjb21wb25lbnQgYmVpbmcgaGFuZGxlZC5cbiAgICovXG4gIGdldCBjbG9zZWQkKCkge1xuICAgIGlmICghdGhpcy5fY2xvc2VkJCkge1xuICAgICAgdGhpcy5fY2xvc2VkJCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jbG9zZWQkO1xuICB9XG5cbiAgcHVibGljIHNob3dNb2RhbCh0eXBlOiBUeXBlPGFueT4sIG9wdGlvbnM6IE1vZGFsRGlhbG9nT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICAvLyBpZiAoIW9wdGlvbnMudmlld0NvbnRhaW5lclJlZikge1xuICAgIC8vICAgdGhyb3cgbmV3IEVycm9yKCdObyB2aWV3Q29udGFpbmVyUmVmOiAnICsgJ01ha2Ugc3VyZSB5b3UgcGFzcyB2aWV3Q29udGFpbmVyUmVmIGluIE1vZGFsRGlhbG9nT3B0aW9ucy4nKTtcbiAgICAvLyB9XG5cbiAgICBsZXQgcGFyZW50VmlldyA9IG9wdGlvbnMudmlld0NvbnRhaW5lclJlZj8uZWxlbWVudC5uYXRpdmVFbGVtZW50IHx8IEFwcGxpY2F0aW9uLmdldFJvb3RWaWV3KCk7XG4gICAgaWYgKG9wdGlvbnMudGFyZ2V0KSB7XG4gICAgICBwYXJlbnRWaWV3ID0gb3B0aW9ucy50YXJnZXQ7XG4gICAgfVxuXG4gICAgaWYgKChwYXJlbnRWaWV3IGluc3RhbmNlb2YgQXBwSG9zdFZpZXcgfHwgcGFyZW50VmlldyBpbnN0YW5jZW9mIEFwcEhvc3RBc3luY1ZpZXcpICYmIHBhcmVudFZpZXcubmdBcHBSb290KSB7XG4gICAgICBwYXJlbnRWaWV3ID0gcGFyZW50Vmlldy5uZ0FwcFJvb3Q7XG4gICAgfVxuXG4gICAgLy8gX25nRGlhbG9nUm9vdCBpcyB0aGUgZmlyc3QgY2hpbGQgb2YgdGhlIHByZXZpb3VzbHkgZGV0YWNoZWQgcHJveHkuXG4gICAgLy8gSXQgc2hvdWxkIGhhdmUgJ3ZpZXdDb250cm9sbGVyJyAoaU9TKSBvciAnX2RpYWxvZ0ZyYWdtZW50JyAoQW5kcm9pZCkgYXZhaWxhYmxlIGZvclxuICAgIC8vIHByZXNlbnRpbmcgZnV0dXJlIG1vZGFsIHZpZXdzLlxuICAgIGlmIChwYXJlbnRWaWV3Ll9uZ0RpYWxvZ1Jvb3QpIHtcbiAgICAgIHBhcmVudFZpZXcgPSBwYXJlbnRWaWV3Ll9uZ0RpYWxvZ1Jvb3Q7XG4gICAgfVxuXG4gICAgLy8gcmVzb2x2ZSBmcm9tIHBhcnRpY3VsYXIgbW9kdWxlIChtb2R1bGVSZWYpXG4gICAgLy8gb3IgZnJvbSBzYW1lIG1vZHVsZSBhcyBwYXJlbnRWaWV3ICh2aWV3Q29udGFpbmVyUmVmKVxuICAgIGNvbnN0IGNvbXBvbmVudEluamVjdG9yID0gb3B0aW9ucy5tb2R1bGVSZWY/LmluamVjdG9yIHx8IG9wdGlvbnMudmlld0NvbnRhaW5lclJlZj8uaW5qZWN0b3IgfHwgdGhpcy5kZWZhdWx0SW5qZWN0b3I7XG4gICAgY29uc3QgcmVzb2x2ZXIgPSBjb21wb25lbnRJbmplY3Rvci5nZXQoQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyKTtcblxuICAgIGxldCBmcmFtZSA9IHBhcmVudFZpZXc7XG4gICAgaWYgKCEocGFyZW50VmlldyBpbnN0YW5jZW9mIEZyYW1lKSkge1xuICAgICAgZnJhbWUgPSAocGFyZW50Vmlldy5wYWdlICYmIHBhcmVudFZpZXcucGFnZS5mcmFtZSkgfHwgRnJhbWUudG9wbW9zdCgpO1xuICAgIH1cblxuICAgIHRoaXMubG9jYXRpb24/Ll9iZWdpbk1vZGFsTmF2aWdhdGlvbihmcmFtZSk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5fc2hvd0RpYWxvZyh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgY29udGFpbmVyUmVmOiBvcHRpb25zLnZpZXdDb250YWluZXJSZWYsXG4gICAgICAgICAgICBpbmplY3RvcjogY29tcG9uZW50SW5qZWN0b3IsXG4gICAgICAgICAgICBjb250ZXh0OiBvcHRpb25zLmNvbnRleHQsXG4gICAgICAgICAgICBkb25lQ2FsbGJhY2s6IHJlc29sdmUsXG4gICAgICAgICAgICBwYXJlbnRWaWV3LFxuICAgICAgICAgICAgcmVzb2x2ZXIsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSwgMTApO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBfc2hvd0RpYWxvZyhvcHRpb25zOiBTaG93RGlhbG9nT3B0aW9ucyk6IHZvaWQge1xuICAgIGxldCBjb21wb25lbnRWaWV3UmVmOiBOZ1ZpZXdSZWY8dW5rbm93bj47XG4gICAgbGV0IGRldGFjaGVkTG9hZGVyUmVmOiBDb21wb25lbnRSZWY8RGV0YWNoZWRMb2FkZXI+O1xuICAgIGxldCBwb3J0YWxPdXRsZXQ6IE5hdGl2ZVNjcmlwdERvbVBvcnRhbE91dGxldDtcblxuICAgIGNvbnN0IGNsb3NlQ2FsbGJhY2sgPSBvbmNlKGFzeW5jICguLi5hcmdzKSA9PiB7XG4gICAgICBvcHRpb25zLmRvbmVDYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgaWYgKGNvbXBvbmVudFZpZXdSZWYpIHtcbiAgICAgICAgY29tcG9uZW50Vmlld1JlZi5maXJzdE5hdGl2ZUxpa2VWaWV3LmNsb3NlTW9kYWwoKTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5vcGVuZWRNb2RhbFBhcmFtcy5wb3AoKTtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCQpIHtcbiAgICAgICAgICB0aGlzLl9jbG9zZWQkLm5leHQocGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLmxvY2F0aW9uLl9jbG9zZU1vZGFsTmF2aWdhdGlvbigpO1xuICAgICAgICBpZiAoZGV0YWNoZWRMb2FkZXJSZWYgfHwgcG9ydGFsT3V0bGV0KSB7XG4gICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICBwb3J0YWxPdXRsZXQ/LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIGRldGFjaGVkTG9hZGVyUmVmPy5pbnN0YW5jZS5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICBkZXRhY2hlZExvYWRlclJlZj8uZGVzdHJveSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBtb2RhbFBhcmFtcyA9IG5ldyBNb2RhbERpYWxvZ1BhcmFtcyhvcHRpb25zLmNvbnRleHQsIGNsb3NlQ2FsbGJhY2spO1xuICAgIGlmICghdGhpcy5vcGVuZWRNb2RhbFBhcmFtcykge1xuICAgICAgdGhpcy5vcGVuZWRNb2RhbFBhcmFtcyA9IFtdO1xuICAgIH1cbiAgICB0aGlzLm9wZW5lZE1vZGFsUGFyYW1zLnB1c2gobW9kYWxQYXJhbXMpO1xuXG4gICAgY29uc3QgY2hpbGRJbmplY3RvciA9IEluamVjdG9yLmNyZWF0ZSh7XG4gICAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IE1vZGFsRGlhbG9nUGFyYW1zLCB1c2VWYWx1ZTogbW9kYWxQYXJhbXMgfV0sXG4gICAgICBwYXJlbnQ6IG9wdGlvbnMuaW5qZWN0b3IsXG4gICAgfSk7XG4gICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XG4gICAgICAvLyBpZiB3ZSBldmVyIHN1cHBvcnQgdGVtcGxhdGVzIGluIHRoZSBvbGQgQVBJXG4gICAgICAvLyBpZihvcHRpb25zLnRlbXBsYXRlUmVmKSB7XG4gICAgICAvLyAgICAgY29uc3QgZGV0YWNoZWRGYWN0b3J5ID0gb3B0aW9ucy5yZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShEZXRhY2hlZExvYWRlcik7XG4gICAgICAvLyAgICAgaWYob3B0aW9ucy5hdHRhY2hUb0NvbnRhaW5lclJlZikge1xuICAgICAgLy8gICAgICAgICBkZXRhY2hlZExvYWRlclJlZiA9IG9wdGlvbnMuYXR0YWNoVG9Db250YWluZXJSZWYuY3JlYXRlQ29tcG9uZW50KGRldGFjaGVkRmFjdG9yeSwgMCwgY2hpbGRJbmplY3RvciwgbnVsbCk7XG4gICAgICAvLyAgICAgfSBlbHNlIHtcbiAgICAgIC8vICAgICAgICAgZGV0YWNoZWRMb2FkZXJSZWYgPSBkZXRhY2hlZEZhY3RvcnkuY3JlYXRlKGNoaWxkSW5qZWN0b3IpOyAvLyB0aGlzIERldGFjaGVkTG9hZGVyIGlzICoqY29tcGxldGVseSoqIGRldGFjaGVkXG4gICAgICAvLyAgICAgICAgIHRoaXMuYXBwUmVmLmF0dGFjaFZpZXcoZGV0YWNoZWRMb2FkZXJSZWYuaG9zdFZpZXcpOyAvLyB3ZSBhdHRhY2ggaXQgdG8gdGhlIGFwcGxpY2F0aW9uUmVmLCBzbyBpdCBiZWNvbWVzIGEgXCJyb290XCIgdmlldyBpbiBhbmd1bGFyJ3MgaGllcmFyY2h5XG4gICAgICAvLyAgICAgfVxuICAgICAgLy8gICAgIGRldGFjaGVkTG9hZGVyUmVmLmNoYW5nZURldGVjdG9yUmVmLmRldGVjdENoYW5nZXMoKTsgLy8gZm9yY2UgYSBjaGFuZ2UgZGV0ZWN0aW9uXG4gICAgICAvLyAgICAgZGV0YWNoZWRMb2FkZXJSZWYuaW5zdGFuY2UuY3JlYXRlVGVtcGxhdGVQb3J0YWwob3B0aW9ucy50ZW1wbGF0ZVJlZik7XG4gICAgICAvLyB9XG4gICAgICBjb25zdCB0YXJnZXRWaWV3ID0gbmV3IENvbnRlbnRWaWV3KCk7XG4gICAgICBjb25zdCBwb3J0YWwgPSBuZXcgQ29tcG9uZW50UG9ydGFsKG9wdGlvbnMudHlwZSk7XG4gICAgICBwb3J0YWxPdXRsZXQgPSBuZXcgTmF0aXZlU2NyaXB0RG9tUG9ydGFsT3V0bGV0KHRhcmdldFZpZXcsIG9wdGlvbnMucmVzb2x2ZXIsIHRoaXMuYXBwUmVmLCBjaGlsZEluamVjdG9yKTtcbiAgICAgIGNvbnN0IGNvbXBvbmVudFJlZiA9IHBvcnRhbE91dGxldC5hdHRhY2gocG9ydGFsKTtcbiAgICAgIGRldGVjdENoYW5nZXMoY29tcG9uZW50UmVmLmluc3RhbmNlKTtcbiAgICAgIGNvbXBvbmVudFZpZXdSZWYgPSBuZXcgTmdWaWV3UmVmKGNvbXBvbmVudFJlZik7XG4gICAgICBpZiAob3B0aW9ucy51c2VDb250ZXh0QXNDb21wb25lbnRQcm9wcyAmJiBvcHRpb25zLmNvbnRleHQpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucy5jb250ZXh0KSB7XG4gICAgICAgICAgKDxDb21wb25lbnRSZWY8YW55Pj5jb21wb25lbnRWaWV3UmVmLnJlZikuaW5zdGFuY2Vba2V5XSA9IG9wdGlvbnMuY29udGV4dFtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY29tcG9uZW50Vmlld1JlZiAhPT0gY29tcG9uZW50UmVmLmxvY2F0aW9uLm5hdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgY29tcG9uZW50UmVmLmxvY2F0aW9uLm5hdGl2ZUVsZW1lbnQuX25nRGlhbG9nUm9vdCA9IGNvbXBvbmVudFZpZXdSZWYuZmlyc3ROYXRpdmVMaWtlVmlldztcbiAgICAgIH1cbiAgICAgIC8vIGlmIHdlIGRvbid0IGRldGFjaCB0aGUgdmlldyBmcm9tIGl0cyBwYXJlbnQsIGlvcyBnZXRzIG1hZFxuICAgICAgY29tcG9uZW50Vmlld1JlZi5kZXRhY2hOYXRpdmVMaWtlVmlldygpO1xuICAgICAgb3B0aW9ucy5wYXJlbnRWaWV3LnNob3dNb2RhbChjb21wb25lbnRWaWV3UmVmLmZpcnN0TmF0aXZlTGlrZVZpZXcsIHsgLi4ub3B0aW9ucywgY2xvc2VDYWxsYmFjayB9KTtcbiAgICB9KTtcbiAgfVxufVxuIl19