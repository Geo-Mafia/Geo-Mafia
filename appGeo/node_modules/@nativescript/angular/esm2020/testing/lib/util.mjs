import { NativeScriptModule } from '@nativescript/angular';
import { TestBed } from '@angular/core/testing';
import { platformBrowserDynamicTesting } from '@angular/platform-browser-dynamic/testing';
// import { NS_COMPILER_PROVIDERS } from "../../platform";
import { NativeScriptTestingModule } from './nativescript-testing.module';
import { testingRootView } from './test-root-view';
/**
 * Declared test contexts. When the suite is done this map should be empty if all lifecycle
 * calls have happened as expected.
 * @private
 */
const activeTestFixtures = [];
/**
 * Return a promise that resolves after (durationMs) milliseconds
 */
export function promiseWait(durationMs) {
    return () => new Promise((resolve) => setTimeout(() => resolve(), durationMs));
}
/**
 * Perform basic TestBed environment initialization. Call this once in the main entry point to your tests.
 * @deprecated
 */
export function nsTestBedInit() {
    TestBed.initTestEnvironment(NativeScriptTestingModule, platformBrowserDynamicTesting() // NS_COMPILER_PROVIDERS)
    );
}
/**
 * Helper for configuring a TestBed instance for rendering components for test. Ideally this
 * would not be needed, and in truth it's just a wrapper to eliminate some boilerplate. It
 * exists because when you need to specify `entryComponents` for a test the setup becomes quite
 * a bit more complex than if you're just doing a basic component test.
 *
 * More about entryComponents complexity: https://github.com/angular/angular/issues/12079
 *
 * Use:
 * ```
 *   beforeEach(nsTestBedBeforeEach([MyComponent,MyFailComponent]));
 * ```
 *
 * **NOTE*** Remember to pair with {@see nsTestBedAfterEach}
 *
 * @deprecated
 * @param components Any components that you will create during the test
 * @param providers Any services your tests depend on
 * @param imports Any module imports your tests depend on
 * @param entryComponents Any entry components that your tests depend on
 */
export function nsTestBedBeforeEach(components, providers = [], imports = [], entryComponents = []) {
    return (done) => {
        activeTestFixtures.push([]);
        // If there are no entry components we can take the simple path.
        if (entryComponents.length === 0) {
            TestBed.configureTestingModule({
                declarations: [...components],
                providers: [...providers],
                imports: [NativeScriptModule, ...imports],
            });
        }
        else {
            // If there are entry components, we have to reset the testing platform.
            //
            // There's got to be a better way... (o_O)
            // TestBed.resetTestEnvironment();
            // @NgModule({
            //     declarations: entryComponents,
            //     exports: entryComponents,
            //     entryComponents: entryComponents
            // })
            // class EntryComponentsTestModule {
            // }
            // TestBed.initTestEnvironment(
            //     EntryComponentsTestModule,
            //     platformBrowserDynamicTesting(NS_COMPILER_PROVIDERS)
            // );
            // TestBed.configureTestingModule({
            //     declarations: components,
            //     imports: [
            //         NativeScriptModule, NativeScriptTestingModule, CommonModule,
            //         ...imports
            //     ],
            //     providers: [...providers, ...NATIVESCRIPT_TESTING_PROVIDERS],
            // });
        }
        TestBed.compileComponents()
            .then(() => done())
            .catch((e) => {
            console.log(`Failed to instantiate test component with error: ${e}`);
            console.log(e.stack);
            done();
        });
    };
}
/**
 * Helper for a basic component TestBed clean up.
 * @param resetEnv When true the testing environment will be reset
 * @param resetFn When resetting the environment, use this init function
 * @deprecated
 */
export function nsTestBedAfterEach(resetEnv = true, resetFn = nsTestBedInit) {
    return () => {
        if (activeTestFixtures.length === 0) {
            throw new Error(`There are no more declared fixtures.` + `Did you call "nsTestBedBeforeEach" and "nsTestBedAfterEach" an equal number of times?`);
        }
        const root = testingRootView();
        const fixtures = activeTestFixtures.pop();
        fixtures.forEach((fixture) => {
            const fixtureView = fixture.nativeElement;
            if (fixtureView.parent === root) {
                root.removeChild(fixtureView);
            }
            fixture.destroy();
        });
        TestBed.resetTestingModule();
        if (resetEnv) {
            TestBed.resetTestEnvironment();
            resetFn();
        }
    };
}
/**
 * Render a component using the TestBed helper, and return a promise that resolves when the
 * ComponentFixture is fully initialized.
 * @deprecated
 */
export function nsTestBedRender(componentType) {
    const fixture = TestBed.createComponent(componentType);
    fixture.detectChanges();
    return (fixture
        .whenRenderingDone()
        // TODO(jd): it seems that the whenStable and whenRenderingDone utilities of ComponentFixture
        //           do not work as expected. I looked at how to fix it and it's not clear how to provide
        //           a {N} specific subclass, because ComponentFixture is newed directly rather than injected
        // What to do about it? Maybe fakeAsync can help? For now just setTimeout for 100ms (x_X)
        .then(promiseWait(100))
        .then(() => {
        const list = activeTestFixtures[activeTestFixtures.length - 1];
        if (!list) {
            console.warn('nsTestBedRender called without nsTestBedBeforeEach/nsTestBedAfter each. ' + "You are responsible for calling 'fixture.destroy()' when your test is done " + 'in order to clean up the components that are created.');
        }
        else {
            list.push(fixture);
        }
        return fixture;
    }));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL2FuZ3VsYXIvdGVzdGluZy9zcmMvbGliL3V0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFHM0QsT0FBTyxFQUFvQixPQUFPLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUVsRSxPQUFPLEVBQUUsNkJBQTZCLEVBQUUsTUFBTSwyQ0FBMkMsQ0FBQztBQUMxRiwwREFBMEQ7QUFDMUQsT0FBTyxFQUFrQyx5QkFBeUIsRUFBRSxNQUFNLCtCQUErQixDQUFDO0FBQzFHLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUVuRDs7OztHQUlHO0FBQ0gsTUFBTSxrQkFBa0IsR0FBOEIsRUFBRSxDQUFDO0FBRXpEOztHQUVHO0FBQ0gsTUFBTSxVQUFVLFdBQVcsQ0FBQyxVQUFrQjtJQUM1QyxPQUFPLEdBQUcsRUFBRSxDQUFDLElBQUksT0FBTyxDQUFPLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsT0FBTyxFQUFFLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQztBQUN2RixDQUFDO0FBRUQ7OztHQUdHO0FBQ0gsTUFBTSxVQUFVLGFBQWE7SUFDM0IsT0FBTyxDQUFDLG1CQUFtQixDQUN6Qix5QkFBeUIsRUFDekIsNkJBQTZCLEVBQUUsQ0FBQyx5QkFBeUI7S0FDMUQsQ0FBQztBQUNKLENBQUM7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FvQkc7QUFDSCxNQUFNLFVBQVUsbUJBQW1CLENBQUMsVUFBaUIsRUFBRSxZQUFtQixFQUFFLEVBQUUsVUFBaUIsRUFBRSxFQUFFLGtCQUF5QixFQUFFO0lBQzVILE9BQU8sQ0FBQyxJQUFJLEVBQUUsRUFBRTtRQUNkLGtCQUFrQixDQUFDLElBQUksQ0FBQyxFQUFFLENB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QUFDO1FBQy9ELElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDVCxPQUFPLENBQUMsSUFBSSxDQUFDLDBFQUEwRSxHQUFHLDZFQUE2RSxHQUFHLHVEQUF1RCxDQUFDLENBQUM7U0FDcE87YUFBTTtZQUNMLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDcEI7UUFDRCxPQUFPLE9BQU8sQ0FBQztJQUNqQixDQUFDLENBQUMsQ0FDTCxDQUFDO0FBQ0osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5hdGl2ZVNjcmlwdE1vZHVsZSB9IGZyb20gJ0BuYXRpdmVzY3JpcHQvYW5ndWxhcic7XG5pbXBvcnQgeyBWaWV3LCBGcmFtZSwgTGF5b3V0QmFzZSwgR3JpZExheW91dCB9IGZyb20gJ0BuYXRpdmVzY3JpcHQvY29yZSc7XG5pbXBvcnQgeyBOZ01vZHVsZSwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29tcG9uZW50Rml4dHVyZSwgVGVzdEJlZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUvdGVzdGluZyc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pY1Rlc3RpbmcgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMvdGVzdGluZyc7XG4vLyBpbXBvcnQgeyBOU19DT01QSUxFUl9QUk9WSURFUlMgfSBmcm9tIFwiLi4vLi4vcGxhdGZvcm1cIjtcbmltcG9ydCB7IE5BVElWRVNDUklQVF9URVNUSU5HX1BST1ZJREVSUywgTmF0aXZlU2NyaXB0VGVzdGluZ01vZHVsZSB9IGZyb20gJy4vbmF0aXZlc2NyaXB0LXRlc3RpbmcubW9kdWxlJztcbmltcG9ydCB7IHRlc3RpbmdSb290VmlldyB9IGZyb20gJy4vdGVzdC1yb290LXZpZXcnO1xuXG4vKipcbiAqIERlY2xhcmVkIHRlc3QgY29udGV4dHMuIFdoZW4gdGhlIHN1aXRlIGlzIGRvbmUgdGhpcyBtYXAgc2hvdWxkIGJlIGVtcHR5IGlmIGFsbCBsaWZlY3ljbGVcbiAqIGNhbGxzIGhhdmUgaGFwcGVuZWQgYXMgZXhwZWN0ZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBhY3RpdmVUZXN0Rml4dHVyZXM6IENvbXBvbmVudEZpeHR1cmU8YW55PltdW10gPSBbXTtcblxuLyoqXG4gKiBSZXR1cm4gYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgYWZ0ZXIgKGR1cmF0aW9uTXMpIG1pbGxpc2Vjb25kc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvbWlzZVdhaXQoZHVyYXRpb25NczogbnVtYmVyKSB7XG4gIHJldHVybiAoKSA9PiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4gc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKCksIGR1cmF0aW9uTXMpKTtcbn1cblxuLyoqXG4gKiBQZXJmb3JtIGJhc2ljIFRlc3RCZWQgZW52aXJvbm1lbnQgaW5pdGlhbGl6YXRpb24uIENhbGwgdGhpcyBvbmNlIGluIHRoZSBtYWluIGVudHJ5IHBvaW50IHRvIHlvdXIgdGVzdHMuXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gbnNUZXN0QmVkSW5pdCgpIHtcbiAgVGVzdEJlZC5pbml0VGVzdEVudmlyb25tZW50KFxuICAgIE5hdGl2ZVNjcmlwdFRlc3RpbmdNb2R1bGUsXG4gICAgcGxhdGZvcm1Ccm93c2VyRHluYW1pY1Rlc3RpbmcoKSAvLyBOU19DT01QSUxFUl9QUk9WSURFUlMpXG4gICk7XG59XG5cbi8qKlxuICogSGVscGVyIGZvciBjb25maWd1cmluZyBhIFRlc3RCZWQgaW5zdGFuY2UgZm9yIHJlbmRlcmluZyBjb21wb25lbnRzIGZvciB0ZXN0LiBJZGVhbGx5IHRoaXNcbiAqIHdvdWxkIG5vdCBiZSBuZWVkZWQsIGFuZCBpbiB0cnV0aCBpdCdzIGp1c3QgYSB3cmFwcGVyIHRvIGVsaW1pbmF0ZSBzb21lIGJvaWxlcnBsYXRlLiBJdFxuICogZXhpc3RzIGJlY2F1c2Ugd2hlbiB5b3UgbmVlZCB0byBzcGVjaWZ5IGBlbnRyeUNvbXBvbmVudHNgIGZvciBhIHRlc3QgdGhlIHNldHVwIGJlY29tZXMgcXVpdGVcbiAqIGEgYml0IG1vcmUgY29tcGxleCB0aGFuIGlmIHlvdSdyZSBqdXN0IGRvaW5nIGEgYmFzaWMgY29tcG9uZW50IHRlc3QuXG4gKlxuICogTW9yZSBhYm91dCBlbnRyeUNvbXBvbmVudHMgY29tcGxleGl0eTogaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTIwNzlcbiAqXG4gKiBVc2U6XG4gKiBgYGBcbiAqICAgYmVmb3JlRWFjaChuc1Rlc3RCZWRCZWZvcmVFYWNoKFtNeUNvbXBvbmVudCxNeUZhaWxDb21wb25lbnRdKSk7XG4gKiBgYGBcbiAqXG4gKiAqKk5PVEUqKiogUmVtZW1iZXIgdG8gcGFpciB3aXRoIHtAc2VlIG5zVGVzdEJlZEFmdGVyRWFjaH1cbiAqXG4gKiBAZGVwcmVjYXRlZFxuICogQHBhcmFtIGNvbXBvbmVudHMgQW55IGNvbXBvbmVudHMgdGhhdCB5b3Ugd2lsbCBjcmVhdGUgZHVyaW5nIHRoZSB0ZXN0XG4gKiBAcGFyYW0gcHJvdmlkZXJzIEFueSBzZXJ2aWNlcyB5b3VyIHRlc3RzIGRlcGVuZCBvblxuICogQHBhcmFtIGltcG9ydHMgQW55IG1vZHVsZSBpbXBvcnRzIHlvdXIgdGVzdHMgZGVwZW5kIG9uXG4gKiBAcGFyYW0gZW50cnlDb21wb25lbnRzIEFueSBlbnRyeSBjb21wb25lbnRzIHRoYXQgeW91ciB0ZXN0cyBkZXBlbmQgb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5zVGVzdEJlZEJlZm9yZUVhY2goY29tcG9uZW50czogYW55W10sIHByb3ZpZGVyczogYW55W10gPSBbXSwgaW1wb3J0czogYW55W10gPSBbXSwgZW50cnlDb21wb25lbnRzOiBhbnlbXSA9IFtdKSB7XG4gIHJldHVybiAoZG9uZSkgPT4ge1xuICAgIGFjdGl2ZVRlc3RGaXh0dXJlcy5wdXNoKFtdKTtcbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZW50cnkgY29tcG9uZW50cyB3ZSBjYW4gdGFrZSB0aGUgc2ltcGxlIHBhdGguXG4gICAgaWYgKGVudHJ5Q29tcG9uZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIFRlc3RCZWQuY29uZmlndXJlVGVzdGluZ01vZHVsZSh7XG4gICAgICAgIGRlY2xhcmF0aW9uczogWy4uLmNvbXBvbmVudHNdLFxuICAgICAgICBwcm92aWRlcnM6IFsuLi5wcm92aWRlcnNdLFxuICAgICAgICBpbXBvcnRzOiBbTmF0aXZlU2NyaXB0TW9kdWxlLCAuLi5pbXBvcnRzXSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGVyZSBhcmUgZW50cnkgY29tcG9uZW50cywgd2UgaGF2ZSB0byByZXNldCB0aGUgdGVzdGluZyBwbGF0Zm9ybS5cbiAgICAgIC8vXG4gICAgICAvLyBUaGVyZSdzIGdvdCB0byBiZSBhIGJldHRlciB3YXkuLi4gKG9fTylcbiAgICAgIC8vIFRlc3RCZWQucmVzZXRUZXN0RW52aXJvbm1lbnQoKTtcbiAgICAgIC8vIEBOZ01vZHVsZSh7XG4gICAgICAvLyAgICAgZGVjbGFyYXRpb25zOiBlbnRyeUNvbXBvbmVudHMsXG4gICAgICAvLyAgICAgZXhwb3J0czogZW50cnlDb21wb25lbnRzLFxuICAgICAgLy8gICAgIGVudHJ5Q29tcG9uZW50czogZW50cnlDb21wb25lbnRzXG4gICAgICAvLyB9KVxuICAgICAgLy8gY2xhc3MgRW50cnlDb21wb25lbnRzVGVzdE1vZHVsZSB7XG4gICAgICAvLyB9XG4gICAgICAvLyBUZXN0QmVkLmluaXRUZXN0RW52aXJvbm1lbnQoXG4gICAgICAvLyAgICAgRW50cnlDb21wb25lbnRzVGVzdE1vZHVsZSxcbiAgICAgIC8vICAgICBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljVGVzdGluZyhOU19DT01QSUxFUl9QUk9WSURFUlMpXG4gICAgICAvLyApO1xuICAgICAgLy8gVGVzdEJlZC5jb25maWd1cmVUZXN0aW5nTW9kdWxlKHtcbiAgICAgIC8vICAgICBkZWNsYXJhdGlvbnM6IGNvbXBvbmVudHMsXG4gICAgICAvLyAgICAgaW1wb3J0czogW1xuICAgICAgLy8gICAgICAgICBOYXRpdmVTY3JpcHRNb2R1bGUsIE5hdGl2ZVNjcmlwdFRlc3RpbmdNb2R1bGUsIENvbW1vbk1vZHVsZSxcbiAgICAgIC8vICAgICAgICAgLi4uaW1wb3J0c1xuICAgICAgLy8gICAgIF0sXG4gICAgICAvLyAgICAgcHJvdmlkZXJzOiBbLi4ucHJvdmlkZXJzLCAuLi5OQVRJVkVTQ1JJUFRfVEVTVElOR19QUk9WSURFUlNdLFxuICAgICAgLy8gfSk7XG4gICAgfVxuICAgIFRlc3RCZWQuY29tcGlsZUNvbXBvbmVudHMoKVxuICAgICAgLnRoZW4oKCkgPT4gZG9uZSgpKVxuICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBGYWlsZWQgdG8gaW5zdGFudGlhdGUgdGVzdCBjb21wb25lbnQgd2l0aCBlcnJvcjogJHtlfWApO1xuICAgICAgICBjb25zb2xlLmxvZyhlLnN0YWNrKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSk7XG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIGZvciBhIGJhc2ljIGNvbXBvbmVudCBUZXN0QmVkIGNsZWFuIHVwLlxuICogQHBhcmFtIHJlc2V0RW52IFdoZW4gdHJ1ZSB0aGUgdGVzdGluZyBlbnZpcm9ubWVudCB3aWxsIGJlIHJlc2V0XG4gKiBAcGFyYW0gcmVzZXRGbiBXaGVuIHJlc2V0dGluZyB0aGUgZW52aXJvbm1lbnQsIHVzZSB0aGlzIGluaXQgZnVuY3Rpb25cbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBuc1Rlc3RCZWRBZnRlckVhY2gocmVzZXRFbnYgPSB0cnVlLCByZXNldEZuID0gbnNUZXN0QmVkSW5pdCkge1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGlmIChhY3RpdmVUZXN0Rml4dHVyZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZXJlIGFyZSBubyBtb3JlIGRlY2xhcmVkIGZpeHR1cmVzLmAgKyBgRGlkIHlvdSBjYWxsIFwibnNUZXN0QmVkQmVmb3JlRWFjaFwiIGFuZCBcIm5zVGVzdEJlZEFmdGVyRWFjaFwiIGFuIGVxdWFsIG51bWJlciBvZiB0aW1lcz9gKTtcbiAgICB9XG4gICAgY29uc3Qgcm9vdCA9IHRlc3RpbmdSb290VmlldygpIGFzIExheW91dEJhc2U7XG4gICAgY29uc3QgZml4dHVyZXMgPSBhY3RpdmVUZXN0Rml4dHVyZXMucG9wKCk7XG4gICAgZml4dHVyZXMuZm9yRWFjaCgoZml4dHVyZSkgPT4ge1xuICAgICAgY29uc3QgZml4dHVyZVZpZXcgPSA8Vmlldz5maXh0dXJlLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICBpZiAoZml4dHVyZVZpZXcucGFyZW50ID09PSByb290KSB7XG4gICAgICAgIHJvb3QucmVtb3ZlQ2hpbGQoZml4dHVyZVZpZXcpO1xuICAgICAgfVxuICAgICAgZml4dHVyZS5kZXN0cm95KCk7XG4gICAgfSk7XG4gICAgVGVzdEJlZC5yZXNldFRlc3RpbmdNb2R1bGUoKTtcbiAgICBpZiAocmVzZXRFbnYpIHtcbiAgICAgIFRlc3RCZWQucmVzZXRUZXN0RW52aXJvbm1lbnQoKTtcbiAgICAgIHJlc2V0Rm4oKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogUmVuZGVyIGEgY29tcG9uZW50IHVzaW5nIHRoZSBUZXN0QmVkIGhlbHBlciwgYW5kIHJldHVybiBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZVxuICogQ29tcG9uZW50Rml4dHVyZSBpcyBmdWxseSBpbml0aWFsaXplZC5cbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBuc1Rlc3RCZWRSZW5kZXI8VD4oY29tcG9uZW50VHlwZTogVHlwZTxUPik6IFByb21pc2U8Q29tcG9uZW50Rml4dHVyZTxUPj4ge1xuICBjb25zdCBmaXh0dXJlID0gVGVzdEJlZC5jcmVhdGVDb21wb25lbnQoY29tcG9uZW50VHlwZSk7XG4gIGZpeHR1cmUuZGV0ZWN0Q2hhbmdlcygpO1xuICByZXR1cm4gKFxuICAgIGZpeHR1cmVcbiAgICAgIC53aGVuUmVuZGVyaW5nRG9uZSgpXG4gICAgICAvLyBUT0RPKGpkKTogaXQgc2VlbXMgdGhhdCB0aGUgd2hlblN0YWJsZSBhbmQgd2hlblJlbmRlcmluZ0RvbmUgdXRpbGl0aWVzIG9mIENvbXBvbmVudEZpeHR1cmVcbiAgICAgIC8vICAgICAgICAgICBkbyBub3Qgd29yayBhcyBleHBlY3RlZC4gSSBsb29rZWQgYXQgaG93IHRvIGZpeCBpdCBhbmQgaXQncyBub3QgY2xlYXIgaG93IHRvIHByb3ZpZGVcbiAgICAgIC8vICAgICAgICAgICBhIHtOfSBzcGVjaWZpYyBzdWJjbGFzcywgYmVjYXVzZSBDb21wb25lbnRGaXh0dXJlIGlzIG5ld2VkIGRpcmVjdGx5IHJhdGhlciB0aGFuIGluamVjdGVkXG4gICAgICAvLyBXaGF0IHRvIGRvIGFib3V0IGl0PyBNYXliZSBmYWtlQXN5bmMgY2FuIGhlbHA/IEZvciBub3cganVzdCBzZXRUaW1lb3V0IGZvciAxMDBtcyAoeF9YKVxuICAgICAgLnRoZW4ocHJvbWlzZVdhaXQoMTAwKSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgY29uc3QgbGlzdCA9IGFjdGl2ZVRlc3RGaXh0dXJlc1thY3RpdmVUZXN0Rml4dHVyZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICghbGlzdCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignbnNUZXN0QmVkUmVuZGVyIGNhbGxlZCB3aXRob3V0IG5zVGVzdEJlZEJlZm9yZUVhY2gvbnNUZXN0QmVkQWZ0ZXIgZWFjaC4gJyArIFwiWW91IGFyZSByZXNwb25zaWJsZSBmb3IgY2FsbGluZyAnZml4dHVyZS5kZXN0cm95KCknIHdoZW4geW91ciB0ZXN0IGlzIGRvbmUgXCIgKyAnaW4gb3JkZXIgdG8gY2xlYW4gdXAgdGhlIGNvbXBvbmVudHMgdGhhdCBhcmUgY3JlYXRlZC4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaXN0LnB1c2goZml4dHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpeHR1cmU7XG4gICAgICB9KVxuICApO1xufVxuIl19