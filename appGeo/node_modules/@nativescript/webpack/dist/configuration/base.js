"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const webpack_1 = require("webpack");
const fs_1 = require("fs");
const fork_ts_checker_webpack_plugin_1 = __importDefault(require("fork-ts-checker-webpack-plugin"));
const webpack_bundle_analyzer_1 = require("webpack-bundle-analyzer");
const terser_webpack_plugin_1 = __importDefault(require("terser-webpack-plugin"));
const PlatformSuffixPlugin_1 = require("../plugins/PlatformSuffixPlugin");
const fileReplacements_1 = require("../helpers/fileReplacements");
const copyRules_1 = require("../helpers/copyRules");
const WatchStatePlugin_1 = require("../plugins/WatchStatePlugin");
const project_1 = require("../helpers/project");
const dependencies_1 = require("../helpers/dependencies");
const dotEnv_1 = require("../helpers/dotEnv");
const index_1 = require("../index");
const config_1 = require("../helpers/config");
const host_1 = require("../helpers/host");
const platform_1 = require("../helpers/platform");
function default_1(config, env = index_1.env) {
    var _a, _b;
    const entryPath = (0, platform_1.getEntryPath)();
    const platform = (0, platform_1.getPlatformName)();
    const mode = env.production ? 'production' : 'development';
    // set mode
    config.mode(mode);
    // config.stats({
    // 	logging: 'verbose'
    // })
    // package.json is generated by the CLI with runtime options
    // this ensures it's not included in the bundle, but rather
    // resolved at runtime
    config.externals(['package.json', '~/package.json']);
    // disable marking built-in node modules as external
    // since they are not available at runtime and
    // should be bundled (requires polyfills)
    // for example `npm i --save url` to
    // polyfill the node url module.
    config.set('externalsPresets', {
        node: false,
    });
    const getSourceMapType = (map) => {
        const defaultSourceMap = 'inline-source-map';
        if (typeof map === 'undefined') {
            // source-maps disabled in production by default
            // enabled with --env.sourceMap=<type>
            if (mode === 'production') {
                // todo: we may set up SourceMapDevToolPlugin to generate external maps in production
                return false;
            }
            return defaultSourceMap;
        }
        // when --env.sourceMap=true is passed, use default
        if (typeof map === 'boolean' && map) {
            return defaultSourceMap;
        }
        // pass any type of sourceMap with --env.sourceMap=<type>
        return map;
    };
    config.devtool(getSourceMapType(env.sourceMap));
    // todo: figure out easiest way to make "node" target work in ns
    // rather than the custom ns target implementation that's hard to maintain
    // appears to be working - but we still have to deal with HMR
    config.target('node');
    config
        .entry('bundle')
        // ensure we load nativescript globals first
        .add('@nativescript/core/globals/index')
        .add('@nativescript/core/bundle-entry-points')
        .add(entryPath);
    // Add android app components to the bundle to SBG can generate the java classes
    if (platform === 'android') {
        const appComponents = env.appComponents || [];
        appComponents.push('@nativescript/core/ui/frame');
        appComponents.push('@nativescript/core/ui/frame/activity');
        appComponents.map((component) => {
            config.entry('bundle').add(component);
        });
    }
    // inspector_modules
    config.when(shouldIncludeInspectorModules(), (config) => {
        config
            .entry('tns_modules/inspector_modules')
            .add('@nativescript/core/inspector_modules');
    });
    config.output
        .path((0, platform_1.getAbsoluteDistPath)())
        .pathinfo(false)
        .publicPath('')
        .libraryTarget('commonjs')
        .globalObject('global')
        .set('clean', true);
    config.watchOptions({
        ignored: [
            `${(0, project_1.getProjectFilePath)('platforms')}/**`,
            `${(0, project_1.getProjectFilePath)((_a = env.appResourcesPath) !== null && _a !== void 0 ? _a : 'App_Resources')}/**`,
        ],
    });
    // allow watching node_modules
    config.when(env.watchNodeModules, (config) => {
        config.set('snapshot', {
            managedPaths: [],
        });
    });
    // Set up Terser options
    config.optimization.minimizer('TerserPlugin').use(terser_webpack_plugin_1.default, [
        {
            terserOptions: {
                // @ts-ignore - https://github.com/webpack-contrib/terser-webpack-plugin/pull/463 broke the types?
                compress: {
                    collapse_vars: platform !== 'android',
                    sequences: platform !== 'android',
                    keep_infinity: true,
                    drop_console: mode === 'production',
                    global_defs: {
                        __UGLIFIED__: true,
                    },
                },
                keep_fnames: true,
                keep_classnames: true,
            },
        },
    ]);
    config.optimization.runtimeChunk('single');
    config.optimization.splitChunks({
        cacheGroups: {
            defaultVendor: {
                test: /[\\/]node_modules[\\/]/,
                priority: -10,
                name: 'vendor',
                chunks: 'all',
            },
        },
    });
    // look for loaders in
    //  - node_modules/@nativescript/webpack/dist/loaders
    //  - node_modules/@nativescript/webpack/node_modules
    //  - node_modules
    // allows for cleaner rules, without having to specify full paths to loaders
    config.resolveLoader.modules
        .add((0, path_1.resolve)(__dirname, '../loaders'))
        .add((0, path_1.resolve)(__dirname, '../../node_modules'))
        .add((0, project_1.getProjectFilePath)('node_modules'))
        .add('node_modules');
    config.resolve.extensions
        .add(`.${platform}.ts`)
        .add('.ts')
        .add(`.${platform}.js`)
        .add('.js')
        .add(`.${platform}.mjs`)
        .add('.mjs')
        .add(`.${platform}.css`)
        .add('.css')
        .add(`.${platform}.scss`)
        .add('.scss')
        .add(`.${platform}.json`)
        .add('.json');
    // base aliases
    config.resolve.alias.set('~', (0, platform_1.getEntryDirPath)()).set('@', (0, platform_1.getEntryDirPath)());
    // resolve symlinks
    config.resolve.symlinks(true);
    // resolve modules in project node_modules first
    // then fall-back to default node resolution (up the parent folder chain)
    config.resolve.modules
        .add((0, project_1.getProjectFilePath)('node_modules'))
        .add('node_modules');
    config.module
        .rule('bundle')
        .enforce('post')
        .test(entryPath)
        .use('app-css-loader')
        .loader('app-css-loader')
        .options({
        platform,
    })
        .end();
    config.when(env.hmr, (config) => {
        config.module
            .rule('bundle')
            .use('nativescript-hot-loader')
            .loader('nativescript-hot-loader')
            .options({
            injectHMRRuntime: true,
        });
    });
    // enable profiling with --env.profile
    config.when(env.profile, (config) => {
        config.profile(true);
    });
    // worker-loader should be declared before ts-loader
    config.module
        .rule('workers')
        .test(/\.(mjs|js|ts)$/)
        .use('nativescript-worker-loader')
        .loader('nativescript-worker-loader');
    // set up ts support
    config.module
        .rule('ts')
        .test([/\.ts$/])
        .use('ts-loader')
        .loader('ts-loader')
        .options({
        // todo: perhaps we can provide a default tsconfig
        // and use that if the project doesn't have one?
        // configFile: '',
        transpileOnly: true,
        allowTsInNodeModules: true,
        compilerOptions: {
            sourceMap: true,
            declaration: false,
        },
        getCustomTransformers() {
            return {
                before: [require('../transformers/NativeClass').default],
            };
        },
    });
    // Use Fork TS Checker to do type checking in a separate non-blocking process
    config.when((0, dependencies_1.hasDependency)('typescript'), (config) => {
        config
            .plugin('ForkTsCheckerWebpackPlugin')
            .use(fork_ts_checker_webpack_plugin_1.default, [
            {
                async: !!env.watch,
                typescript: {
                    memoryLimit: 4096,
                },
            },
        ]);
    });
    // set up js
    config.module
        .rule('js')
        .test(/\.js$/)
        .exclude.add(/node_modules/)
        .end();
    // config.resolve.extensions.add('.xml');
    // set up xml
    config.module
        .rule('xml')
        .test(/\.xml$/)
        .use('xml-namespace-loader')
        .loader('xml-namespace-loader');
    // default PostCSS options to use
    // projects can change settings
    // via postcss.config.js
    const postCSSOptions = {
        postcssOptions: {
            plugins: [
                // inlines @imported stylesheets
                [
                    'postcss-import',
                    {
                        // custom resolver to resolve platform extensions in @import statements
                        // ie. @import "foo.css" would import "foo.ios.css" if the platform is ios and it exists
                        resolve(id, baseDir, importOptions) {
                            const ext = (0, path_1.extname)(id);
                            const platformExt = ext ? `.${platform}${ext}` : '';
                            if (!id.includes(platformExt)) {
                                const platformRequest = id.replace(ext, platformExt);
                                const extPath = (0, path_1.resolve)(baseDir, platformRequest);
                                try {
                                    return require.resolve(platformRequest, {
                                        paths: [baseDir],
                                    });
                                }
                                catch (_a) { }
                                if ((0, fs_1.existsSync)(extPath)) {
                                    console.log(`resolving "${id}" to "${platformRequest}"`);
                                    return extPath;
                                }
                            }
                            // fallback to postcss-import default resolution
                            return id;
                        },
                    },
                ],
            ],
        },
    };
    // set up css
    config.module
        .rule('css')
        .test(/\.css$/)
        .use('apply-css-loader')
        .loader('apply-css-loader')
        .end()
        .use('css2json-loader')
        .loader('css2json-loader')
        .end()
        .use('postcss-loader')
        .loader('postcss-loader')
        .options(postCSSOptions);
    // set up scss
    config.module
        .rule('scss')
        .test(/\.scss$/)
        .use('apply-css-loader')
        .loader('apply-css-loader')
        .end()
        .use('css2json-loader')
        .loader('css2json-loader')
        .end()
        .use('postcss-loader')
        .loader('postcss-loader')
        .options(postCSSOptions)
        .end()
        .use('sass-loader')
        .loader('sass-loader');
    // config.plugin('NormalModuleReplacementPlugin').use(NormalModuleReplacementPlugin, [
    // 	/.*/,
    // 	request => {
    // 		if (new RegExp(`\.${platform}\..+$`).test(request.request)) {
    // 			request.rawRequest = request.rawRequest.replace(`.${platform}.`, '.')
    // 			console.log(request)
    // 		}
    // 	}
    // ])
    config.plugin('PlatformSuffixPlugin').use(PlatformSuffixPlugin_1.PlatformSuffixPlugin, [
        {
            platform,
        },
    ]);
    // Makes sure that require.context will never include
    // App_Resources, regardless where they are located.
    config
        .plugin('ContextExclusionPlugin|App_Resources')
        .use(webpack_1.ContextExclusionPlugin, [new RegExp(`(.*)App_Resources(.*)`)]);
    // Makes sure that require.context will never include code from
    // another platform (ie .android.ts when building for ios)
    const otherPlatformsRE = (0, platform_1.getAvailablePlatforms)()
        .filter((platform) => platform !== (0, platform_1.getPlatformName)())
        .join('|');
    config
        .plugin('ContextExclusionPlugin|Other_Platforms')
        .use(webpack_1.ContextExclusionPlugin, [
        new RegExp(`\\.(${otherPlatformsRE})\\.(\\w+)$`),
    ]);
    // Filter common undesirable warnings
    config.set('ignoreWarnings', ((_b = config.get('ignoreWarnings')) !== null && _b !== void 0 ? _b : []).concat([
        /**
         * This rule hides
         * +-----------------------------------------------------------------------------------------+
         * | WARNING in ./node_modules/@angular/core/fesm2015/core.js 29714:15-102                   |
         * | System.import() is deprecated and will be removed soon. Use import() instead.           |
         * | For more info visit https://webpack.js.org/guides/code-splitting/                       |
         * +-----------------------------------------------------------------------------------------+
         */
        /System.import\(\) is deprecated/,
    ]));
    // todo: refine defaults
    config.plugin('DefinePlugin').use(webpack_1.DefinePlugin, [
        {
            __DEV__: mode === 'development',
            __NS_WEBPACK__: true,
            __NS_ENV_VERBOSE__: !!env.verbose,
            __NS_DEV_HOST_IPS__: mode === 'development' ? JSON.stringify((0, host_1.getIPS)()) : `[]`,
            __CSS_PARSER__: JSON.stringify((0, config_1.getValue)('cssParser', 'css-tree')),
            __UI_USE_XML_PARSER__: true,
            __UI_USE_EXTERNAL_RENDERER__: false,
            __ANDROID__: platform === 'android',
            __IOS__: platform === 'ios',
            /* for compat only */ 'global.isAndroid': platform === 'android',
            /* for compat only */ 'global.isIOS': platform === 'ios',
            process: 'global.process',
            // enable testID when using --env.e2e
            __USE_TEST_ID__: !!env.e2e,
            // todo: ?!?!
            // profile: '() => {}',
        },
    ]);
    // enable DotEnv
    (0, dotEnv_1.applyDotEnvPlugin)(config);
    // replacements
    (0, fileReplacements_1.applyFileReplacements)(config);
    // set up default copy rules
    (0, copyRules_1.addCopyRule)('assets/**');
    (0, copyRules_1.addCopyRule)('fonts/**');
    (0, copyRules_1.addCopyRule)('**/*.+(jpg|png)');
    (0, copyRules_1.applyCopyRules)(config);
    config.plugin('WatchStatePlugin').use(WatchStatePlugin_1.WatchStatePlugin);
    config.when(env.hmr, (config) => {
        config.plugin('HotModuleReplacementPlugin').use(webpack_1.HotModuleReplacementPlugin);
    });
    config.when(env.report, (config) => {
        config.plugin('BundleAnalyzerPlugin').use(webpack_bundle_analyzer_1.BundleAnalyzerPlugin, [
            {
                analyzerMode: 'static',
                generateStatsFile: true,
                openAnalyzer: false,
                reportFilename: (0, project_1.getProjectFilePath)('report/report.html'),
                statsFilename: (0, project_1.getProjectFilePath)('report/stats.json'),
            },
        ]);
    });
    return config;
}
exports.default = default_1;
function shouldIncludeInspectorModules() {
    const platform = (0, platform_1.getPlatformName)();
    // todo: check if core modules are external
    // todo: check if we are testing
    return platform === 'ios';
}
//# sourceMappingURL=base.js.map