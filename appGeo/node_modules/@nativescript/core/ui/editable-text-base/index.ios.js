import { EditableTextBase as EditableTextBaseCommon, autofillTypeProperty, keyboardTypeProperty, returnKeyTypeProperty, autocapitalizationTypeProperty, autocorrectProperty } from './editable-text-base-common';
export * from './editable-text-base-common';
export class EditableTextBase extends EditableTextBaseCommon {
    dismissSoftInput() {
        this.nativeTextViewProtected.resignFirstResponder();
        this.notify({ eventName: EditableTextBase.blurEvent, object: this });
    }
    [keyboardTypeProperty.getDefault]() {
        const keyboardType = this.nativeTextViewProtected.keyboardType;
        switch (keyboardType) {
            case 2 /* UIKeyboardType.NumbersAndPunctuation */:
                return 'number';
            case 5 /* UIKeyboardType.PhonePad */:
                return 'phone';
            case 3 /* UIKeyboardType.URL */:
                return 'url';
            case 7 /* UIKeyboardType.EmailAddress */:
                return 'email';
            case 4 /* UIKeyboardType.NumberPad */:
                return 'integer';
            default:
                return keyboardType.toString();
        }
    }
    [keyboardTypeProperty.setNative](value) {
        let newKeyboardType;
        switch (value) {
            case 'datetime':
                newKeyboardType = 2 /* UIKeyboardType.NumbersAndPunctuation */;
                break;
            case 'phone':
                newKeyboardType = 5 /* UIKeyboardType.PhonePad */;
                break;
            case 'number':
                newKeyboardType = 2 /* UIKeyboardType.NumbersAndPunctuation */;
                break;
            case 'url':
                newKeyboardType = 3 /* UIKeyboardType.URL */;
                break;
            case 'email':
                newKeyboardType = 7 /* UIKeyboardType.EmailAddress */;
                break;
            case 'integer':
                newKeyboardType = 4 /* UIKeyboardType.NumberPad */;
                break;
            default:
                const kt = +value;
                if (!isNaN(kt)) {
                    newKeyboardType = kt;
                }
                else {
                    newKeyboardType = 0 /* UIKeyboardType.Default */;
                }
                break;
        }
        this.nativeTextViewProtected.keyboardType = newKeyboardType;
    }
    [autofillTypeProperty.setNative](value) {
        let newTextContentType;
        switch (value) {
            case 'phone':
                newTextContentType = UITextContentTypeTelephoneNumber;
                break;
            case 'postalCode':
                newTextContentType = UITextContentTypePostalCode;
                break;
            case 'creditCardNumber':
                newTextContentType = UITextContentTypeCreditCardNumber;
                break;
            case 'email':
                newTextContentType = UITextContentTypeEmailAddress;
                break;
            case 'name':
                newTextContentType = UITextContentTypeName;
                break;
            case 'username':
                newTextContentType = UITextContentTypeUsername;
                break;
            case 'password':
                newTextContentType = UITextContentTypePassword;
                break;
            case 'none':
                newTextContentType = null;
            default:
                newTextContentType = value;
                break;
        }
        this.nativeTextViewProtected.textContentType = newTextContentType;
    }
    [returnKeyTypeProperty.getDefault]() {
        const returnKeyType = this.nativeTextViewProtected.returnKeyType;
        switch (returnKeyType) {
            case 9 /* UIReturnKeyType.Done */:
                return 'done';
            case 1 /* UIReturnKeyType.Go */:
                return 'go';
            case 4 /* UIReturnKeyType.Next */:
                return 'next';
            case 6 /* UIReturnKeyType.Search */:
                return 'search';
            case 7 /* UIReturnKeyType.Send */:
                return 'send';
            default:
                return returnKeyType.toString();
        }
    }
    [returnKeyTypeProperty.setNative](value) {
        let newValue;
        switch (value) {
            case 'done':
                newValue = 9 /* UIReturnKeyType.Done */;
                break;
            case 'go':
                newValue = 1 /* UIReturnKeyType.Go */;
                break;
            case 'next':
                newValue = 4 /* UIReturnKeyType.Next */;
                break;
            case 'search':
                newValue = 6 /* UIReturnKeyType.Search */;
                break;
            case 'send':
                newValue = 7 /* UIReturnKeyType.Send */;
                break;
            default:
                const rkt = +value;
                if (!isNaN(rkt)) {
                    newValue = rkt;
                }
                else {
                    newValue = 0 /* UIKeyboardType.Default */;
                }
                break;
        }
        this.nativeTextViewProtected.returnKeyType = newValue;
    }
    [autocapitalizationTypeProperty.getDefault]() {
        const autocapitalizationType = this.nativeTextViewProtected.autocapitalizationType;
        switch (autocapitalizationType) {
            case 0 /* UITextAutocapitalizationType.None */:
                return 'none';
            case 1 /* UITextAutocapitalizationType.Words */:
                return 'words';
            case 2 /* UITextAutocapitalizationType.Sentences */:
                return 'sentences';
            case 3 /* UITextAutocapitalizationType.AllCharacters */:
                return 'allcharacters';
            default:
                throw new Error('Invalid autocapitalizationType value:' + autocapitalizationType);
        }
    }
    [autocapitalizationTypeProperty.setNative](value) {
        let newValue;
        switch (value) {
            case 'none':
                newValue = 0 /* UITextAutocapitalizationType.None */;
                break;
            case 'words':
                newValue = 1 /* UITextAutocapitalizationType.Words */;
                break;
            case 'sentences':
                newValue = 2 /* UITextAutocapitalizationType.Sentences */;
                break;
            case 'allcharacters':
                newValue = 3 /* UITextAutocapitalizationType.AllCharacters */;
                break;
            default:
                newValue = 2 /* UITextAutocapitalizationType.Sentences */;
                break;
        }
        this.nativeTextViewProtected.autocapitalizationType = newValue;
    }
    [autocorrectProperty.getDefault]() {
        const autocorrectionType = this.nativeTextViewProtected.autocorrectionType;
        switch (autocorrectionType) {
            case 2 /* UITextAutocorrectionType.Yes */:
                return true;
            case 1 /* UITextAutocorrectionType.No */:
                return false;
            case 0 /* UITextAutocorrectionType.Default */:
                return autocorrectionType;
        }
    }
    [autocorrectProperty.setNative](value) {
        let newValue;
        if (typeof value === 'number') {
            newValue = 0 /* UITextAutocorrectionType.Default */;
        }
        else if (value) {
            newValue = 2 /* UITextAutocorrectionType.Yes */;
        }
        else {
            newValue = 1 /* UITextAutocorrectionType.No */;
        }
        this.nativeTextViewProtected.autocorrectionType = newValue;
    }
    setSelection(start, stop) {
        const view = this.nativeTextViewProtected;
        if (view) {
            if (stop !== undefined) {
                const begin = view.beginningOfDocument;
                const fromPosition = view.positionFromPositionOffset(begin, start);
                const toPosition = view.positionFromPositionOffset(begin, stop);
                view.selectedTextRange = view.textRangeFromPositionToPosition(fromPosition, toPosition);
            }
            else {
                const begin = view.beginningOfDocument;
                const pos = view.positionFromPositionOffset(begin, start);
                view.selectedTextRange = view.textRangeFromPositionToPosition(pos, pos);
            }
        }
    }
}
export function _updateCharactersInRangeReplacementString(formattedText, rangeLocation, rangeLength, replacementString) {
    const deletingText = !replacementString;
    let currentLocation = 0;
    for (let i = 0, length = formattedText.spans.length; i < length; i++) {
        const span = formattedText.spans.getItem(i);
        if (currentLocation <= rangeLocation && rangeLocation < currentLocation + span.text.length) {
            const newText = splice(span.text, rangeLocation - currentLocation, deletingText ? rangeLength : 0, replacementString);
            span._setTextInternal(newText);
            return;
        }
        currentLocation += span.text.length;
    }
}
/*
 * @param {String} value The string to splice.
 * @param {number} start Index at which to start changing the string.
 * @param {number} delCount An integer indicating the number of old chars to remove.
 * @param {string} newSubStr The String that is spliced in.
 * @return {string} A new string with the spliced substring.function splice(value: string, start: number, delCount: number, newSubStr: string) {
 */
function splice(value, start, delCount, newSubStr) {
    return value.slice(0, start) + newSubStr + value.slice(start + Math.abs(delCount));
}
//# sourceMappingURL=index.ios.js.map